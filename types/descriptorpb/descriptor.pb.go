// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.1.2
// source: github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto

package descriptorpb

import (
	base64 "encoding/base64"
	binary "encoding/binary"
	io "io"
	math "math"
	strconv "strconv"
	strings "strings"
	unsafe "unsafe"

	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	errors "github.com/pkg/errors"
)

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// The messages in this file describe the definitions found in .proto files.
// A valid .proto file can be translated directly to a FileDescriptorProto
// without any other information (e.g. without reading its imports).

// The full set of known editions.
type Edition int32

const (
	// A placeholder for an unknown edition value.
	Edition_EDITION_UNKNOWN Edition = 0
	// Legacy syntax "editions".  These pre-date editions, but behave much like
	// distinct editions.  These can't be used to specify the edition of proto
	// files, but feature definitions must supply proto2/proto3 defaults for
	// backwards compatibility.
	Edition_EDITION_PROTO2 Edition = 998
	Edition_EDITION_PROTO3 Edition = 999
	// Editions that have been released.  The specific values are arbitrary and
	// should not be depended on, but they will always be time-ordered for easy
	// comparison.
	Edition_EDITION_2023 Edition = 1000
	Edition_EDITION_2024 Edition = 1001
	// Placeholder editions for testing feature resolution.  These should not be
	// used or relyed on outside of tests.
	Edition_EDITION_1_TEST_ONLY     Edition = 1
	Edition_EDITION_2_TEST_ONLY     Edition = 2
	Edition_EDITION_99997_TEST_ONLY Edition = 99997
	Edition_EDITION_99998_TEST_ONLY Edition = 99998
	Edition_EDITION_99999_TEST_ONLY Edition = 99999
	// Placeholder for specifying unbounded edition support.  This should only
	// ever be used by plugins that can expect to never require any changes to
	// support a new edition.
	Edition_EDITION_MAX Edition = 2147483647
)

// Enum value maps for Edition.
var (
	Edition_name = map[int32]string{
		0:          "EDITION_UNKNOWN",
		998:        "EDITION_PROTO2",
		999:        "EDITION_PROTO3",
		1000:       "EDITION_2023",
		1001:       "EDITION_2024",
		1:          "EDITION_1_TEST_ONLY",
		2:          "EDITION_2_TEST_ONLY",
		99997:      "EDITION_99997_TEST_ONLY",
		99998:      "EDITION_99998_TEST_ONLY",
		99999:      "EDITION_99999_TEST_ONLY",
		2147483647: "EDITION_MAX",
	}
	Edition_value = map[string]int32{
		"EDITION_UNKNOWN":         0,
		"EDITION_PROTO2":          998,
		"EDITION_PROTO3":          999,
		"EDITION_2023":            1000,
		"EDITION_2024":            1001,
		"EDITION_1_TEST_ONLY":     1,
		"EDITION_2_TEST_ONLY":     2,
		"EDITION_99997_TEST_ONLY": 99997,
		"EDITION_99998_TEST_ONLY": 99998,
		"EDITION_99999_TEST_ONLY": 99999,
		"EDITION_MAX":             2147483647,
	}
)

func (x Edition) Enum() *Edition {
	p := new(Edition)
	*p = x
	return p
}

func (x Edition) String() string {
	name, valid := Edition_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// The verification state of the extension range.
type ExtensionRangeOptions_VerificationState int32

const (
	// All the extensions of the range must be declared.
	ExtensionRangeOptions_DECLARATION ExtensionRangeOptions_VerificationState = 0
	ExtensionRangeOptions_UNVERIFIED  ExtensionRangeOptions_VerificationState = 1
)

// Enum value maps for ExtensionRangeOptions_VerificationState.
var (
	ExtensionRangeOptions_VerificationState_name = map[int32]string{
		0: "DECLARATION",
		1: "UNVERIFIED",
	}
	ExtensionRangeOptions_VerificationState_value = map[string]int32{
		"DECLARATION": 0,
		"UNVERIFIED":  1,
	}
)

func (x ExtensionRangeOptions_VerificationState) Enum() *ExtensionRangeOptions_VerificationState {
	p := new(ExtensionRangeOptions_VerificationState)
	*p = x
	return p
}

func (x ExtensionRangeOptions_VerificationState) String() string {
	name, valid := ExtensionRangeOptions_VerificationState_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FieldDescriptorProto_Type int32

const (
	// 0 is reserved for errors.
	// Order is weird for historical reasons.
	FieldDescriptorProto_TYPE_DOUBLE FieldDescriptorProto_Type = 1
	FieldDescriptorProto_TYPE_FLOAT  FieldDescriptorProto_Type = 2
	// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
	// negative values are likely.
	FieldDescriptorProto_TYPE_INT64  FieldDescriptorProto_Type = 3
	FieldDescriptorProto_TYPE_UINT64 FieldDescriptorProto_Type = 4
	// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
	// negative values are likely.
	FieldDescriptorProto_TYPE_INT32   FieldDescriptorProto_Type = 5
	FieldDescriptorProto_TYPE_FIXED64 FieldDescriptorProto_Type = 6
	FieldDescriptorProto_TYPE_FIXED32 FieldDescriptorProto_Type = 7
	FieldDescriptorProto_TYPE_BOOL    FieldDescriptorProto_Type = 8
	FieldDescriptorProto_TYPE_STRING  FieldDescriptorProto_Type = 9
	// Tag-delimited aggregate.
	// Group type is deprecated and not supported after google.protobuf. However, Proto3
	// implementations should still be able to parse the group wire format and
	// treat group fields as unknown fields.  In Editions, the group wire format
	// can be enabled via the `message_encoding` feature.
	FieldDescriptorProto_TYPE_GROUP   FieldDescriptorProto_Type = 10
	FieldDescriptorProto_TYPE_MESSAGE FieldDescriptorProto_Type = 11 // Length-delimited aggregate.
	// New in version 2.
	FieldDescriptorProto_TYPE_BYTES    FieldDescriptorProto_Type = 12
	FieldDescriptorProto_TYPE_UINT32   FieldDescriptorProto_Type = 13
	FieldDescriptorProto_TYPE_ENUM     FieldDescriptorProto_Type = 14
	FieldDescriptorProto_TYPE_SFIXED32 FieldDescriptorProto_Type = 15
	FieldDescriptorProto_TYPE_SFIXED64 FieldDescriptorProto_Type = 16
	FieldDescriptorProto_TYPE_SINT32   FieldDescriptorProto_Type = 17 // Uses ZigZag encoding.
	FieldDescriptorProto_TYPE_SINT64   FieldDescriptorProto_Type = 18 // Uses ZigZag encoding.
)

// Enum value maps for FieldDescriptorProto_Type.
var (
	FieldDescriptorProto_Type_name = map[int32]string{
		1:  "TYPE_DOUBLE",
		2:  "TYPE_FLOAT",
		3:  "TYPE_INT64",
		4:  "TYPE_UINT64",
		5:  "TYPE_INT32",
		6:  "TYPE_FIXED64",
		7:  "TYPE_FIXED32",
		8:  "TYPE_BOOL",
		9:  "TYPE_STRING",
		10: "TYPE_GROUP",
		11: "TYPE_MESSAGE",
		12: "TYPE_BYTES",
		13: "TYPE_UINT32",
		14: "TYPE_ENUM",
		15: "TYPE_SFIXED32",
		16: "TYPE_SFIXED64",
		17: "TYPE_SINT32",
		18: "TYPE_SINT64",
	}
	FieldDescriptorProto_Type_value = map[string]int32{
		"TYPE_DOUBLE":   1,
		"TYPE_FLOAT":    2,
		"TYPE_INT64":    3,
		"TYPE_UINT64":   4,
		"TYPE_INT32":    5,
		"TYPE_FIXED64":  6,
		"TYPE_FIXED32":  7,
		"TYPE_BOOL":     8,
		"TYPE_STRING":   9,
		"TYPE_GROUP":    10,
		"TYPE_MESSAGE":  11,
		"TYPE_BYTES":    12,
		"TYPE_UINT32":   13,
		"TYPE_ENUM":     14,
		"TYPE_SFIXED32": 15,
		"TYPE_SFIXED64": 16,
		"TYPE_SINT32":   17,
		"TYPE_SINT64":   18,
	}
)

func (x FieldDescriptorProto_Type) Enum() *FieldDescriptorProto_Type {
	p := new(FieldDescriptorProto_Type)
	*p = x
	return p
}

func (x FieldDescriptorProto_Type) String() string {
	name, valid := FieldDescriptorProto_Type_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FieldDescriptorProto_Label int32

const (
	// 0 is reserved for errors
	FieldDescriptorProto_LABEL_OPTIONAL FieldDescriptorProto_Label = 1
	FieldDescriptorProto_LABEL_REPEATED FieldDescriptorProto_Label = 3
	// The required label is only allowed in google.protobuf.  In proto3 and Editions
	// it's explicitly prohibited.  In Editions, the `field_presence` feature
	// can be used to get this behavior.
	FieldDescriptorProto_LABEL_REQUIRED FieldDescriptorProto_Label = 2
)

// Enum value maps for FieldDescriptorProto_Label.
var (
	FieldDescriptorProto_Label_name = map[int32]string{
		1: "LABEL_OPTIONAL",
		3: "LABEL_REPEATED",
		2: "LABEL_REQUIRED",
	}
	FieldDescriptorProto_Label_value = map[string]int32{
		"LABEL_OPTIONAL": 1,
		"LABEL_REPEATED": 3,
		"LABEL_REQUIRED": 2,
	}
)

func (x FieldDescriptorProto_Label) Enum() *FieldDescriptorProto_Label {
	p := new(FieldDescriptorProto_Label)
	*p = x
	return p
}

func (x FieldDescriptorProto_Label) String() string {
	name, valid := FieldDescriptorProto_Label_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Generated classes can be optimized for speed or code size.
type FileOptions_OptimizeMode int32

const (
	FileOptions_SPEED FileOptions_OptimizeMode = 1 // Generate complete code for parsing, serialization,
	// etc.
	FileOptions_CODE_SIZE    FileOptions_OptimizeMode = 2 // Use ReflectionOps to implement these methods.
	FileOptions_LITE_RUNTIME FileOptions_OptimizeMode = 3 // Generate code using MessageLite and the lite runtime.
)

// Enum value maps for FileOptions_OptimizeMode.
var (
	FileOptions_OptimizeMode_name = map[int32]string{
		1: "SPEED",
		2: "CODE_SIZE",
		3: "LITE_RUNTIME",
	}
	FileOptions_OptimizeMode_value = map[string]int32{
		"SPEED":        1,
		"CODE_SIZE":    2,
		"LITE_RUNTIME": 3,
	}
)

func (x FileOptions_OptimizeMode) Enum() *FileOptions_OptimizeMode {
	p := new(FileOptions_OptimizeMode)
	*p = x
	return p
}

func (x FileOptions_OptimizeMode) String() string {
	name, valid := FileOptions_OptimizeMode_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FieldOptions_CType int32

const (
	// Default mode.
	FieldOptions_STRING FieldOptions_CType = 0
	// The option [ctype=CORD] may be applied to a non-repeated field of type
	// "bytes". It indicates that in C++, the data should be stored in a Cord
	// instead of a string.  For very large strings, this may reduce memory
	// fragmentation. It may also allow better performance when parsing from a
	// Cord, or when parsing with aliasing enabled, as the parsed Cord may then
	// alias the original buffer.
	FieldOptions_CORD         FieldOptions_CType = 1
	FieldOptions_STRING_PIECE FieldOptions_CType = 2
)

// Enum value maps for FieldOptions_CType.
var (
	FieldOptions_CType_name = map[int32]string{
		0: "STRING",
		1: "CORD",
		2: "STRING_PIECE",
	}
	FieldOptions_CType_value = map[string]int32{
		"STRING":       0,
		"CORD":         1,
		"STRING_PIECE": 2,
	}
)

func (x FieldOptions_CType) Enum() *FieldOptions_CType {
	p := new(FieldOptions_CType)
	*p = x
	return p
}

func (x FieldOptions_CType) String() string {
	name, valid := FieldOptions_CType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FieldOptions_JSType int32

const (
	// Use the default type.
	FieldOptions_JS_NORMAL FieldOptions_JSType = 0
	// Use JavaScript strings.
	FieldOptions_JS_STRING FieldOptions_JSType = 1
	// Use JavaScript numbers.
	FieldOptions_JS_NUMBER FieldOptions_JSType = 2
)

// Enum value maps for FieldOptions_JSType.
var (
	FieldOptions_JSType_name = map[int32]string{
		0: "JS_NORMAL",
		1: "JS_STRING",
		2: "JS_NUMBER",
	}
	FieldOptions_JSType_value = map[string]int32{
		"JS_NORMAL": 0,
		"JS_STRING": 1,
		"JS_NUMBER": 2,
	}
)

func (x FieldOptions_JSType) Enum() *FieldOptions_JSType {
	p := new(FieldOptions_JSType)
	*p = x
	return p
}

func (x FieldOptions_JSType) String() string {
	name, valid := FieldOptions_JSType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// If set to RETENTION_SOURCE, the option will be omitted from the binary.
// Note: as of January 2023, support for this is in progress and does not yet
// have an effect (b/264593489).
type FieldOptions_OptionRetention int32

const (
	FieldOptions_RETENTION_UNKNOWN FieldOptions_OptionRetention = 0
	FieldOptions_RETENTION_RUNTIME FieldOptions_OptionRetention = 1
	FieldOptions_RETENTION_SOURCE  FieldOptions_OptionRetention = 2
)

// Enum value maps for FieldOptions_OptionRetention.
var (
	FieldOptions_OptionRetention_name = map[int32]string{
		0: "RETENTION_UNKNOWN",
		1: "RETENTION_RUNTIME",
		2: "RETENTION_SOURCE",
	}
	FieldOptions_OptionRetention_value = map[string]int32{
		"RETENTION_UNKNOWN": 0,
		"RETENTION_RUNTIME": 1,
		"RETENTION_SOURCE":  2,
	}
)

func (x FieldOptions_OptionRetention) Enum() *FieldOptions_OptionRetention {
	p := new(FieldOptions_OptionRetention)
	*p = x
	return p
}

func (x FieldOptions_OptionRetention) String() string {
	name, valid := FieldOptions_OptionRetention_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// This indicates the types of entities that the field may apply to when used
// as an option. If it is unset, then the field may be freely used as an
// option on any kind of entity. Note: as of January 2023, support for this is
// in progress and does not yet have an effect (b/264593489).
type FieldOptions_OptionTargetType int32

const (
	FieldOptions_TARGET_TYPE_UNKNOWN         FieldOptions_OptionTargetType = 0
	FieldOptions_TARGET_TYPE_FILE            FieldOptions_OptionTargetType = 1
	FieldOptions_TARGET_TYPE_EXTENSION_RANGE FieldOptions_OptionTargetType = 2
	FieldOptions_TARGET_TYPE_MESSAGE         FieldOptions_OptionTargetType = 3
	FieldOptions_TARGET_TYPE_FIELD           FieldOptions_OptionTargetType = 4
	FieldOptions_TARGET_TYPE_ONEOF           FieldOptions_OptionTargetType = 5
	FieldOptions_TARGET_TYPE_ENUM            FieldOptions_OptionTargetType = 6
	FieldOptions_TARGET_TYPE_ENUM_ENTRY      FieldOptions_OptionTargetType = 7
	FieldOptions_TARGET_TYPE_SERVICE         FieldOptions_OptionTargetType = 8
	FieldOptions_TARGET_TYPE_METHOD          FieldOptions_OptionTargetType = 9
)

// Enum value maps for FieldOptions_OptionTargetType.
var (
	FieldOptions_OptionTargetType_name = map[int32]string{
		0: "TARGET_TYPE_UNKNOWN",
		1: "TARGET_TYPE_FILE",
		2: "TARGET_TYPE_EXTENSION_RANGE",
		3: "TARGET_TYPE_MESSAGE",
		4: "TARGET_TYPE_FIELD",
		5: "TARGET_TYPE_ONEOF",
		6: "TARGET_TYPE_ENUM",
		7: "TARGET_TYPE_ENUM_ENTRY",
		8: "TARGET_TYPE_SERVICE",
		9: "TARGET_TYPE_METHOD",
	}
	FieldOptions_OptionTargetType_value = map[string]int32{
		"TARGET_TYPE_UNKNOWN":         0,
		"TARGET_TYPE_FILE":            1,
		"TARGET_TYPE_EXTENSION_RANGE": 2,
		"TARGET_TYPE_MESSAGE":         3,
		"TARGET_TYPE_FIELD":           4,
		"TARGET_TYPE_ONEOF":           5,
		"TARGET_TYPE_ENUM":            6,
		"TARGET_TYPE_ENUM_ENTRY":      7,
		"TARGET_TYPE_SERVICE":         8,
		"TARGET_TYPE_METHOD":          9,
	}
)

func (x FieldOptions_OptionTargetType) Enum() *FieldOptions_OptionTargetType {
	p := new(FieldOptions_OptionTargetType)
	*p = x
	return p
}

func (x FieldOptions_OptionTargetType) String() string {
	name, valid := FieldOptions_OptionTargetType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
// or neither? HTTP based RPC implementation may choose GET verb for safe
// methods, and PUT verb for idempotent methods instead of the default POST.
type MethodOptions_IdempotencyLevel int32

const (
	MethodOptions_IDEMPOTENCY_UNKNOWN MethodOptions_IdempotencyLevel = 0
	MethodOptions_NO_SIDE_EFFECTS     MethodOptions_IdempotencyLevel = 1 // implies idempotent
	MethodOptions_IDEMPOTENT          MethodOptions_IdempotencyLevel = 2 // idempotent, but may have side effects
)

// Enum value maps for MethodOptions_IdempotencyLevel.
var (
	MethodOptions_IdempotencyLevel_name = map[int32]string{
		0: "IDEMPOTENCY_UNKNOWN",
		1: "NO_SIDE_EFFECTS",
		2: "IDEMPOTENT",
	}
	MethodOptions_IdempotencyLevel_value = map[string]int32{
		"IDEMPOTENCY_UNKNOWN": 0,
		"NO_SIDE_EFFECTS":     1,
		"IDEMPOTENT":          2,
	}
)

func (x MethodOptions_IdempotencyLevel) Enum() *MethodOptions_IdempotencyLevel {
	p := new(MethodOptions_IdempotencyLevel)
	*p = x
	return p
}

func (x MethodOptions_IdempotencyLevel) String() string {
	name, valid := MethodOptions_IdempotencyLevel_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_FieldPresence int32

const (
	FeatureSet_FIELD_PRESENCE_UNKNOWN FeatureSet_FieldPresence = 0
	FeatureSet_EXPLICIT               FeatureSet_FieldPresence = 1
	FeatureSet_IMPLICIT               FeatureSet_FieldPresence = 2
	FeatureSet_LEGACY_REQUIRED        FeatureSet_FieldPresence = 3
)

// Enum value maps for FeatureSet_FieldPresence.
var (
	FeatureSet_FieldPresence_name = map[int32]string{
		0: "FIELD_PRESENCE_UNKNOWN",
		1: "EXPLICIT",
		2: "IMPLICIT",
		3: "LEGACY_REQUIRED",
	}
	FeatureSet_FieldPresence_value = map[string]int32{
		"FIELD_PRESENCE_UNKNOWN": 0,
		"EXPLICIT":               1,
		"IMPLICIT":               2,
		"LEGACY_REQUIRED":        3,
	}
)

func (x FeatureSet_FieldPresence) Enum() *FeatureSet_FieldPresence {
	p := new(FeatureSet_FieldPresence)
	*p = x
	return p
}

func (x FeatureSet_FieldPresence) String() string {
	name, valid := FeatureSet_FieldPresence_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_EnumType int32

const (
	FeatureSet_ENUM_TYPE_UNKNOWN FeatureSet_EnumType = 0
	FeatureSet_OPEN              FeatureSet_EnumType = 1
	FeatureSet_CLOSED            FeatureSet_EnumType = 2
)

// Enum value maps for FeatureSet_EnumType.
var (
	FeatureSet_EnumType_name = map[int32]string{
		0: "ENUM_TYPE_UNKNOWN",
		1: "OPEN",
		2: "CLOSED",
	}
	FeatureSet_EnumType_value = map[string]int32{
		"ENUM_TYPE_UNKNOWN": 0,
		"OPEN":              1,
		"CLOSED":            2,
	}
)

func (x FeatureSet_EnumType) Enum() *FeatureSet_EnumType {
	p := new(FeatureSet_EnumType)
	*p = x
	return p
}

func (x FeatureSet_EnumType) String() string {
	name, valid := FeatureSet_EnumType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_RepeatedFieldEncoding int32

const (
	FeatureSet_REPEATED_FIELD_ENCODING_UNKNOWN FeatureSet_RepeatedFieldEncoding = 0
	FeatureSet_PACKED                          FeatureSet_RepeatedFieldEncoding = 1
	FeatureSet_EXPANDED                        FeatureSet_RepeatedFieldEncoding = 2
)

// Enum value maps for FeatureSet_RepeatedFieldEncoding.
var (
	FeatureSet_RepeatedFieldEncoding_name = map[int32]string{
		0: "REPEATED_FIELD_ENCODING_UNKNOWN",
		1: "PACKED",
		2: "EXPANDED",
	}
	FeatureSet_RepeatedFieldEncoding_value = map[string]int32{
		"REPEATED_FIELD_ENCODING_UNKNOWN": 0,
		"PACKED":                          1,
		"EXPANDED":                        2,
	}
)

func (x FeatureSet_RepeatedFieldEncoding) Enum() *FeatureSet_RepeatedFieldEncoding {
	p := new(FeatureSet_RepeatedFieldEncoding)
	*p = x
	return p
}

func (x FeatureSet_RepeatedFieldEncoding) String() string {
	name, valid := FeatureSet_RepeatedFieldEncoding_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_Utf8Validation int32

const (
	FeatureSet_UTF8_VALIDATION_UNKNOWN FeatureSet_Utf8Validation = 0
	FeatureSet_VERIFY                  FeatureSet_Utf8Validation = 2
	FeatureSet_NONE                    FeatureSet_Utf8Validation = 3
)

// Enum value maps for FeatureSet_Utf8Validation.
var (
	FeatureSet_Utf8Validation_name = map[int32]string{
		0: "UTF8_VALIDATION_UNKNOWN",
		2: "VERIFY",
		3: "NONE",
	}
	FeatureSet_Utf8Validation_value = map[string]int32{
		"UTF8_VALIDATION_UNKNOWN": 0,
		"VERIFY":                  2,
		"NONE":                    3,
	}
)

func (x FeatureSet_Utf8Validation) Enum() *FeatureSet_Utf8Validation {
	p := new(FeatureSet_Utf8Validation)
	*p = x
	return p
}

func (x FeatureSet_Utf8Validation) String() string {
	name, valid := FeatureSet_Utf8Validation_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_MessageEncoding int32

const (
	FeatureSet_MESSAGE_ENCODING_UNKNOWN FeatureSet_MessageEncoding = 0
	FeatureSet_LENGTH_PREFIXED          FeatureSet_MessageEncoding = 1
	FeatureSet_DELIMITED                FeatureSet_MessageEncoding = 2
)

// Enum value maps for FeatureSet_MessageEncoding.
var (
	FeatureSet_MessageEncoding_name = map[int32]string{
		0: "MESSAGE_ENCODING_UNKNOWN",
		1: "LENGTH_PREFIXED",
		2: "DELIMITED",
	}
	FeatureSet_MessageEncoding_value = map[string]int32{
		"MESSAGE_ENCODING_UNKNOWN": 0,
		"LENGTH_PREFIXED":          1,
		"DELIMITED":                2,
	}
)

func (x FeatureSet_MessageEncoding) Enum() *FeatureSet_MessageEncoding {
	p := new(FeatureSet_MessageEncoding)
	*p = x
	return p
}

func (x FeatureSet_MessageEncoding) String() string {
	name, valid := FeatureSet_MessageEncoding_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_JsonFormat int32

const (
	FeatureSet_JSON_FORMAT_UNKNOWN FeatureSet_JsonFormat = 0
	FeatureSet_ALLOW               FeatureSet_JsonFormat = 1
	FeatureSet_LEGACY_BEST_EFFORT  FeatureSet_JsonFormat = 2
)

// Enum value maps for FeatureSet_JsonFormat.
var (
	FeatureSet_JsonFormat_name = map[int32]string{
		0: "JSON_FORMAT_UNKNOWN",
		1: "ALLOW",
		2: "LEGACY_BEST_EFFORT",
	}
	FeatureSet_JsonFormat_value = map[string]int32{
		"JSON_FORMAT_UNKNOWN": 0,
		"ALLOW":               1,
		"LEGACY_BEST_EFFORT":  2,
	}
)

func (x FeatureSet_JsonFormat) Enum() *FeatureSet_JsonFormat {
	p := new(FeatureSet_JsonFormat)
	*p = x
	return p
}

func (x FeatureSet_JsonFormat) String() string {
	name, valid := FeatureSet_JsonFormat_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Represents the identified object's effect on the element in the original
// .proto file.
type GeneratedCodeInfo_Annotation_Semantic int32

const (
	// There is no effect or the effect is indescribable.
	GeneratedCodeInfo_Annotation_NONE GeneratedCodeInfo_Annotation_Semantic = 0
	// The element is set or otherwise mutated.
	GeneratedCodeInfo_Annotation_SET GeneratedCodeInfo_Annotation_Semantic = 1
	// An alias to the element is returned.
	GeneratedCodeInfo_Annotation_ALIAS GeneratedCodeInfo_Annotation_Semantic = 2
)

// Enum value maps for GeneratedCodeInfo_Annotation_Semantic.
var (
	GeneratedCodeInfo_Annotation_Semantic_name = map[int32]string{
		0: "NONE",
		1: "SET",
		2: "ALIAS",
	}
	GeneratedCodeInfo_Annotation_Semantic_value = map[string]int32{
		"NONE":  0,
		"SET":   1,
		"ALIAS": 2,
	}
)

func (x GeneratedCodeInfo_Annotation_Semantic) Enum() *GeneratedCodeInfo_Annotation_Semantic {
	p := new(GeneratedCodeInfo_Annotation_Semantic)
	*p = x
	return p
}

func (x GeneratedCodeInfo_Annotation_Semantic) String() string {
	name, valid := GeneratedCodeInfo_Annotation_Semantic_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
type FileDescriptorSet struct {
	unknownFields []byte
	File          []*FileDescriptorProto `protobuf:"bytes,1,rep,name=file" json:"file,omitempty"`
}

func (x *FileDescriptorSet) Reset() {
	*x = FileDescriptorSet{}
}

func (*FileDescriptorSet) ProtoMessage() {}

func (x *FileDescriptorSet) GetFile() []*FileDescriptorProto {
	if x != nil {
		return x.File
	}
	return nil
}

// Describes a complete .proto file.
type FileDescriptorProto struct {
	unknownFields []byte
	Name          *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`       // file name, relative to root of source tree
	Package       *string `protobuf:"bytes,2,opt,name=package" json:"package,omitempty"` // e.g. "foo", "foo.bar", etc.
	// Names of files imported by this file.
	Dependency []string `protobuf:"bytes,3,rep,name=dependency" json:"dependency,omitempty"`
	// Indexes of the public imported files in the dependency list above.
	PublicDependency []int32 `protobuf:"varint,10,rep,name=public_dependency,json=publicDependency" json:"publicDependency,omitempty"`
	// Indexes of the weak imported files in the dependency list.
	// For Google-internal migration only. Do not use.
	WeakDependency []int32 `protobuf:"varint,11,rep,name=weak_dependency,json=weakDependency" json:"weakDependency,omitempty"`
	// All top-level definitions in this file.
	MessageType []*DescriptorProto        `protobuf:"bytes,4,rep,name=message_type,json=messageType" json:"messageType,omitempty"`
	EnumType    []*EnumDescriptorProto    `protobuf:"bytes,5,rep,name=enum_type,json=enumType" json:"enumType,omitempty"`
	Service     []*ServiceDescriptorProto `protobuf:"bytes,6,rep,name=service" json:"service,omitempty"`
	Extension   []*FieldDescriptorProto   `protobuf:"bytes,7,rep,name=extension" json:"extension,omitempty"`
	Options     *FileOptions              `protobuf:"bytes,8,opt,name=options" json:"options,omitempty"`
	// This field contains optional information about the original source code.
	// You may safely remove this entire field without harming runtime
	// functionality of the descriptors -- the information is needed only by
	// development tools.
	SourceCodeInfo *SourceCodeInfo `protobuf:"bytes,9,opt,name=source_code_info,json=sourceCodeInfo" json:"sourceCodeInfo,omitempty"`
	// The syntax of the proto file.
	// The supported values are "proto2", "proto3", and "editions".
	//
	// If `edition` is present, this value must be "editions".
	Syntax *string `protobuf:"bytes,12,opt,name=syntax" json:"syntax,omitempty"`
	// The edition of the proto file.
	Edition *Edition `protobuf:"varint,14,opt,name=edition" json:"edition,omitempty"`
}

func (x *FileDescriptorProto) Reset() {
	*x = FileDescriptorProto{}
}

func (*FileDescriptorProto) ProtoMessage() {}

func (x *FileDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *FileDescriptorProto) GetPackage() string {
	if x != nil && x.Package != nil {
		return *x.Package
	}
	return ""
}

func (x *FileDescriptorProto) GetDependency() []string {
	if x != nil {
		return x.Dependency
	}
	return nil
}

func (x *FileDescriptorProto) GetPublicDependency() []int32 {
	if x != nil {
		return x.PublicDependency
	}
	return nil
}

func (x *FileDescriptorProto) GetWeakDependency() []int32 {
	if x != nil {
		return x.WeakDependency
	}
	return nil
}

func (x *FileDescriptorProto) GetMessageType() []*DescriptorProto {
	if x != nil {
		return x.MessageType
	}
	return nil
}

func (x *FileDescriptorProto) GetEnumType() []*EnumDescriptorProto {
	if x != nil {
		return x.EnumType
	}
	return nil
}

func (x *FileDescriptorProto) GetService() []*ServiceDescriptorProto {
	if x != nil {
		return x.Service
	}
	return nil
}

func (x *FileDescriptorProto) GetExtension() []*FieldDescriptorProto {
	if x != nil {
		return x.Extension
	}
	return nil
}

func (x *FileDescriptorProto) GetOptions() *FileOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *FileDescriptorProto) GetSourceCodeInfo() *SourceCodeInfo {
	if x != nil {
		return x.SourceCodeInfo
	}
	return nil
}

func (x *FileDescriptorProto) GetSyntax() string {
	if x != nil && x.Syntax != nil {
		return *x.Syntax
	}
	return ""
}

func (x *FileDescriptorProto) GetEdition() Edition {
	if x != nil && x.Edition != nil {
		return *x.Edition
	}
	return Edition_EDITION_UNKNOWN
}

// Describes a message type.
type DescriptorProto struct {
	unknownFields  []byte
	Name           *string                           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Field          []*FieldDescriptorProto           `protobuf:"bytes,2,rep,name=field" json:"field,omitempty"`
	Extension      []*FieldDescriptorProto           `protobuf:"bytes,6,rep,name=extension" json:"extension,omitempty"`
	NestedType     []*DescriptorProto                `protobuf:"bytes,3,rep,name=nested_type,json=nestedType" json:"nestedType,omitempty"`
	EnumType       []*EnumDescriptorProto            `protobuf:"bytes,4,rep,name=enum_type,json=enumType" json:"enumType,omitempty"`
	ExtensionRange []*DescriptorProto_ExtensionRange `protobuf:"bytes,5,rep,name=extension_range,json=extensionRange" json:"extensionRange,omitempty"`
	OneofDecl      []*OneofDescriptorProto           `protobuf:"bytes,8,rep,name=oneof_decl,json=oneofDecl" json:"oneofDecl,omitempty"`
	Options        *MessageOptions                   `protobuf:"bytes,7,opt,name=options" json:"options,omitempty"`
	ReservedRange  []*DescriptorProto_ReservedRange  `protobuf:"bytes,9,rep,name=reserved_range,json=reservedRange" json:"reservedRange,omitempty"`
	// Reserved field names, which may not be used by fields in the same message.
	// A given name may only be reserved once.
	ReservedName []string `protobuf:"bytes,10,rep,name=reserved_name,json=reservedName" json:"reservedName,omitempty"`
}

func (x *DescriptorProto) Reset() {
	*x = DescriptorProto{}
}

func (*DescriptorProto) ProtoMessage() {}

func (x *DescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *DescriptorProto) GetField() []*FieldDescriptorProto {
	if x != nil {
		return x.Field
	}
	return nil
}

func (x *DescriptorProto) GetExtension() []*FieldDescriptorProto {
	if x != nil {
		return x.Extension
	}
	return nil
}

func (x *DescriptorProto) GetNestedType() []*DescriptorProto {
	if x != nil {
		return x.NestedType
	}
	return nil
}

func (x *DescriptorProto) GetEnumType() []*EnumDescriptorProto {
	if x != nil {
		return x.EnumType
	}
	return nil
}

func (x *DescriptorProto) GetExtensionRange() []*DescriptorProto_ExtensionRange {
	if x != nil {
		return x.ExtensionRange
	}
	return nil
}

func (x *DescriptorProto) GetOneofDecl() []*OneofDescriptorProto {
	if x != nil {
		return x.OneofDecl
	}
	return nil
}

func (x *DescriptorProto) GetOptions() *MessageOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *DescriptorProto) GetReservedRange() []*DescriptorProto_ReservedRange {
	if x != nil {
		return x.ReservedRange
	}
	return nil
}

func (x *DescriptorProto) GetReservedName() []string {
	if x != nil {
		return x.ReservedName
	}
	return nil
}

type ExtensionRangeOptions struct {
	unknownFields []byte
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
	// For external users: DO NOT USE. We are in the process of open sourcing
	// extension declaration and executing internal cleanups before it can be
	// used externally.
	Declaration []*ExtensionRangeOptions_Declaration `protobuf:"bytes,2,rep,name=declaration" json:"declaration,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,50,opt,name=features" json:"features,omitempty"`
	// The verification state of the range.
	// TODO: flip the default to DECLARATION once all empty ranges
	// are marked as UNVERIFIED.
	Verification *ExtensionRangeOptions_VerificationState `protobuf:"varint,3,opt,name=verification,def=1" json:"verification,omitempty"`
}

// Default values for ExtensionRangeOptions fields.
const (
	Default_ExtensionRangeOptions_Verification = ExtensionRangeOptions_UNVERIFIED
)

func (x *ExtensionRangeOptions) Reset() {
	*x = ExtensionRangeOptions{}
}

func (*ExtensionRangeOptions) ProtoMessage() {}

func (x *ExtensionRangeOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

func (x *ExtensionRangeOptions) GetDeclaration() []*ExtensionRangeOptions_Declaration {
	if x != nil {
		return x.Declaration
	}
	return nil
}

func (x *ExtensionRangeOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *ExtensionRangeOptions) GetVerification() ExtensionRangeOptions_VerificationState {
	if x != nil && x.Verification != nil {
		return *x.Verification
	}
	return Default_ExtensionRangeOptions_Verification
}

// Describes a field within a message.
type FieldDescriptorProto struct {
	unknownFields []byte
	Name          *string                     `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Number        *int32                      `protobuf:"varint,3,opt,name=number" json:"number,omitempty"`
	Label         *FieldDescriptorProto_Label `protobuf:"varint,4,opt,name=label" json:"label,omitempty"`
	// If type_name is set, this need not be set.  If both this and type_name
	// are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
	Type *FieldDescriptorProto_Type `protobuf:"varint,5,opt,name=type" json:"type,omitempty"`
	// For message and enum types, this is the name of the type.  If the name
	// starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
	// rules are used to find the type (i.e. first the nested types within this
	// message are searched, then within the parent, on up to the root
	// namespace).
	TypeName *string `protobuf:"bytes,6,opt,name=type_name,json=typeName" json:"typeName,omitempty"`
	// For extensions, this is the name of the type being extended.  It is
	// resolved in the same manner as type_name.
	Extendee *string `protobuf:"bytes,2,opt,name=extendee" json:"extendee,omitempty"`
	// For numeric types, contains the original text representation of the value.
	// For booleans, "true" or "false".
	// For strings, contains the default text contents (not escaped in any way).
	// For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
	DefaultValue *string `protobuf:"bytes,7,opt,name=default_value,json=defaultValue" json:"defaultValue,omitempty"`
	// If set, gives the index of a oneof in the containing type's oneof_decl
	// list.  This field is a member of that oneof.
	OneofIndex *int32 `protobuf:"varint,9,opt,name=oneof_index,json=oneofIndex" json:"oneofIndex,omitempty"`
	// JSON name of this field. The value is set by protocol compiler. If the
	// user has set a "json_name" option on this field, that option's value
	// will be used. Otherwise, it's deduced from the field's name by converting
	// it to camelCase.
	JsonName *string       `protobuf:"bytes,10,opt,name=json_name,json=jsonName" json:"jsonName,omitempty"`
	Options  *FieldOptions `protobuf:"bytes,8,opt,name=options" json:"options,omitempty"`
	// If true, this is a proto3 "optional". When a proto3 field is optional, it
	// tracks presence regardless of field type.
	//
	// When proto3_optional is true, this field must belong to a oneof to signal
	// to old proto3 clients that presence is tracked for this field. This oneof
	// is known as a "synthetic" oneof, and this field must be its sole member
	// (each proto3 optional field gets its own synthetic oneof). Synthetic oneofs
	// exist in the descriptor only, and do not generate any API. Synthetic oneofs
	// must be ordered after all "real" oneofs.
	//
	// For message fields, proto3_optional doesn't create any semantic change,
	// since non-repeated message fields always track presence. However it still
	// indicates the semantic detail of whether the user wrote "optional" or not.
	// This can be useful for round-tripping the .proto file. For consistency we
	// give message fields a synthetic oneof also, even though it is not required
	// to track presence. This is especially important because the parser can't
	// tell if a field is a message or an enum, so it must always create a
	// synthetic oneof.
	//
	// Proto2 optional fields do not set this flag, because they already indicate
	// optional with `LABEL_OPTIONAL`.
	Proto3Optional *bool `protobuf:"varint,17,opt,name=proto3_optional,json=proto3Optional" json:"proto3Optional,omitempty"`
}

func (x *FieldDescriptorProto) Reset() {
	*x = FieldDescriptorProto{}
}

func (*FieldDescriptorProto) ProtoMessage() {}

func (x *FieldDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *FieldDescriptorProto) GetNumber() int32 {
	if x != nil && x.Number != nil {
		return *x.Number
	}
	return 0
}

func (x *FieldDescriptorProto) GetLabel() FieldDescriptorProto_Label {
	if x != nil && x.Label != nil {
		return *x.Label
	}
	return FieldDescriptorProto_LABEL_OPTIONAL
}

func (x *FieldDescriptorProto) GetType() FieldDescriptorProto_Type {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return FieldDescriptorProto_TYPE_DOUBLE
}

func (x *FieldDescriptorProto) GetTypeName() string {
	if x != nil && x.TypeName != nil {
		return *x.TypeName
	}
	return ""
}

func (x *FieldDescriptorProto) GetExtendee() string {
	if x != nil && x.Extendee != nil {
		return *x.Extendee
	}
	return ""
}

func (x *FieldDescriptorProto) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *FieldDescriptorProto) GetOneofIndex() int32 {
	if x != nil && x.OneofIndex != nil {
		return *x.OneofIndex
	}
	return 0
}

func (x *FieldDescriptorProto) GetJsonName() string {
	if x != nil && x.JsonName != nil {
		return *x.JsonName
	}
	return ""
}

func (x *FieldDescriptorProto) GetOptions() *FieldOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *FieldDescriptorProto) GetProto3Optional() bool {
	if x != nil && x.Proto3Optional != nil {
		return *x.Proto3Optional
	}
	return false
}

// Describes a oneof.
type OneofDescriptorProto struct {
	unknownFields []byte
	Name          *string       `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Options       *OneofOptions `protobuf:"bytes,2,opt,name=options" json:"options,omitempty"`
}

func (x *OneofDescriptorProto) Reset() {
	*x = OneofDescriptorProto{}
}

func (*OneofDescriptorProto) ProtoMessage() {}

func (x *OneofDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *OneofDescriptorProto) GetOptions() *OneofOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Describes an enum type.
type EnumDescriptorProto struct {
	unknownFields []byte
	Name          *string                     `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value         []*EnumValueDescriptorProto `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
	Options       *EnumOptions                `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
	// Range of reserved numeric values. Reserved numeric values may not be used
	// by enum values in the same enum declaration. Reserved ranges may not
	// overlap.
	ReservedRange []*EnumDescriptorProto_EnumReservedRange `protobuf:"bytes,4,rep,name=reserved_range,json=reservedRange" json:"reservedRange,omitempty"`
	// Reserved enum value names, which may not be reused. A given name may only
	// be reserved once.
	ReservedName []string `protobuf:"bytes,5,rep,name=reserved_name,json=reservedName" json:"reservedName,omitempty"`
}

func (x *EnumDescriptorProto) Reset() {
	*x = EnumDescriptorProto{}
}

func (*EnumDescriptorProto) ProtoMessage() {}

func (x *EnumDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *EnumDescriptorProto) GetValue() []*EnumValueDescriptorProto {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *EnumDescriptorProto) GetOptions() *EnumOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *EnumDescriptorProto) GetReservedRange() []*EnumDescriptorProto_EnumReservedRange {
	if x != nil {
		return x.ReservedRange
	}
	return nil
}

func (x *EnumDescriptorProto) GetReservedName() []string {
	if x != nil {
		return x.ReservedName
	}
	return nil
}

// Describes a value within an enum.
type EnumValueDescriptorProto struct {
	unknownFields []byte
	Name          *string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Number        *int32            `protobuf:"varint,2,opt,name=number" json:"number,omitempty"`
	Options       *EnumValueOptions `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
}

func (x *EnumValueDescriptorProto) Reset() {
	*x = EnumValueDescriptorProto{}
}

func (*EnumValueDescriptorProto) ProtoMessage() {}

func (x *EnumValueDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *EnumValueDescriptorProto) GetNumber() int32 {
	if x != nil && x.Number != nil {
		return *x.Number
	}
	return 0
}

func (x *EnumValueDescriptorProto) GetOptions() *EnumValueOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Describes a service.
type ServiceDescriptorProto struct {
	unknownFields []byte
	Name          *string                  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Method        []*MethodDescriptorProto `protobuf:"bytes,2,rep,name=method" json:"method,omitempty"`
	Options       *ServiceOptions          `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
}

func (x *ServiceDescriptorProto) Reset() {
	*x = ServiceDescriptorProto{}
}

func (*ServiceDescriptorProto) ProtoMessage() {}

func (x *ServiceDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ServiceDescriptorProto) GetMethod() []*MethodDescriptorProto {
	if x != nil {
		return x.Method
	}
	return nil
}

func (x *ServiceDescriptorProto) GetOptions() *ServiceOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Describes a method of a service.
type MethodDescriptorProto struct {
	unknownFields []byte
	Name          *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Input and output type names.  These are resolved in the same way as
	// FieldDescriptorProto.type_name, but must refer to a message type.
	InputType  *string        `protobuf:"bytes,2,opt,name=input_type,json=inputType" json:"inputType,omitempty"`
	OutputType *string        `protobuf:"bytes,3,opt,name=output_type,json=outputType" json:"outputType,omitempty"`
	Options    *MethodOptions `protobuf:"bytes,4,opt,name=options" json:"options,omitempty"`
	// Identifies if client streams multiple client messages
	ClientStreaming *bool `protobuf:"varint,5,opt,name=client_streaming,json=clientStreaming,def=0" json:"clientStreaming,omitempty"`
	// Identifies if server streams multiple server messages
	ServerStreaming *bool `protobuf:"varint,6,opt,name=server_streaming,json=serverStreaming,def=0" json:"serverStreaming,omitempty"`
}

// Default values for MethodDescriptorProto fields.
const (
	Default_MethodDescriptorProto_ClientStreaming = bool(false)
	Default_MethodDescriptorProto_ServerStreaming = bool(false)
)

func (x *MethodDescriptorProto) Reset() {
	*x = MethodDescriptorProto{}
}

func (*MethodDescriptorProto) ProtoMessage() {}

func (x *MethodDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *MethodDescriptorProto) GetInputType() string {
	if x != nil && x.InputType != nil {
		return *x.InputType
	}
	return ""
}

func (x *MethodDescriptorProto) GetOutputType() string {
	if x != nil && x.OutputType != nil {
		return *x.OutputType
	}
	return ""
}

func (x *MethodDescriptorProto) GetOptions() *MethodOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *MethodDescriptorProto) GetClientStreaming() bool {
	if x != nil && x.ClientStreaming != nil {
		return *x.ClientStreaming
	}
	return Default_MethodDescriptorProto_ClientStreaming
}

func (x *MethodDescriptorProto) GetServerStreaming() bool {
	if x != nil && x.ServerStreaming != nil {
		return *x.ServerStreaming
	}
	return Default_MethodDescriptorProto_ServerStreaming
}

type FileOptions struct {
	unknownFields []byte
	// Sets the Java package where classes generated from this .proto will be
	// placed.  By default, the proto package is used, but this is often
	// inappropriate because proto packages do not normally start with backwards
	// domain names.
	JavaPackage *string `protobuf:"bytes,1,opt,name=java_package,json=javaPackage" json:"javaPackage,omitempty"`
	// Controls the name of the wrapper Java class generated for the .proto file.
	// That class will always contain the .proto file's getDescriptor() method as
	// well as any top-level extensions defined in the .proto file.
	// If java_multiple_files is disabled, then all the other classes from the
	// .proto file will be nested inside the single wrapper outer class.
	JavaOuterClassname *string `protobuf:"bytes,8,opt,name=java_outer_classname,json=javaOuterClassname" json:"javaOuterClassname,omitempty"`
	// If enabled, then the Java code generator will generate a separate .java
	// file for each top-level message, enum, and service defined in the .proto
	// file.  Thus, these types will *not* be nested inside the wrapper class
	// named by java_outer_classname.  However, the wrapper class will still be
	// generated to contain the file's getDescriptor() method as well as any
	// top-level extensions defined in the file.
	JavaMultipleFiles *bool `protobuf:"varint,10,opt,name=java_multiple_files,json=javaMultipleFiles,def=0" json:"javaMultipleFiles,omitempty"`
	// This option does nothing.
	//
	// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
	JavaGenerateEqualsAndHash *bool `protobuf:"varint,20,opt,name=java_generate_equals_and_hash,json=javaGenerateEqualsAndHash" json:"javaGenerateEqualsAndHash,omitempty"`
	// If set true, then the Java2 code generator will generate code that
	// throws an exception whenever an attempt is made to assign a non-UTF-8
	// byte sequence to a string field.
	// Message reflection will do the same.
	// However, an extension field still accepts non-UTF-8 byte sequences.
	// This option has no effect on when used with the lite runtime.
	JavaStringCheckUtf8 *bool                     `protobuf:"varint,27,opt,name=java_string_check_utf8,json=javaStringCheckUtf8,def=0" json:"javaStringCheckUtf8,omitempty"`
	OptimizeFor         *FileOptions_OptimizeMode `protobuf:"varint,9,opt,name=optimize_for,json=optimizeFor,def=1" json:"optimizeFor,omitempty"`
	// Sets the Go package where structs generated from this .proto will be
	// placed. If omitted, the Go package will be derived from the following:
	//   - The basename of the package import path, if provided.
	//   - Otherwise, the package statement in the .proto file, if present.
	//   - Otherwise, the basename of the .proto file, without extension.
	GoPackage *string `protobuf:"bytes,11,opt,name=go_package,json=goPackage" json:"goPackage,omitempty"`
	// Should generic services be generated in each language?  "Generic" services
	// are not specific to any particular RPC system.  They are generated by the
	// main code generators in each language (without additional plugins).
	// Generic services were the only kind of service generation supported by
	// early versions of google.protobuf.
	//
	// Generic services are now considered deprecated in favor of using plugins
	// that generate code specific to your particular RPC system.  Therefore,
	// these default to false.  Old code which depends on generic services should
	// explicitly set them to true.
	CcGenericServices   *bool `protobuf:"varint,16,opt,name=cc_generic_services,json=ccGenericServices,def=0" json:"ccGenericServices,omitempty"`
	JavaGenericServices *bool `protobuf:"varint,17,opt,name=java_generic_services,json=javaGenericServices,def=0" json:"javaGenericServices,omitempty"`
	PyGenericServices   *bool `protobuf:"varint,18,opt,name=py_generic_services,json=pyGenericServices,def=0" json:"pyGenericServices,omitempty"`
	// Is this file deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for everything in the file, or it will be completely ignored; in the very
	// least, this is a formalization for deprecating files.
	Deprecated *bool `protobuf:"varint,23,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// Enables the use of arenas for the proto messages in this file. This applies
	// only to generated classes for C++.
	CcEnableArenas *bool `protobuf:"varint,31,opt,name=cc_enable_arenas,json=ccEnableArenas,def=1" json:"ccEnableArenas,omitempty"`
	// Sets the objective c class prefix which is prepended to all objective c
	// generated classes from this .proto. There is no default.
	ObjcClassPrefix *string `protobuf:"bytes,36,opt,name=objc_class_prefix,json=objcClassPrefix" json:"objcClassPrefix,omitempty"`
	// Namespace for generated classes; defaults to the package.
	CsharpNamespace *string `protobuf:"bytes,37,opt,name=csharp_namespace,json=csharpNamespace" json:"csharpNamespace,omitempty"`
	// By default Swift generators will take the proto package and CamelCase it
	// replacing '.' with underscore and use that to prefix the types/symbols
	// defined. When this options is provided, they will use this value instead
	// to prefix the types/symbols defined.
	SwiftPrefix *string `protobuf:"bytes,39,opt,name=swift_prefix,json=swiftPrefix" json:"swiftPrefix,omitempty"`
	// Sets the php class prefix which is prepended to all php generated classes
	// from this .proto. Default is empty.
	PhpClassPrefix *string `protobuf:"bytes,40,opt,name=php_class_prefix,json=phpClassPrefix" json:"phpClassPrefix,omitempty"`
	// Use this option to change the namespace of php generated classes. Default
	// is empty. When this option is empty, the package name will be used for
	// determining the namespace.
	PhpNamespace *string `protobuf:"bytes,41,opt,name=php_namespace,json=phpNamespace" json:"phpNamespace,omitempty"`
	// Use this option to change the namespace of php generated metadata classes.
	// Default is empty. When this option is empty, the proto file name will be
	// used for determining the namespace.
	PhpMetadataNamespace *string `protobuf:"bytes,44,opt,name=php_metadata_namespace,json=phpMetadataNamespace" json:"phpMetadataNamespace,omitempty"`
	// Use this option to change the package of ruby generated classes. Default
	// is empty. When this option is not set, the package name will be used for
	// determining the ruby package.
	RubyPackage *string `protobuf:"bytes,45,opt,name=ruby_package,json=rubyPackage" json:"rubyPackage,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,50,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here.
	// See the documentation for the "Options" section above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
}

// Default values for FileOptions fields.
const (
	Default_FileOptions_JavaMultipleFiles   = bool(false)
	Default_FileOptions_JavaStringCheckUtf8 = bool(false)
	Default_FileOptions_OptimizeFor         = FileOptions_SPEED
	Default_FileOptions_CcGenericServices   = bool(false)
	Default_FileOptions_JavaGenericServices = bool(false)
	Default_FileOptions_PyGenericServices   = bool(false)
	Default_FileOptions_Deprecated          = bool(false)
	Default_FileOptions_CcEnableArenas      = bool(true)
)

func (x *FileOptions) Reset() {
	*x = FileOptions{}
}

func (*FileOptions) ProtoMessage() {}

func (x *FileOptions) GetJavaPackage() string {
	if x != nil && x.JavaPackage != nil {
		return *x.JavaPackage
	}
	return ""
}

func (x *FileOptions) GetJavaOuterClassname() string {
	if x != nil && x.JavaOuterClassname != nil {
		return *x.JavaOuterClassname
	}
	return ""
}

func (x *FileOptions) GetJavaMultipleFiles() bool {
	if x != nil && x.JavaMultipleFiles != nil {
		return *x.JavaMultipleFiles
	}
	return Default_FileOptions_JavaMultipleFiles
}

// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
func (x *FileOptions) GetJavaGenerateEqualsAndHash() bool {
	if x != nil && x.JavaGenerateEqualsAndHash != nil {
		return *x.JavaGenerateEqualsAndHash
	}
	return false
}

func (x *FileOptions) GetJavaStringCheckUtf8() bool {
	if x != nil && x.JavaStringCheckUtf8 != nil {
		return *x.JavaStringCheckUtf8
	}
	return Default_FileOptions_JavaStringCheckUtf8
}

func (x *FileOptions) GetOptimizeFor() FileOptions_OptimizeMode {
	if x != nil && x.OptimizeFor != nil {
		return *x.OptimizeFor
	}
	return Default_FileOptions_OptimizeFor
}

func (x *FileOptions) GetGoPackage() string {
	if x != nil && x.GoPackage != nil {
		return *x.GoPackage
	}
	return ""
}

func (x *FileOptions) GetCcGenericServices() bool {
	if x != nil && x.CcGenericServices != nil {
		return *x.CcGenericServices
	}
	return Default_FileOptions_CcGenericServices
}

func (x *FileOptions) GetJavaGenericServices() bool {
	if x != nil && x.JavaGenericServices != nil {
		return *x.JavaGenericServices
	}
	return Default_FileOptions_JavaGenericServices
}

func (x *FileOptions) GetPyGenericServices() bool {
	if x != nil && x.PyGenericServices != nil {
		return *x.PyGenericServices
	}
	return Default_FileOptions_PyGenericServices
}

func (x *FileOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_FileOptions_Deprecated
}

func (x *FileOptions) GetCcEnableArenas() bool {
	if x != nil && x.CcEnableArenas != nil {
		return *x.CcEnableArenas
	}
	return Default_FileOptions_CcEnableArenas
}

func (x *FileOptions) GetObjcClassPrefix() string {
	if x != nil && x.ObjcClassPrefix != nil {
		return *x.ObjcClassPrefix
	}
	return ""
}

func (x *FileOptions) GetCsharpNamespace() string {
	if x != nil && x.CsharpNamespace != nil {
		return *x.CsharpNamespace
	}
	return ""
}

func (x *FileOptions) GetSwiftPrefix() string {
	if x != nil && x.SwiftPrefix != nil {
		return *x.SwiftPrefix
	}
	return ""
}

func (x *FileOptions) GetPhpClassPrefix() string {
	if x != nil && x.PhpClassPrefix != nil {
		return *x.PhpClassPrefix
	}
	return ""
}

func (x *FileOptions) GetPhpNamespace() string {
	if x != nil && x.PhpNamespace != nil {
		return *x.PhpNamespace
	}
	return ""
}

func (x *FileOptions) GetPhpMetadataNamespace() string {
	if x != nil && x.PhpMetadataNamespace != nil {
		return *x.PhpMetadataNamespace
	}
	return ""
}

func (x *FileOptions) GetRubyPackage() string {
	if x != nil && x.RubyPackage != nil {
		return *x.RubyPackage
	}
	return ""
}

func (x *FileOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *FileOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type MessageOptions struct {
	unknownFields []byte
	// Set true to use the old proto1 MessageSet wire format for extensions.
	// This is provided for backwards-compatibility with the MessageSet wire
	// format.  You should not use this for any other reason:  It's less
	// efficient, has fewer features, and is more complicated.
	//
	// The message must be defined exactly as follows:
	//
	//	message Foo {
	//	  option message_set_wire_format = true;
	//	  extensions 4 to max;
	//	}
	//
	// Note that the message cannot have any defined fields; MessageSets only
	// have extensions.
	//
	// All extensions of your type must be singular messages; e.g. they cannot
	// be int32s, enums, or repeated messages.
	//
	// Because this is an option, the above two restrictions are not enforced by
	// the protocol compiler.
	MessageSetWireFormat *bool `protobuf:"varint,1,opt,name=message_set_wire_format,json=messageSetWireFormat,def=0" json:"messageSetWireFormat,omitempty"`
	// Disables the generation of the standard "descriptor()" accessor, which can
	// conflict with a field of the same name.  This is meant to make migration
	// from proto1 easier; new code should avoid fields named "descriptor".
	NoStandardDescriptorAccessor *bool `protobuf:"varint,2,opt,name=no_standard_descriptor_accessor,json=noStandardDescriptorAccessor,def=0" json:"noStandardDescriptorAccessor,omitempty"`
	// Is this message deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the message, or it will be completely ignored; in the very least,
	// this is a formalization for deprecating messages.
	Deprecated *bool `protobuf:"varint,3,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// Whether the message is an automatically generated map entry type for the
	// maps field.
	//
	// For maps fields:
	//
	//	map<KeyType, ValueType> map_field = 1;
	//
	// The parsed descriptor looks like:
	//
	//	message MapFieldEntry {
	//	    option map_entry = true;
	//	    optional KeyType key = 1;
	//	    optional ValueType value = 2;
	//	}
	//	repeated MapFieldEntry map_field = 1;
	//
	// Implementations may choose not to generate the map_entry=true message, but
	// use a native map in the target language to hold the keys and values.
	// The reflection APIs in such implementations still need to work as
	// if the field is a repeated message field.
	//
	// NOTE: Do not set the option in .proto files. Always use the maps syntax
	// instead. The option should only be implicitly set by the proto compiler
	// parser.
	MapEntry *bool `protobuf:"varint,7,opt,name=map_entry,json=mapEntry" json:"mapEntry,omitempty"`
	// Enable the legacy handling of JSON field name conflicts.  This lowercases
	// and strips underscored from the fields before comparison in proto3 only.
	// The new behavior takes `json_name` into account and applies to proto2 as
	// well.
	//
	// This should only be used as a temporary measure against broken builds due
	// to the change in behavior for JSON field name conflicts.
	//
	// TODO This is legacy behavior we plan to remove once downstream
	// teams have had time to migrate.
	//
	// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
	DeprecatedLegacyJsonFieldConflicts *bool `protobuf:"varint,11,opt,name=deprecated_legacy_json_field_conflicts,json=deprecatedLegacyJsonFieldConflicts" json:"deprecatedLegacyJsonFieldConflicts,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,12,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
}

// Default values for MessageOptions fields.
const (
	Default_MessageOptions_MessageSetWireFormat         = bool(false)
	Default_MessageOptions_NoStandardDescriptorAccessor = bool(false)
	Default_MessageOptions_Deprecated                   = bool(false)
)

func (x *MessageOptions) Reset() {
	*x = MessageOptions{}
}

func (*MessageOptions) ProtoMessage() {}

func (x *MessageOptions) GetMessageSetWireFormat() bool {
	if x != nil && x.MessageSetWireFormat != nil {
		return *x.MessageSetWireFormat
	}
	return Default_MessageOptions_MessageSetWireFormat
}

func (x *MessageOptions) GetNoStandardDescriptorAccessor() bool {
	if x != nil && x.NoStandardDescriptorAccessor != nil {
		return *x.NoStandardDescriptorAccessor
	}
	return Default_MessageOptions_NoStandardDescriptorAccessor
}

func (x *MessageOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_MessageOptions_Deprecated
}

func (x *MessageOptions) GetMapEntry() bool {
	if x != nil && x.MapEntry != nil {
		return *x.MapEntry
	}
	return false
}

// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
func (x *MessageOptions) GetDeprecatedLegacyJsonFieldConflicts() bool {
	if x != nil && x.DeprecatedLegacyJsonFieldConflicts != nil {
		return *x.DeprecatedLegacyJsonFieldConflicts
	}
	return false
}

func (x *MessageOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *MessageOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type FieldOptions struct {
	unknownFields []byte
	// The ctype option instructs the C++ code generator to use a different
	// representation of the field than it normally would.  See the specific
	// options below.  This option is only implemented to support use of
	// [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
	// type "bytes" in the open source release -- sorry, we'll try to include
	// other types in a future version!
	Ctype *FieldOptions_CType `protobuf:"varint,1,opt,name=ctype,def=0" json:"ctype,omitempty"`
	// The packed option can be enabled for repeated primitive fields to enable
	// a more efficient representation on the wire. Rather than repeatedly
	// writing the tag and type for each element, the entire array is encoded as
	// a single length-delimited blob. In proto3, only explicit setting it to
	// false will avoid using packed encoding.  This option is prohibited in
	// Editions, but the `repeated_field_encoding` feature can be used to control
	// the behavior.
	Packed *bool `protobuf:"varint,2,opt,name=packed" json:"packed,omitempty"`
	// The jstype option determines the JavaScript type used for values of the
	// field.  The option is permitted only for 64 bit integral and fixed types
	// (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
	// is represented as JavaScript string, which avoids loss of precision that
	// can happen when a large value is converted to a floating point JavaScript.
	// Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
	// use the JavaScript "number" type.  The behavior of the default option
	// JS_NORMAL is implementation dependent.
	//
	// This option is an enum to permit additional types to be added, e.g.
	// goog.math.Integer.
	Jstype *FieldOptions_JSType `protobuf:"varint,6,opt,name=jstype,def=0" json:"jstype,omitempty"`
	// Should this field be parsed lazily?  Lazy applies only to message-type
	// fields.  It means that when the outer message is initially parsed, the
	// inner message's contents will not be parsed but instead stored in encoded
	// form.  The inner message will actually be parsed when it is first accessed.
	//
	// This is only a hint.  Implementations are free to choose whether to use
	// eager or lazy parsing regardless of the value of this option.  However,
	// setting this option true suggests that the protocol author believes that
	// using lazy parsing on this field is worth the additional bookkeeping
	// overhead typically needed to implement it.
	//
	// This option does not affect the public interface of any generated code;
	// all method signatures remain the same.  Furthermore, thread-safety of the
	// interface is not affected by this option; const methods remain safe to
	// call from multiple threads concurrently, while non-const methods continue
	// to require exclusive access.
	//
	// Note that lazy message fields are still eagerly verified to check
	// ill-formed wireformat or missing required fields. Calling IsInitialized()
	// on the outer message would fail if the inner message has missing required
	// fields. Failed verification would result in parsing failure (except when
	// uninitialized messages are acceptable).
	Lazy *bool `protobuf:"varint,5,opt,name=lazy,def=0" json:"lazy,omitempty"`
	// unverified_lazy does no correctness checks on the byte stream. This should
	// only be used where lazy with verification is prohibitive for performance
	// reasons.
	UnverifiedLazy *bool `protobuf:"varint,15,opt,name=unverified_lazy,json=unverifiedLazy,def=0" json:"unverifiedLazy,omitempty"`
	// Is this field deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for accessors, or it will be completely ignored; in the very least, this
	// is a formalization for deprecating fields.
	Deprecated *bool `protobuf:"varint,3,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// For Google-internal migration only. Do not use.
	Weak *bool `protobuf:"varint,10,opt,name=weak,def=0" json:"weak,omitempty"`
	// Indicate that the field value should not be printed out when using debug
	// formats, e.g. when the field contains sensitive credentials.
	DebugRedact     *bool                           `protobuf:"varint,16,opt,name=debug_redact,json=debugRedact,def=0" json:"debugRedact,omitempty"`
	Retention       *FieldOptions_OptionRetention   `protobuf:"varint,17,opt,name=retention" json:"retention,omitempty"`
	Targets         []FieldOptions_OptionTargetType `protobuf:"varint,19,rep,name=targets" json:"targets,omitempty"`
	EditionDefaults []*FieldOptions_EditionDefault  `protobuf:"bytes,20,rep,name=edition_defaults,json=editionDefaults" json:"editionDefaults,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,21,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
}

// Default values for FieldOptions fields.
const (
	Default_FieldOptions_Ctype          = FieldOptions_STRING
	Default_FieldOptions_Jstype         = FieldOptions_JS_NORMAL
	Default_FieldOptions_Lazy           = bool(false)
	Default_FieldOptions_UnverifiedLazy = bool(false)
	Default_FieldOptions_Deprecated     = bool(false)
	Default_FieldOptions_Weak           = bool(false)
	Default_FieldOptions_DebugRedact    = bool(false)
)

func (x *FieldOptions) Reset() {
	*x = FieldOptions{}
}

func (*FieldOptions) ProtoMessage() {}

func (x *FieldOptions) GetCtype() FieldOptions_CType {
	if x != nil && x.Ctype != nil {
		return *x.Ctype
	}
	return Default_FieldOptions_Ctype
}

func (x *FieldOptions) GetPacked() bool {
	if x != nil && x.Packed != nil {
		return *x.Packed
	}
	return false
}

func (x *FieldOptions) GetJstype() FieldOptions_JSType {
	if x != nil && x.Jstype != nil {
		return *x.Jstype
	}
	return Default_FieldOptions_Jstype
}

func (x *FieldOptions) GetLazy() bool {
	if x != nil && x.Lazy != nil {
		return *x.Lazy
	}
	return Default_FieldOptions_Lazy
}

func (x *FieldOptions) GetUnverifiedLazy() bool {
	if x != nil && x.UnverifiedLazy != nil {
		return *x.UnverifiedLazy
	}
	return Default_FieldOptions_UnverifiedLazy
}

func (x *FieldOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_FieldOptions_Deprecated
}

func (x *FieldOptions) GetWeak() bool {
	if x != nil && x.Weak != nil {
		return *x.Weak
	}
	return Default_FieldOptions_Weak
}

func (x *FieldOptions) GetDebugRedact() bool {
	if x != nil && x.DebugRedact != nil {
		return *x.DebugRedact
	}
	return Default_FieldOptions_DebugRedact
}

func (x *FieldOptions) GetRetention() FieldOptions_OptionRetention {
	if x != nil && x.Retention != nil {
		return *x.Retention
	}
	return FieldOptions_RETENTION_UNKNOWN
}

func (x *FieldOptions) GetTargets() []FieldOptions_OptionTargetType {
	if x != nil {
		return x.Targets
	}
	return nil
}

func (x *FieldOptions) GetEditionDefaults() []*FieldOptions_EditionDefault {
	if x != nil {
		return x.EditionDefaults
	}
	return nil
}

func (x *FieldOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *FieldOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type OneofOptions struct {
	unknownFields []byte
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,1,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
}

func (x *OneofOptions) Reset() {
	*x = OneofOptions{}
}

func (*OneofOptions) ProtoMessage() {}

func (x *OneofOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *OneofOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type EnumOptions struct {
	unknownFields []byte
	// Set this option to true to allow mapping different tag names to the same
	// value.
	AllowAlias *bool `protobuf:"varint,2,opt,name=allow_alias,json=allowAlias" json:"allowAlias,omitempty"`
	// Is this enum deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the enum, or it will be completely ignored; in the very least, this
	// is a formalization for deprecating enums.
	Deprecated *bool `protobuf:"varint,3,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// Enable the legacy handling of JSON field name conflicts.  This lowercases
	// and strips underscored from the fields before comparison in proto3 only.
	// The new behavior takes `json_name` into account and applies to proto2 as
	// well.
	// TODO Remove this legacy behavior once downstream teams have
	// had time to migrate.
	//
	// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
	DeprecatedLegacyJsonFieldConflicts *bool `protobuf:"varint,6,opt,name=deprecated_legacy_json_field_conflicts,json=deprecatedLegacyJsonFieldConflicts" json:"deprecatedLegacyJsonFieldConflicts,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,7,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
}

// Default values for EnumOptions fields.
const (
	Default_EnumOptions_Deprecated = bool(false)
)

func (x *EnumOptions) Reset() {
	*x = EnumOptions{}
}

func (*EnumOptions) ProtoMessage() {}

func (x *EnumOptions) GetAllowAlias() bool {
	if x != nil && x.AllowAlias != nil {
		return *x.AllowAlias
	}
	return false
}

func (x *EnumOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_EnumOptions_Deprecated
}

// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
func (x *EnumOptions) GetDeprecatedLegacyJsonFieldConflicts() bool {
	if x != nil && x.DeprecatedLegacyJsonFieldConflicts != nil {
		return *x.DeprecatedLegacyJsonFieldConflicts
	}
	return false
}

func (x *EnumOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *EnumOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type EnumValueOptions struct {
	unknownFields []byte
	// Is this enum value deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the enum value, or it will be completely ignored; in the very least,
	// this is a formalization for deprecating enum values.
	Deprecated *bool `protobuf:"varint,1,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,2,opt,name=features" json:"features,omitempty"`
	// Indicate that fields annotated with this enum value should not be printed
	// out when using debug formats, e.g. when the field contains sensitive
	// credentials.
	DebugRedact *bool `protobuf:"varint,3,opt,name=debug_redact,json=debugRedact,def=0" json:"debugRedact,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
}

// Default values for EnumValueOptions fields.
const (
	Default_EnumValueOptions_Deprecated  = bool(false)
	Default_EnumValueOptions_DebugRedact = bool(false)
)

func (x *EnumValueOptions) Reset() {
	*x = EnumValueOptions{}
}

func (*EnumValueOptions) ProtoMessage() {}

func (x *EnumValueOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_EnumValueOptions_Deprecated
}

func (x *EnumValueOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *EnumValueOptions) GetDebugRedact() bool {
	if x != nil && x.DebugRedact != nil {
		return *x.DebugRedact
	}
	return Default_EnumValueOptions_DebugRedact
}

func (x *EnumValueOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type ServiceOptions struct {
	unknownFields []byte
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,34,opt,name=features" json:"features,omitempty"`
	// Is this service deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the service, or it will be completely ignored; in the very least,
	// this is a formalization for deprecating services.
	Deprecated *bool `protobuf:"varint,33,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
}

// Default values for ServiceOptions fields.
const (
	Default_ServiceOptions_Deprecated = bool(false)
)

func (x *ServiceOptions) Reset() {
	*x = ServiceOptions{}
}

func (*ServiceOptions) ProtoMessage() {}

func (x *ServiceOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *ServiceOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_ServiceOptions_Deprecated
}

func (x *ServiceOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type MethodOptions struct {
	unknownFields []byte
	// Is this method deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the method, or it will be completely ignored; in the very least,
	// this is a formalization for deprecating methods.
	Deprecated       *bool                           `protobuf:"varint,33,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	IdempotencyLevel *MethodOptions_IdempotencyLevel `protobuf:"varint,34,opt,name=idempotency_level,json=idempotencyLevel,def=0" json:"idempotencyLevel,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,35,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpretedOption,omitempty"`
}

// Default values for MethodOptions fields.
const (
	Default_MethodOptions_Deprecated       = bool(false)
	Default_MethodOptions_IdempotencyLevel = MethodOptions_IDEMPOTENCY_UNKNOWN
)

func (x *MethodOptions) Reset() {
	*x = MethodOptions{}
}

func (*MethodOptions) ProtoMessage() {}

func (x *MethodOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_MethodOptions_Deprecated
}

func (x *MethodOptions) GetIdempotencyLevel() MethodOptions_IdempotencyLevel {
	if x != nil && x.IdempotencyLevel != nil {
		return *x.IdempotencyLevel
	}
	return Default_MethodOptions_IdempotencyLevel
}

func (x *MethodOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *MethodOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
type UninterpretedOption struct {
	unknownFields []byte
	Name          []*UninterpretedOption_NamePart `protobuf:"bytes,2,rep,name=name" json:"name,omitempty"`
	// The value of the uninterpreted option, in whatever type the tokenizer
	// identified it as during parsing. Exactly one of these should be set.
	IdentifierValue  *string  `protobuf:"bytes,3,opt,name=identifier_value,json=identifierValue" json:"identifierValue,omitempty"`
	PositiveIntValue *uint64  `protobuf:"varint,4,opt,name=positive_int_value,json=positiveIntValue" json:"positiveIntValue,omitempty"`
	NegativeIntValue *int64   `protobuf:"varint,5,opt,name=negative_int_value,json=negativeIntValue" json:"negativeIntValue,omitempty"`
	DoubleValue      *float64 `protobuf:"fixed64,6,opt,name=double_value,json=doubleValue" json:"doubleValue,omitempty"`
	StringValue      []byte   `protobuf:"bytes,7,opt,name=string_value,json=stringValue" json:"stringValue,omitempty"`
	AggregateValue   *string  `protobuf:"bytes,8,opt,name=aggregate_value,json=aggregateValue" json:"aggregateValue,omitempty"`
}

func (x *UninterpretedOption) Reset() {
	*x = UninterpretedOption{}
}

func (*UninterpretedOption) ProtoMessage() {}

func (x *UninterpretedOption) GetName() []*UninterpretedOption_NamePart {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *UninterpretedOption) GetIdentifierValue() string {
	if x != nil && x.IdentifierValue != nil {
		return *x.IdentifierValue
	}
	return ""
}

func (x *UninterpretedOption) GetPositiveIntValue() uint64 {
	if x != nil && x.PositiveIntValue != nil {
		return *x.PositiveIntValue
	}
	return 0
}

func (x *UninterpretedOption) GetNegativeIntValue() int64 {
	if x != nil && x.NegativeIntValue != nil {
		return *x.NegativeIntValue
	}
	return 0
}

func (x *UninterpretedOption) GetDoubleValue() float64 {
	if x != nil && x.DoubleValue != nil {
		return *x.DoubleValue
	}
	return 0
}

func (x *UninterpretedOption) GetStringValue() []byte {
	if x != nil {
		return x.StringValue
	}
	return nil
}

func (x *UninterpretedOption) GetAggregateValue() string {
	if x != nil && x.AggregateValue != nil {
		return *x.AggregateValue
	}
	return ""
}

// TODO Enums in C++ gencode (and potentially other languages) are
// not well scoped.  This means that each of the feature enums below can clash
// with each other.  The short names we've chosen maximize call-site
// readability, but leave us very open to this scenario.  A future feature will
// be designed and implemented to handle this, hopefully before we ever hit a
// conflict here.
type FeatureSet struct {
	unknownFields         []byte
	FieldPresence         *FeatureSet_FieldPresence         `protobuf:"varint,1,opt,name=field_presence,json=fieldPresence" json:"fieldPresence,omitempty"`
	EnumType              *FeatureSet_EnumType              `protobuf:"varint,2,opt,name=enum_type,json=enumType" json:"enumType,omitempty"`
	RepeatedFieldEncoding *FeatureSet_RepeatedFieldEncoding `protobuf:"varint,3,opt,name=repeated_field_encoding,json=repeatedFieldEncoding" json:"repeatedFieldEncoding,omitempty"`
	Utf8Validation        *FeatureSet_Utf8Validation        `protobuf:"varint,4,opt,name=utf8_validation,json=utf8Validation" json:"utf8Validation,omitempty"`
	MessageEncoding       *FeatureSet_MessageEncoding       `protobuf:"varint,5,opt,name=message_encoding,json=messageEncoding" json:"messageEncoding,omitempty"`
	JsonFormat            *FeatureSet_JsonFormat            `protobuf:"varint,6,opt,name=json_format,json=jsonFormat" json:"jsonFormat,omitempty"`
}

func (x *FeatureSet) Reset() {
	*x = FeatureSet{}
}

func (*FeatureSet) ProtoMessage() {}

func (x *FeatureSet) GetFieldPresence() FeatureSet_FieldPresence {
	if x != nil && x.FieldPresence != nil {
		return *x.FieldPresence
	}
	return FeatureSet_FIELD_PRESENCE_UNKNOWN
}

func (x *FeatureSet) GetEnumType() FeatureSet_EnumType {
	if x != nil && x.EnumType != nil {
		return *x.EnumType
	}
	return FeatureSet_ENUM_TYPE_UNKNOWN
}

func (x *FeatureSet) GetRepeatedFieldEncoding() FeatureSet_RepeatedFieldEncoding {
	if x != nil && x.RepeatedFieldEncoding != nil {
		return *x.RepeatedFieldEncoding
	}
	return FeatureSet_REPEATED_FIELD_ENCODING_UNKNOWN
}

func (x *FeatureSet) GetUtf8Validation() FeatureSet_Utf8Validation {
	if x != nil && x.Utf8Validation != nil {
		return *x.Utf8Validation
	}
	return FeatureSet_UTF8_VALIDATION_UNKNOWN
}

func (x *FeatureSet) GetMessageEncoding() FeatureSet_MessageEncoding {
	if x != nil && x.MessageEncoding != nil {
		return *x.MessageEncoding
	}
	return FeatureSet_MESSAGE_ENCODING_UNKNOWN
}

func (x *FeatureSet) GetJsonFormat() FeatureSet_JsonFormat {
	if x != nil && x.JsonFormat != nil {
		return *x.JsonFormat
	}
	return FeatureSet_JSON_FORMAT_UNKNOWN
}

// A compiled specification for the defaults of a set of features.  These
// messages are generated from FeatureSet extensions and can be used to seed
// feature resolution. The resolution with this object becomes a simple search
// for the closest matching edition, followed by proto merges.
type FeatureSetDefaults struct {
	unknownFields []byte
	Defaults      []*FeatureSetDefaults_FeatureSetEditionDefault `protobuf:"bytes,1,rep,name=defaults" json:"defaults,omitempty"`
	// The minimum supported edition (inclusive) when this was constructed.
	// Editions before this will not have defaults.
	MinimumEdition *Edition `protobuf:"varint,4,opt,name=minimum_edition,json=minimumEdition" json:"minimumEdition,omitempty"`
	// The maximum known edition (inclusive) when this was constructed. Editions
	// after this will not have reliable defaults.
	MaximumEdition *Edition `protobuf:"varint,5,opt,name=maximum_edition,json=maximumEdition" json:"maximumEdition,omitempty"`
}

func (x *FeatureSetDefaults) Reset() {
	*x = FeatureSetDefaults{}
}

func (*FeatureSetDefaults) ProtoMessage() {}

func (x *FeatureSetDefaults) GetDefaults() []*FeatureSetDefaults_FeatureSetEditionDefault {
	if x != nil {
		return x.Defaults
	}
	return nil
}

func (x *FeatureSetDefaults) GetMinimumEdition() Edition {
	if x != nil && x.MinimumEdition != nil {
		return *x.MinimumEdition
	}
	return Edition_EDITION_UNKNOWN
}

func (x *FeatureSetDefaults) GetMaximumEdition() Edition {
	if x != nil && x.MaximumEdition != nil {
		return *x.MaximumEdition
	}
	return Edition_EDITION_UNKNOWN
}

// Encapsulates information about the original source file from which a
// FileDescriptorProto was generated.
type SourceCodeInfo struct {
	unknownFields []byte
	// A Location identifies a piece of source code in a .proto file which
	// corresponds to a particular definition.  This information is intended
	// to be useful to IDEs, code indexers, documentation generators, and similar
	// tools.
	//
	// For example, say we have a file like:
	//
	//	message Foo {
	//	  optional string foo = 1;
	//	}
	//
	// Let's look at just the field definition:
	//
	//	optional string foo = 1;
	//	^       ^^     ^^  ^  ^^^
	//	a       bc     de  f  ghi
	//
	// We have the following locations:
	//
	//	span   path               represents
	//	[a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
	//	[a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
	//	[c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
	//	[e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
	//	[g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
	//
	// Notes:
	//   - A location may refer to a repeated field itself (i.e. not to any
	//     particular index within it).  This is used whenever a set of elements are
	//     logically enclosed in a single code segment.  For example, an entire
	//     extend block (possibly containing multiple extension definitions) will
	//     have an outer location whose path refers to the "extensions" repeated
	//     field without an index.
	//   - Multiple locations may have the same path.  This happens when a single
	//     logical declaration is spread out across multiple places.  The most
	//     obvious example is the "extend" block again -- there may be multiple
	//     extend blocks in the same scope, each of which will have the same path.
	//   - A location's span is not always a subset of its parent's span.  For
	//     example, the "extendee" of an extension declaration appears at the
	//     beginning of the "extend" block and is shared by all extensions within
	//     the block.
	//   - Just because a location's span is a subset of some other location's span
	//     does not mean that it is a descendant.  For example, a "group" defines
	//     both a type and a field in a single declaration.  Thus, the locations
	//     corresponding to the type and field and their components will overlap.
	//   - Code which tries to interpret locations should probably be designed to
	//     ignore those that it doesn't understand, as more types of locations could
	//     be recorded in the future.
	Location []*SourceCodeInfo_Location `protobuf:"bytes,1,rep,name=location" json:"location,omitempty"`
}

func (x *SourceCodeInfo) Reset() {
	*x = SourceCodeInfo{}
}

func (*SourceCodeInfo) ProtoMessage() {}

func (x *SourceCodeInfo) GetLocation() []*SourceCodeInfo_Location {
	if x != nil {
		return x.Location
	}
	return nil
}

// Describes the relationship between generated code and its original source
// file. A GeneratedCodeInfo message is associated with only one generated
// source file, but may contain references to different source .proto files.
type GeneratedCodeInfo struct {
	unknownFields []byte
	// An Annotation connects some span of text in generated code to an element
	// of its generating .proto file.
	Annotation []*GeneratedCodeInfo_Annotation `protobuf:"bytes,1,rep,name=annotation" json:"annotation,omitempty"`
}

func (x *GeneratedCodeInfo) Reset() {
	*x = GeneratedCodeInfo{}
}

func (*GeneratedCodeInfo) ProtoMessage() {}

func (x *GeneratedCodeInfo) GetAnnotation() []*GeneratedCodeInfo_Annotation {
	if x != nil {
		return x.Annotation
	}
	return nil
}

type DescriptorProto_ExtensionRange struct {
	unknownFields []byte
	Start         *int32                 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"` // Inclusive.
	End           *int32                 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`     // Exclusive.
	Options       *ExtensionRangeOptions `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
}

func (x *DescriptorProto_ExtensionRange) Reset() {
	*x = DescriptorProto_ExtensionRange{}
}

func (*DescriptorProto_ExtensionRange) ProtoMessage() {}

func (x *DescriptorProto_ExtensionRange) GetStart() int32 {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return 0
}

func (x *DescriptorProto_ExtensionRange) GetEnd() int32 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

func (x *DescriptorProto_ExtensionRange) GetOptions() *ExtensionRangeOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Range of reserved tag numbers. Reserved tag numbers may not be used by
// fields or extension ranges in the same message. Reserved ranges may
// not overlap.
type DescriptorProto_ReservedRange struct {
	unknownFields []byte
	Start         *int32 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"` // Inclusive.
	End           *int32 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`     // Exclusive.
}

func (x *DescriptorProto_ReservedRange) Reset() {
	*x = DescriptorProto_ReservedRange{}
}

func (*DescriptorProto_ReservedRange) ProtoMessage() {}

func (x *DescriptorProto_ReservedRange) GetStart() int32 {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return 0
}

func (x *DescriptorProto_ReservedRange) GetEnd() int32 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

type ExtensionRangeOptions_Declaration struct {
	unknownFields []byte
	// The extension number declared within the extension range.
	Number *int32 `protobuf:"varint,1,opt,name=number" json:"number,omitempty"`
	// The fully-qualified name of the extension field. There must be a leading
	// dot in front of the full name.
	FullName *string `protobuf:"bytes,2,opt,name=full_name,json=fullName" json:"fullName,omitempty"`
	// The fully-qualified type name of the extension field. Unlike
	// Metadata.type, Declaration.type must have a leading dot for messages
	// and enums.
	Type *string `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	// If true, indicates that the number is reserved in the extension range,
	// and any extension field with the number will fail to compile. Set this
	// when a declared extension field is deleted.
	Reserved *bool `protobuf:"varint,5,opt,name=reserved" json:"reserved,omitempty"`
	// If true, indicates that the extension must be defined as repeated.
	// Otherwise the extension must be defined as optional.
	Repeated *bool `protobuf:"varint,6,opt,name=repeated" json:"repeated,omitempty"`
}

func (x *ExtensionRangeOptions_Declaration) Reset() {
	*x = ExtensionRangeOptions_Declaration{}
}

func (*ExtensionRangeOptions_Declaration) ProtoMessage() {}

func (x *ExtensionRangeOptions_Declaration) GetNumber() int32 {
	if x != nil && x.Number != nil {
		return *x.Number
	}
	return 0
}

func (x *ExtensionRangeOptions_Declaration) GetFullName() string {
	if x != nil && x.FullName != nil {
		return *x.FullName
	}
	return ""
}

func (x *ExtensionRangeOptions_Declaration) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

func (x *ExtensionRangeOptions_Declaration) GetReserved() bool {
	if x != nil && x.Reserved != nil {
		return *x.Reserved
	}
	return false
}

func (x *ExtensionRangeOptions_Declaration) GetRepeated() bool {
	if x != nil && x.Repeated != nil {
		return *x.Repeated
	}
	return false
}

// Range of reserved numeric values. Reserved values may not be used by
// entries in the same enum. Reserved ranges may not overlap.
//
// Note that this is distinct from DescriptorProto.ReservedRange in that it
// is inclusive such that it can appropriately represent the entire int32
// domain.
type EnumDescriptorProto_EnumReservedRange struct {
	unknownFields []byte
	Start         *int32 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"` // Inclusive.
	End           *int32 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`     // Inclusive.
}

func (x *EnumDescriptorProto_EnumReservedRange) Reset() {
	*x = EnumDescriptorProto_EnumReservedRange{}
}

func (*EnumDescriptorProto_EnumReservedRange) ProtoMessage() {}

func (x *EnumDescriptorProto_EnumReservedRange) GetStart() int32 {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return 0
}

func (x *EnumDescriptorProto_EnumReservedRange) GetEnd() int32 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

type FieldOptions_EditionDefault struct {
	unknownFields []byte
	Edition       *Edition `protobuf:"varint,3,opt,name=edition" json:"edition,omitempty"`
	Value         *string  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"` // Textproto value.
}

func (x *FieldOptions_EditionDefault) Reset() {
	*x = FieldOptions_EditionDefault{}
}

func (*FieldOptions_EditionDefault) ProtoMessage() {}

func (x *FieldOptions_EditionDefault) GetEdition() Edition {
	if x != nil && x.Edition != nil {
		return *x.Edition
	}
	return Edition_EDITION_UNKNOWN
}

func (x *FieldOptions_EditionDefault) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

// The name of the uninterpreted option.  Each string represents a segment in
// a dot-separated name.  is_extension is true iff a segment represents an
// extension (denoted with parentheses in options specs in .proto files).
// E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
// "foo.(bar.baz).moo".
type UninterpretedOption_NamePart struct {
	unknownFields []byte
	NamePart      *string `protobuf:"bytes,1,req,name=name_part,json=namePart" json:"namePart,omitempty"`
	IsExtension   *bool   `protobuf:"varint,2,req,name=is_extension,json=isExtension" json:"isExtension,omitempty"`
}

func (x *UninterpretedOption_NamePart) Reset() {
	*x = UninterpretedOption_NamePart{}
}

func (*UninterpretedOption_NamePart) ProtoMessage() {}

func (x *UninterpretedOption_NamePart) GetNamePart() string {
	if x != nil && x.NamePart != nil {
		return *x.NamePart
	}
	return ""
}

func (x *UninterpretedOption_NamePart) GetIsExtension() bool {
	if x != nil && x.IsExtension != nil {
		return *x.IsExtension
	}
	return false
}

// A map from every known edition with a unique set of defaults to its
// defaults. Not all editions may be contained here.  For a given edition,
// the defaults at the closest matching edition ordered at or before it should
// be used.  This field must be in strict ascending order by edition.
type FeatureSetDefaults_FeatureSetEditionDefault struct {
	unknownFields []byte
	Edition       *Edition    `protobuf:"varint,3,opt,name=edition" json:"edition,omitempty"`
	Features      *FeatureSet `protobuf:"bytes,2,opt,name=features" json:"features,omitempty"`
}

func (x *FeatureSetDefaults_FeatureSetEditionDefault) Reset() {
	*x = FeatureSetDefaults_FeatureSetEditionDefault{}
}

func (*FeatureSetDefaults_FeatureSetEditionDefault) ProtoMessage() {}

func (x *FeatureSetDefaults_FeatureSetEditionDefault) GetEdition() Edition {
	if x != nil && x.Edition != nil {
		return *x.Edition
	}
	return Edition_EDITION_UNKNOWN
}

func (x *FeatureSetDefaults_FeatureSetEditionDefault) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

type SourceCodeInfo_Location struct {
	unknownFields []byte
	// Identifies which part of the FileDescriptorProto was defined at this
	// location.
	//
	// Each element is a field number or an index.  They form a path from
	// the root FileDescriptorProto to the place where the definition appears.
	// For example, this path:
	//
	//	[ 4, 3, 2, 7, 1 ]
	//
	// refers to:
	//
	//	file.message_type(3)  // 4, 3
	//	    .field(7)         // 2, 7
	//	    .name()           // 1
	//
	// This is because FileDescriptorProto.message_type has field number 4:
	//
	//	repeated DescriptorProto message_type = 4;
	//
	// and DescriptorProto.field has field number 2:
	//
	//	repeated FieldDescriptorProto field = 2;
	//
	// and FieldDescriptorProto.name has field number 1:
	//
	//	optional string name = 1;
	//
	// Thus, the above path gives the location of a field name.  If we removed
	// the last element:
	//
	//	[ 4, 3, 2, 7 ]
	//
	// this path refers to the whole field declaration (from the beginning
	// of the label to the terminating semicolon).
	Path []int32 `protobuf:"varint,1,rep,packed,name=path" json:"path,omitempty"`
	// Always has exactly three or four elements: start line, start column,
	// end line (optional, otherwise assumed same as start line), end column.
	// These are packed into a single field for efficiency.  Note that line
	// and column numbers are zero-based -- typically you will want to add
	// 1 to each before displaying to a user.
	Span []int32 `protobuf:"varint,2,rep,packed,name=span" json:"span,omitempty"`
	// If this SourceCodeInfo represents a complete declaration, these are any
	// comments appearing before and after the declaration which appear to be
	// attached to the declaration.
	//
	// A series of line comments appearing on consecutive lines, with no other
	// tokens appearing on those lines, will be treated as a single comment.
	//
	// leading_detached_comments will keep paragraphs of comments that appear
	// before (but not connected to) the current element. Each paragraph,
	// separated by empty lines, will be one comment element in the repeated
	// field.
	//
	// Only the comment content is provided; comment markers (e.g. //) are
	// stripped out.  For block comments, leading whitespace and an asterisk
	// will be stripped from the beginning of each line other than the first.
	// Newlines are included in the output.
	//
	// Examples:
	//
	//	optional int32 foo = 1;  // Comment attached to foo.
	//	// Comment attached to bar.
	//	optional int32 bar = 2;
	//
	//	optional string baz = 3;
	//	// Comment attached to baz.
	//	// Another line attached to baz.
	//
	//	// Comment attached to moo.
	//	//
	//	// Another line attached to moo.
	//	optional double moo = 4;
	//
	//	// Detached comment for corge. This is not leading or trailing comments
	//	// to moo or corge because there are blank lines separating it from
	//	// both.
	//
	//	// Detached comment for corge paragraph 2.
	//
	//	optional string corge = 5;
	//	/* Block comment attached
	//	 * to corge.  Leading asterisks
	//	 * will be removed. */
	//	/* Block comment attached to
	//	 * grault. */
	//	optional int32 grault = 6;
	//
	//	// ignored detached comments.
	LeadingComments         *string  `protobuf:"bytes,3,opt,name=leading_comments,json=leadingComments" json:"leadingComments,omitempty"`
	TrailingComments        *string  `protobuf:"bytes,4,opt,name=trailing_comments,json=trailingComments" json:"trailingComments,omitempty"`
	LeadingDetachedComments []string `protobuf:"bytes,6,rep,name=leading_detached_comments,json=leadingDetachedComments" json:"leadingDetachedComments,omitempty"`
}

func (x *SourceCodeInfo_Location) Reset() {
	*x = SourceCodeInfo_Location{}
}

func (*SourceCodeInfo_Location) ProtoMessage() {}

func (x *SourceCodeInfo_Location) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *SourceCodeInfo_Location) GetSpan() []int32 {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *SourceCodeInfo_Location) GetLeadingComments() string {
	if x != nil && x.LeadingComments != nil {
		return *x.LeadingComments
	}
	return ""
}

func (x *SourceCodeInfo_Location) GetTrailingComments() string {
	if x != nil && x.TrailingComments != nil {
		return *x.TrailingComments
	}
	return ""
}

func (x *SourceCodeInfo_Location) GetLeadingDetachedComments() []string {
	if x != nil {
		return x.LeadingDetachedComments
	}
	return nil
}

type GeneratedCodeInfo_Annotation struct {
	unknownFields []byte
	// Identifies the element in the original source .proto file. This field
	// is formatted the same as SourceCodeInfo.Location.path.
	Path []int32 `protobuf:"varint,1,rep,packed,name=path" json:"path,omitempty"`
	// Identifies the filesystem path to the original source .proto.
	SourceFile *string `protobuf:"bytes,2,opt,name=source_file,json=sourceFile" json:"sourceFile,omitempty"`
	// Identifies the starting offset in bytes in the generated code
	// that relates to the identified object.
	Begin *int32 `protobuf:"varint,3,opt,name=begin" json:"begin,omitempty"`
	// Identifies the ending offset in bytes in the generated code that
	// relates to the identified object. The end offset should be one past
	// the last relevant byte (so the length of the text = end - begin).
	End      *int32                                 `protobuf:"varint,4,opt,name=end" json:"end,omitempty"`
	Semantic *GeneratedCodeInfo_Annotation_Semantic `protobuf:"varint,5,opt,name=semantic" json:"semantic,omitempty"`
}

func (x *GeneratedCodeInfo_Annotation) Reset() {
	*x = GeneratedCodeInfo_Annotation{}
}

func (*GeneratedCodeInfo_Annotation) ProtoMessage() {}

func (x *GeneratedCodeInfo_Annotation) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *GeneratedCodeInfo_Annotation) GetSourceFile() string {
	if x != nil && x.SourceFile != nil {
		return *x.SourceFile
	}
	return ""
}

func (x *GeneratedCodeInfo_Annotation) GetBegin() int32 {
	if x != nil && x.Begin != nil {
		return *x.Begin
	}
	return 0
}

func (x *GeneratedCodeInfo_Annotation) GetEnd() int32 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

func (x *GeneratedCodeInfo_Annotation) GetSemantic() GeneratedCodeInfo_Annotation_Semantic {
	if x != nil && x.Semantic != nil {
		return *x.Semantic
	}
	return GeneratedCodeInfo_Annotation_NONE
}

func (m *FileDescriptorSet) CloneVT() *FileDescriptorSet {
	if m == nil {
		return (*FileDescriptorSet)(nil)
	}
	r := new(FileDescriptorSet)
	if rhs := m.File; rhs != nil {
		tmpContainer := make([]*FileDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.File = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FileDescriptorSet) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *FileDescriptorProto) CloneVT() *FileDescriptorProto {
	if m == nil {
		return (*FileDescriptorProto)(nil)
	}
	r := new(FileDescriptorProto)
	r.Options = m.Options.CloneVT()
	r.SourceCodeInfo = m.SourceCodeInfo.CloneVT()
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Package; rhs != nil {
		tmpVal := *rhs
		r.Package = &tmpVal
	}
	if rhs := m.Dependency; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Dependency = tmpContainer
	}
	if rhs := m.PublicDependency; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.PublicDependency = tmpContainer
	}
	if rhs := m.WeakDependency; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.WeakDependency = tmpContainer
	}
	if rhs := m.MessageType; rhs != nil {
		tmpContainer := make([]*DescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.MessageType = tmpContainer
	}
	if rhs := m.EnumType; rhs != nil {
		tmpContainer := make([]*EnumDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.EnumType = tmpContainer
	}
	if rhs := m.Service; rhs != nil {
		tmpContainer := make([]*ServiceDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Service = tmpContainer
	}
	if rhs := m.Extension; rhs != nil {
		tmpContainer := make([]*FieldDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Extension = tmpContainer
	}
	if rhs := m.Syntax; rhs != nil {
		tmpVal := *rhs
		r.Syntax = &tmpVal
	}
	if rhs := m.Edition; rhs != nil {
		tmpVal := *rhs
		r.Edition = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FileDescriptorProto) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *DescriptorProto_ExtensionRange) CloneVT() *DescriptorProto_ExtensionRange {
	if m == nil {
		return (*DescriptorProto_ExtensionRange)(nil)
	}
	r := new(DescriptorProto_ExtensionRange)
	r.Options = m.Options.CloneVT()
	if rhs := m.Start; rhs != nil {
		tmpVal := *rhs
		r.Start = &tmpVal
	}
	if rhs := m.End; rhs != nil {
		tmpVal := *rhs
		r.End = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *DescriptorProto_ExtensionRange) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *DescriptorProto_ReservedRange) CloneVT() *DescriptorProto_ReservedRange {
	if m == nil {
		return (*DescriptorProto_ReservedRange)(nil)
	}
	r := new(DescriptorProto_ReservedRange)
	if rhs := m.Start; rhs != nil {
		tmpVal := *rhs
		r.Start = &tmpVal
	}
	if rhs := m.End; rhs != nil {
		tmpVal := *rhs
		r.End = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *DescriptorProto_ReservedRange) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *DescriptorProto) CloneVT() *DescriptorProto {
	if m == nil {
		return (*DescriptorProto)(nil)
	}
	r := new(DescriptorProto)
	r.Options = m.Options.CloneVT()
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Field; rhs != nil {
		tmpContainer := make([]*FieldDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Field = tmpContainer
	}
	if rhs := m.Extension; rhs != nil {
		tmpContainer := make([]*FieldDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Extension = tmpContainer
	}
	if rhs := m.NestedType; rhs != nil {
		tmpContainer := make([]*DescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.NestedType = tmpContainer
	}
	if rhs := m.EnumType; rhs != nil {
		tmpContainer := make([]*EnumDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.EnumType = tmpContainer
	}
	if rhs := m.ExtensionRange; rhs != nil {
		tmpContainer := make([]*DescriptorProto_ExtensionRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ExtensionRange = tmpContainer
	}
	if rhs := m.OneofDecl; rhs != nil {
		tmpContainer := make([]*OneofDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.OneofDecl = tmpContainer
	}
	if rhs := m.ReservedRange; rhs != nil {
		tmpContainer := make([]*DescriptorProto_ReservedRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ReservedRange = tmpContainer
	}
	if rhs := m.ReservedName; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.ReservedName = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *DescriptorProto) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExtensionRangeOptions_Declaration) CloneVT() *ExtensionRangeOptions_Declaration {
	if m == nil {
		return (*ExtensionRangeOptions_Declaration)(nil)
	}
	r := new(ExtensionRangeOptions_Declaration)
	if rhs := m.Number; rhs != nil {
		tmpVal := *rhs
		r.Number = &tmpVal
	}
	if rhs := m.FullName; rhs != nil {
		tmpVal := *rhs
		r.FullName = &tmpVal
	}
	if rhs := m.Type; rhs != nil {
		tmpVal := *rhs
		r.Type = &tmpVal
	}
	if rhs := m.Reserved; rhs != nil {
		tmpVal := *rhs
		r.Reserved = &tmpVal
	}
	if rhs := m.Repeated; rhs != nil {
		tmpVal := *rhs
		r.Repeated = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExtensionRangeOptions_Declaration) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ExtensionRangeOptions) CloneVT() *ExtensionRangeOptions {
	if m == nil {
		return (*ExtensionRangeOptions)(nil)
	}
	r := new(ExtensionRangeOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if rhs := m.Declaration; rhs != nil {
		tmpContainer := make([]*ExtensionRangeOptions_Declaration, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Declaration = tmpContainer
	}
	if rhs := m.Verification; rhs != nil {
		tmpVal := *rhs
		r.Verification = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ExtensionRangeOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *FieldDescriptorProto) CloneVT() *FieldDescriptorProto {
	if m == nil {
		return (*FieldDescriptorProto)(nil)
	}
	r := new(FieldDescriptorProto)
	r.Options = m.Options.CloneVT()
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Number; rhs != nil {
		tmpVal := *rhs
		r.Number = &tmpVal
	}
	if rhs := m.Label; rhs != nil {
		tmpVal := *rhs
		r.Label = &tmpVal
	}
	if rhs := m.Type; rhs != nil {
		tmpVal := *rhs
		r.Type = &tmpVal
	}
	if rhs := m.TypeName; rhs != nil {
		tmpVal := *rhs
		r.TypeName = &tmpVal
	}
	if rhs := m.Extendee; rhs != nil {
		tmpVal := *rhs
		r.Extendee = &tmpVal
	}
	if rhs := m.DefaultValue; rhs != nil {
		tmpVal := *rhs
		r.DefaultValue = &tmpVal
	}
	if rhs := m.OneofIndex; rhs != nil {
		tmpVal := *rhs
		r.OneofIndex = &tmpVal
	}
	if rhs := m.JsonName; rhs != nil {
		tmpVal := *rhs
		r.JsonName = &tmpVal
	}
	if rhs := m.Proto3Optional; rhs != nil {
		tmpVal := *rhs
		r.Proto3Optional = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FieldDescriptorProto) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *OneofDescriptorProto) CloneVT() *OneofDescriptorProto {
	if m == nil {
		return (*OneofDescriptorProto)(nil)
	}
	r := new(OneofDescriptorProto)
	r.Options = m.Options.CloneVT()
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *OneofDescriptorProto) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnumDescriptorProto_EnumReservedRange) CloneVT() *EnumDescriptorProto_EnumReservedRange {
	if m == nil {
		return (*EnumDescriptorProto_EnumReservedRange)(nil)
	}
	r := new(EnumDescriptorProto_EnumReservedRange)
	if rhs := m.Start; rhs != nil {
		tmpVal := *rhs
		r.Start = &tmpVal
	}
	if rhs := m.End; rhs != nil {
		tmpVal := *rhs
		r.End = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *EnumDescriptorProto_EnumReservedRange) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnumDescriptorProto) CloneVT() *EnumDescriptorProto {
	if m == nil {
		return (*EnumDescriptorProto)(nil)
	}
	r := new(EnumDescriptorProto)
	r.Options = m.Options.CloneVT()
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Value; rhs != nil {
		tmpContainer := make([]*EnumValueDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Value = tmpContainer
	}
	if rhs := m.ReservedRange; rhs != nil {
		tmpContainer := make([]*EnumDescriptorProto_EnumReservedRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ReservedRange = tmpContainer
	}
	if rhs := m.ReservedName; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.ReservedName = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *EnumDescriptorProto) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnumValueDescriptorProto) CloneVT() *EnumValueDescriptorProto {
	if m == nil {
		return (*EnumValueDescriptorProto)(nil)
	}
	r := new(EnumValueDescriptorProto)
	r.Options = m.Options.CloneVT()
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Number; rhs != nil {
		tmpVal := *rhs
		r.Number = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *EnumValueDescriptorProto) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ServiceDescriptorProto) CloneVT() *ServiceDescriptorProto {
	if m == nil {
		return (*ServiceDescriptorProto)(nil)
	}
	r := new(ServiceDescriptorProto)
	r.Options = m.Options.CloneVT()
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Method; rhs != nil {
		tmpContainer := make([]*MethodDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Method = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ServiceDescriptorProto) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *MethodDescriptorProto) CloneVT() *MethodDescriptorProto {
	if m == nil {
		return (*MethodDescriptorProto)(nil)
	}
	r := new(MethodDescriptorProto)
	r.Options = m.Options.CloneVT()
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.InputType; rhs != nil {
		tmpVal := *rhs
		r.InputType = &tmpVal
	}
	if rhs := m.OutputType; rhs != nil {
		tmpVal := *rhs
		r.OutputType = &tmpVal
	}
	if rhs := m.ClientStreaming; rhs != nil {
		tmpVal := *rhs
		r.ClientStreaming = &tmpVal
	}
	if rhs := m.ServerStreaming; rhs != nil {
		tmpVal := *rhs
		r.ServerStreaming = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *MethodDescriptorProto) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *FileOptions) CloneVT() *FileOptions {
	if m == nil {
		return (*FileOptions)(nil)
	}
	r := new(FileOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.JavaPackage; rhs != nil {
		tmpVal := *rhs
		r.JavaPackage = &tmpVal
	}
	if rhs := m.JavaOuterClassname; rhs != nil {
		tmpVal := *rhs
		r.JavaOuterClassname = &tmpVal
	}
	if rhs := m.JavaMultipleFiles; rhs != nil {
		tmpVal := *rhs
		r.JavaMultipleFiles = &tmpVal
	}
	if rhs := m.JavaGenerateEqualsAndHash; rhs != nil {
		tmpVal := *rhs
		r.JavaGenerateEqualsAndHash = &tmpVal
	}
	if rhs := m.JavaStringCheckUtf8; rhs != nil {
		tmpVal := *rhs
		r.JavaStringCheckUtf8 = &tmpVal
	}
	if rhs := m.OptimizeFor; rhs != nil {
		tmpVal := *rhs
		r.OptimizeFor = &tmpVal
	}
	if rhs := m.GoPackage; rhs != nil {
		tmpVal := *rhs
		r.GoPackage = &tmpVal
	}
	if rhs := m.CcGenericServices; rhs != nil {
		tmpVal := *rhs
		r.CcGenericServices = &tmpVal
	}
	if rhs := m.JavaGenericServices; rhs != nil {
		tmpVal := *rhs
		r.JavaGenericServices = &tmpVal
	}
	if rhs := m.PyGenericServices; rhs != nil {
		tmpVal := *rhs
		r.PyGenericServices = &tmpVal
	}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.CcEnableArenas; rhs != nil {
		tmpVal := *rhs
		r.CcEnableArenas = &tmpVal
	}
	if rhs := m.ObjcClassPrefix; rhs != nil {
		tmpVal := *rhs
		r.ObjcClassPrefix = &tmpVal
	}
	if rhs := m.CsharpNamespace; rhs != nil {
		tmpVal := *rhs
		r.CsharpNamespace = &tmpVal
	}
	if rhs := m.SwiftPrefix; rhs != nil {
		tmpVal := *rhs
		r.SwiftPrefix = &tmpVal
	}
	if rhs := m.PhpClassPrefix; rhs != nil {
		tmpVal := *rhs
		r.PhpClassPrefix = &tmpVal
	}
	if rhs := m.PhpNamespace; rhs != nil {
		tmpVal := *rhs
		r.PhpNamespace = &tmpVal
	}
	if rhs := m.PhpMetadataNamespace; rhs != nil {
		tmpVal := *rhs
		r.PhpMetadataNamespace = &tmpVal
	}
	if rhs := m.RubyPackage; rhs != nil {
		tmpVal := *rhs
		r.RubyPackage = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FileOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *MessageOptions) CloneVT() *MessageOptions {
	if m == nil {
		return (*MessageOptions)(nil)
	}
	r := new(MessageOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.MessageSetWireFormat; rhs != nil {
		tmpVal := *rhs
		r.MessageSetWireFormat = &tmpVal
	}
	if rhs := m.NoStandardDescriptorAccessor; rhs != nil {
		tmpVal := *rhs
		r.NoStandardDescriptorAccessor = &tmpVal
	}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.MapEntry; rhs != nil {
		tmpVal := *rhs
		r.MapEntry = &tmpVal
	}
	if rhs := m.DeprecatedLegacyJsonFieldConflicts; rhs != nil {
		tmpVal := *rhs
		r.DeprecatedLegacyJsonFieldConflicts = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *MessageOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *FieldOptions_EditionDefault) CloneVT() *FieldOptions_EditionDefault {
	if m == nil {
		return (*FieldOptions_EditionDefault)(nil)
	}
	r := new(FieldOptions_EditionDefault)
	if rhs := m.Edition; rhs != nil {
		tmpVal := *rhs
		r.Edition = &tmpVal
	}
	if rhs := m.Value; rhs != nil {
		tmpVal := *rhs
		r.Value = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FieldOptions_EditionDefault) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *FieldOptions) CloneVT() *FieldOptions {
	if m == nil {
		return (*FieldOptions)(nil)
	}
	r := new(FieldOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.Ctype; rhs != nil {
		tmpVal := *rhs
		r.Ctype = &tmpVal
	}
	if rhs := m.Packed; rhs != nil {
		tmpVal := *rhs
		r.Packed = &tmpVal
	}
	if rhs := m.Jstype; rhs != nil {
		tmpVal := *rhs
		r.Jstype = &tmpVal
	}
	if rhs := m.Lazy; rhs != nil {
		tmpVal := *rhs
		r.Lazy = &tmpVal
	}
	if rhs := m.UnverifiedLazy; rhs != nil {
		tmpVal := *rhs
		r.UnverifiedLazy = &tmpVal
	}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.Weak; rhs != nil {
		tmpVal := *rhs
		r.Weak = &tmpVal
	}
	if rhs := m.DebugRedact; rhs != nil {
		tmpVal := *rhs
		r.DebugRedact = &tmpVal
	}
	if rhs := m.Retention; rhs != nil {
		tmpVal := *rhs
		r.Retention = &tmpVal
	}
	if rhs := m.Targets; rhs != nil {
		tmpContainer := make([]FieldOptions_OptionTargetType, len(rhs))
		copy(tmpContainer, rhs)
		r.Targets = tmpContainer
	}
	if rhs := m.EditionDefaults; rhs != nil {
		tmpContainer := make([]*FieldOptions_EditionDefault, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.EditionDefaults = tmpContainer
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FieldOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *OneofOptions) CloneVT() *OneofOptions {
	if m == nil {
		return (*OneofOptions)(nil)
	}
	r := new(OneofOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *OneofOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnumOptions) CloneVT() *EnumOptions {
	if m == nil {
		return (*EnumOptions)(nil)
	}
	r := new(EnumOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.AllowAlias; rhs != nil {
		tmpVal := *rhs
		r.AllowAlias = &tmpVal
	}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.DeprecatedLegacyJsonFieldConflicts; rhs != nil {
		tmpVal := *rhs
		r.DeprecatedLegacyJsonFieldConflicts = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *EnumOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnumValueOptions) CloneVT() *EnumValueOptions {
	if m == nil {
		return (*EnumValueOptions)(nil)
	}
	r := new(EnumValueOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.DebugRedact; rhs != nil {
		tmpVal := *rhs
		r.DebugRedact = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *EnumValueOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ServiceOptions) CloneVT() *ServiceOptions {
	if m == nil {
		return (*ServiceOptions)(nil)
	}
	r := new(ServiceOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ServiceOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *MethodOptions) CloneVT() *MethodOptions {
	if m == nil {
		return (*MethodOptions)(nil)
	}
	r := new(MethodOptions)
	r.Features = m.Features.CloneVT()
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.IdempotencyLevel; rhs != nil {
		tmpVal := *rhs
		r.IdempotencyLevel = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.UninterpretedOption = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *MethodOptions) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *UninterpretedOption_NamePart) CloneVT() *UninterpretedOption_NamePart {
	if m == nil {
		return (*UninterpretedOption_NamePart)(nil)
	}
	r := new(UninterpretedOption_NamePart)
	if rhs := m.NamePart; rhs != nil {
		tmpVal := *rhs
		r.NamePart = &tmpVal
	}
	if rhs := m.IsExtension; rhs != nil {
		tmpVal := *rhs
		r.IsExtension = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *UninterpretedOption_NamePart) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *UninterpretedOption) CloneVT() *UninterpretedOption {
	if m == nil {
		return (*UninterpretedOption)(nil)
	}
	r := new(UninterpretedOption)
	if rhs := m.Name; rhs != nil {
		tmpContainer := make([]*UninterpretedOption_NamePart, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Name = tmpContainer
	}
	if rhs := m.IdentifierValue; rhs != nil {
		tmpVal := *rhs
		r.IdentifierValue = &tmpVal
	}
	if rhs := m.PositiveIntValue; rhs != nil {
		tmpVal := *rhs
		r.PositiveIntValue = &tmpVal
	}
	if rhs := m.NegativeIntValue; rhs != nil {
		tmpVal := *rhs
		r.NegativeIntValue = &tmpVal
	}
	if rhs := m.DoubleValue; rhs != nil {
		tmpVal := *rhs
		r.DoubleValue = &tmpVal
	}
	if rhs := m.StringValue; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.StringValue = tmpBytes
	}
	if rhs := m.AggregateValue; rhs != nil {
		tmpVal := *rhs
		r.AggregateValue = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *UninterpretedOption) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *FeatureSet) CloneVT() *FeatureSet {
	if m == nil {
		return (*FeatureSet)(nil)
	}
	r := new(FeatureSet)
	if rhs := m.FieldPresence; rhs != nil {
		tmpVal := *rhs
		r.FieldPresence = &tmpVal
	}
	if rhs := m.EnumType; rhs != nil {
		tmpVal := *rhs
		r.EnumType = &tmpVal
	}
	if rhs := m.RepeatedFieldEncoding; rhs != nil {
		tmpVal := *rhs
		r.RepeatedFieldEncoding = &tmpVal
	}
	if rhs := m.Utf8Validation; rhs != nil {
		tmpVal := *rhs
		r.Utf8Validation = &tmpVal
	}
	if rhs := m.MessageEncoding; rhs != nil {
		tmpVal := *rhs
		r.MessageEncoding = &tmpVal
	}
	if rhs := m.JsonFormat; rhs != nil {
		tmpVal := *rhs
		r.JsonFormat = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FeatureSet) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) CloneVT() *FeatureSetDefaults_FeatureSetEditionDefault {
	if m == nil {
		return (*FeatureSetDefaults_FeatureSetEditionDefault)(nil)
	}
	r := new(FeatureSetDefaults_FeatureSetEditionDefault)
	r.Features = m.Features.CloneVT()
	if rhs := m.Edition; rhs != nil {
		tmpVal := *rhs
		r.Edition = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *FeatureSetDefaults) CloneVT() *FeatureSetDefaults {
	if m == nil {
		return (*FeatureSetDefaults)(nil)
	}
	r := new(FeatureSetDefaults)
	if rhs := m.Defaults; rhs != nil {
		tmpContainer := make([]*FeatureSetDefaults_FeatureSetEditionDefault, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Defaults = tmpContainer
	}
	if rhs := m.MinimumEdition; rhs != nil {
		tmpVal := *rhs
		r.MinimumEdition = &tmpVal
	}
	if rhs := m.MaximumEdition; rhs != nil {
		tmpVal := *rhs
		r.MaximumEdition = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FeatureSetDefaults) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SourceCodeInfo_Location) CloneVT() *SourceCodeInfo_Location {
	if m == nil {
		return (*SourceCodeInfo_Location)(nil)
	}
	r := new(SourceCodeInfo_Location)
	if rhs := m.Path; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.Path = tmpContainer
	}
	if rhs := m.Span; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.Span = tmpContainer
	}
	if rhs := m.LeadingComments; rhs != nil {
		tmpVal := *rhs
		r.LeadingComments = &tmpVal
	}
	if rhs := m.TrailingComments; rhs != nil {
		tmpVal := *rhs
		r.TrailingComments = &tmpVal
	}
	if rhs := m.LeadingDetachedComments; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.LeadingDetachedComments = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SourceCodeInfo_Location) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *SourceCodeInfo) CloneVT() *SourceCodeInfo {
	if m == nil {
		return (*SourceCodeInfo)(nil)
	}
	r := new(SourceCodeInfo)
	if rhs := m.Location; rhs != nil {
		tmpContainer := make([]*SourceCodeInfo_Location, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Location = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SourceCodeInfo) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *GeneratedCodeInfo_Annotation) CloneVT() *GeneratedCodeInfo_Annotation {
	if m == nil {
		return (*GeneratedCodeInfo_Annotation)(nil)
	}
	r := new(GeneratedCodeInfo_Annotation)
	if rhs := m.Path; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.Path = tmpContainer
	}
	if rhs := m.SourceFile; rhs != nil {
		tmpVal := *rhs
		r.SourceFile = &tmpVal
	}
	if rhs := m.Begin; rhs != nil {
		tmpVal := *rhs
		r.Begin = &tmpVal
	}
	if rhs := m.End; rhs != nil {
		tmpVal := *rhs
		r.End = &tmpVal
	}
	if rhs := m.Semantic; rhs != nil {
		tmpVal := *rhs
		r.Semantic = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GeneratedCodeInfo_Annotation) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *GeneratedCodeInfo) CloneVT() *GeneratedCodeInfo {
	if m == nil {
		return (*GeneratedCodeInfo)(nil)
	}
	r := new(GeneratedCodeInfo)
	if rhs := m.Annotation; rhs != nil {
		tmpContainer := make([]*GeneratedCodeInfo_Annotation, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Annotation = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *GeneratedCodeInfo) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (this *FileDescriptorSet) EqualVT(that *FileDescriptorSet) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.File) != len(that.File) {
		return false
	}
	for i, vx := range this.File {
		vy := that.File[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &FileDescriptorProto{}
			}
			if q == nil {
				q = &FileDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FileDescriptorSet) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FileDescriptorSet)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FileDescriptorProto) EqualVT(that *FileDescriptorProto) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Package, that.Package; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Dependency) != len(that.Dependency) {
		return false
	}
	for i, vx := range this.Dependency {
		vy := that.Dependency[i]
		if vx != vy {
			return false
		}
	}
	if len(this.MessageType) != len(that.MessageType) {
		return false
	}
	for i, vx := range this.MessageType {
		vy := that.MessageType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &DescriptorProto{}
			}
			if q == nil {
				q = &DescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.EnumType) != len(that.EnumType) {
		return false
	}
	for i, vx := range this.EnumType {
		vy := that.EnumType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &EnumDescriptorProto{}
			}
			if q == nil {
				q = &EnumDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.Service) != len(that.Service) {
		return false
	}
	for i, vx := range this.Service {
		vy := that.Service[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ServiceDescriptorProto{}
			}
			if q == nil {
				q = &ServiceDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.Extension) != len(that.Extension) {
		return false
	}
	for i, vx := range this.Extension {
		vy := that.Extension[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &FieldDescriptorProto{}
			}
			if q == nil {
				q = &FieldDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	if !this.SourceCodeInfo.EqualVT(that.SourceCodeInfo) {
		return false
	}
	if len(this.PublicDependency) != len(that.PublicDependency) {
		return false
	}
	for i, vx := range this.PublicDependency {
		vy := that.PublicDependency[i]
		if vx != vy {
			return false
		}
	}
	if len(this.WeakDependency) != len(that.WeakDependency) {
		return false
	}
	for i, vx := range this.WeakDependency {
		vy := that.WeakDependency[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.Syntax, that.Syntax; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Edition, that.Edition; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FileDescriptorProto) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FileDescriptorProto)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *DescriptorProto_ExtensionRange) EqualVT(that *DescriptorProto_ExtensionRange) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Start, that.Start; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.End, that.End; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *DescriptorProto_ExtensionRange) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*DescriptorProto_ExtensionRange)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *DescriptorProto_ReservedRange) EqualVT(that *DescriptorProto_ReservedRange) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Start, that.Start; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.End, that.End; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *DescriptorProto_ReservedRange) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*DescriptorProto_ReservedRange)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *DescriptorProto) EqualVT(that *DescriptorProto) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Field) != len(that.Field) {
		return false
	}
	for i, vx := range this.Field {
		vy := that.Field[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &FieldDescriptorProto{}
			}
			if q == nil {
				q = &FieldDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.NestedType) != len(that.NestedType) {
		return false
	}
	for i, vx := range this.NestedType {
		vy := that.NestedType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &DescriptorProto{}
			}
			if q == nil {
				q = &DescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.EnumType) != len(that.EnumType) {
		return false
	}
	for i, vx := range this.EnumType {
		vy := that.EnumType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &EnumDescriptorProto{}
			}
			if q == nil {
				q = &EnumDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.ExtensionRange) != len(that.ExtensionRange) {
		return false
	}
	for i, vx := range this.ExtensionRange {
		vy := that.ExtensionRange[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &DescriptorProto_ExtensionRange{}
			}
			if q == nil {
				q = &DescriptorProto_ExtensionRange{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.Extension) != len(that.Extension) {
		return false
	}
	for i, vx := range this.Extension {
		vy := that.Extension[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &FieldDescriptorProto{}
			}
			if q == nil {
				q = &FieldDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	if len(this.OneofDecl) != len(that.OneofDecl) {
		return false
	}
	for i, vx := range this.OneofDecl {
		vy := that.OneofDecl[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &OneofDescriptorProto{}
			}
			if q == nil {
				q = &OneofDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.ReservedRange) != len(that.ReservedRange) {
		return false
	}
	for i, vx := range this.ReservedRange {
		vy := that.ReservedRange[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &DescriptorProto_ReservedRange{}
			}
			if q == nil {
				q = &DescriptorProto_ReservedRange{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.ReservedName) != len(that.ReservedName) {
		return false
	}
	for i, vx := range this.ReservedName {
		vy := that.ReservedName[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *DescriptorProto) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*DescriptorProto)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExtensionRangeOptions_Declaration) EqualVT(that *ExtensionRangeOptions_Declaration) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Number, that.Number; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.FullName, that.FullName; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Type, that.Type; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Reserved, that.Reserved; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Repeated, that.Repeated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExtensionRangeOptions_Declaration) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExtensionRangeOptions_Declaration)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ExtensionRangeOptions) EqualVT(that *ExtensionRangeOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Declaration) != len(that.Declaration) {
		return false
	}
	for i, vx := range this.Declaration {
		vy := that.Declaration[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ExtensionRangeOptions_Declaration{}
			}
			if q == nil {
				q = &ExtensionRangeOptions_Declaration{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if p, q := this.Verification, that.Verification; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ExtensionRangeOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ExtensionRangeOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FieldDescriptorProto) EqualVT(that *FieldDescriptorProto) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Extendee, that.Extendee; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Number, that.Number; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Label, that.Label; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Type, that.Type; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.TypeName, that.TypeName; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultValue, that.DefaultValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	if p, q := this.OneofIndex, that.OneofIndex; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JsonName, that.JsonName; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Proto3Optional, that.Proto3Optional; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FieldDescriptorProto) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FieldDescriptorProto)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *OneofDescriptorProto) EqualVT(that *OneofDescriptorProto) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *OneofDescriptorProto) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*OneofDescriptorProto)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *EnumDescriptorProto_EnumReservedRange) EqualVT(that *EnumDescriptorProto_EnumReservedRange) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Start, that.Start; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.End, that.End; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnumDescriptorProto_EnumReservedRange) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnumDescriptorProto_EnumReservedRange)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *EnumDescriptorProto) EqualVT(that *EnumDescriptorProto) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Value) != len(that.Value) {
		return false
	}
	for i, vx := range this.Value {
		vy := that.Value[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &EnumValueDescriptorProto{}
			}
			if q == nil {
				q = &EnumValueDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	if len(this.ReservedRange) != len(that.ReservedRange) {
		return false
	}
	for i, vx := range this.ReservedRange {
		vy := that.ReservedRange[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &EnumDescriptorProto_EnumReservedRange{}
			}
			if q == nil {
				q = &EnumDescriptorProto_EnumReservedRange{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.ReservedName) != len(that.ReservedName) {
		return false
	}
	for i, vx := range this.ReservedName {
		vy := that.ReservedName[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnumDescriptorProto) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnumDescriptorProto)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *EnumValueDescriptorProto) EqualVT(that *EnumValueDescriptorProto) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Number, that.Number; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnumValueDescriptorProto) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnumValueDescriptorProto)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ServiceDescriptorProto) EqualVT(that *ServiceDescriptorProto) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Method) != len(that.Method) {
		return false
	}
	for i, vx := range this.Method {
		vy := that.Method[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &MethodDescriptorProto{}
			}
			if q == nil {
				q = &MethodDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ServiceDescriptorProto) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ServiceDescriptorProto)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *MethodDescriptorProto) EqualVT(that *MethodDescriptorProto) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.InputType, that.InputType; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OutputType, that.OutputType; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Options.EqualVT(that.Options) {
		return false
	}
	if p, q := this.ClientStreaming, that.ClientStreaming; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.ServerStreaming, that.ServerStreaming; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *MethodDescriptorProto) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*MethodDescriptorProto)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FileOptions) EqualVT(that *FileOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.JavaPackage, that.JavaPackage; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaOuterClassname, that.JavaOuterClassname; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptimizeFor, that.OptimizeFor; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaMultipleFiles, that.JavaMultipleFiles; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.GoPackage, that.GoPackage; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.CcGenericServices, that.CcGenericServices; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaGenericServices, that.JavaGenericServices; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PyGenericServices, that.PyGenericServices; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaGenerateEqualsAndHash, that.JavaGenerateEqualsAndHash; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaStringCheckUtf8, that.JavaStringCheckUtf8; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.CcEnableArenas, that.CcEnableArenas; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.ObjcClassPrefix, that.ObjcClassPrefix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.CsharpNamespace, that.CsharpNamespace; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.SwiftPrefix, that.SwiftPrefix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PhpClassPrefix, that.PhpClassPrefix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PhpNamespace, that.PhpNamespace; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PhpMetadataNamespace, that.PhpMetadataNamespace; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.RubyPackage, that.RubyPackage; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FileOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FileOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *MessageOptions) EqualVT(that *MessageOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.MessageSetWireFormat, that.MessageSetWireFormat; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.NoStandardDescriptorAccessor, that.NoStandardDescriptorAccessor; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MapEntry, that.MapEntry; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DeprecatedLegacyJsonFieldConflicts, that.DeprecatedLegacyJsonFieldConflicts; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *MessageOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*MessageOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FieldOptions_EditionDefault) EqualVT(that *FieldOptions_EditionDefault) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Value, that.Value; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Edition, that.Edition; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FieldOptions_EditionDefault) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FieldOptions_EditionDefault)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FieldOptions) EqualVT(that *FieldOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Ctype, that.Ctype; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Packed, that.Packed; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lazy, that.Lazy; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Jstype, that.Jstype; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Weak, that.Weak; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.UnverifiedLazy, that.UnverifiedLazy; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DebugRedact, that.DebugRedact; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Retention, that.Retention; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Targets) != len(that.Targets) {
		return false
	}
	for i, vx := range this.Targets {
		vy := that.Targets[i]
		if vx != vy {
			return false
		}
	}
	if len(this.EditionDefaults) != len(that.EditionDefaults) {
		return false
	}
	for i, vx := range this.EditionDefaults {
		vy := that.EditionDefaults[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &FieldOptions_EditionDefault{}
			}
			if q == nil {
				q = &FieldOptions_EditionDefault{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FieldOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FieldOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *OneofOptions) EqualVT(that *OneofOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *OneofOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*OneofOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *EnumOptions) EqualVT(that *EnumOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.AllowAlias, that.AllowAlias; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DeprecatedLegacyJsonFieldConflicts, that.DeprecatedLegacyJsonFieldConflicts; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnumOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnumOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *EnumValueOptions) EqualVT(that *EnumValueOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if p, q := this.DebugRedact, that.DebugRedact; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnumValueOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnumValueOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ServiceOptions) EqualVT(that *ServiceOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ServiceOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ServiceOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *MethodOptions) EqualVT(that *MethodOptions) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.IdempotencyLevel, that.IdempotencyLevel; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption{}
			}
			if q == nil {
				q = &UninterpretedOption{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *MethodOptions) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*MethodOptions)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *UninterpretedOption_NamePart) EqualVT(that *UninterpretedOption_NamePart) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.NamePart, that.NamePart; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.IsExtension, that.IsExtension; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *UninterpretedOption_NamePart) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*UninterpretedOption_NamePart)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *UninterpretedOption) EqualVT(that *UninterpretedOption) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Name) != len(that.Name) {
		return false
	}
	for i, vx := range this.Name {
		vy := that.Name[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &UninterpretedOption_NamePart{}
			}
			if q == nil {
				q = &UninterpretedOption_NamePart{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if p, q := this.IdentifierValue, that.IdentifierValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PositiveIntValue, that.PositiveIntValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.NegativeIntValue, that.NegativeIntValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DoubleValue, that.DoubleValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.StringValue, that.StringValue; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if p, q := this.AggregateValue, that.AggregateValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *UninterpretedOption) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*UninterpretedOption)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FeatureSet) EqualVT(that *FeatureSet) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.FieldPresence, that.FieldPresence; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.EnumType, that.EnumType; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.RepeatedFieldEncoding, that.RepeatedFieldEncoding; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Utf8Validation, that.Utf8Validation; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MessageEncoding, that.MessageEncoding; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JsonFormat, that.JsonFormat; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FeatureSet) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FeatureSet)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FeatureSetDefaults_FeatureSetEditionDefault) EqualVT(that *FeatureSetDefaults_FeatureSetEditionDefault) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Features.EqualVT(that.Features) {
		return false
	}
	if p, q := this.Edition, that.Edition; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FeatureSetDefaults_FeatureSetEditionDefault) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FeatureSetDefaults_FeatureSetEditionDefault)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FeatureSetDefaults) EqualVT(that *FeatureSetDefaults) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Defaults) != len(that.Defaults) {
		return false
	}
	for i, vx := range this.Defaults {
		vy := that.Defaults[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &FeatureSetDefaults_FeatureSetEditionDefault{}
			}
			if q == nil {
				q = &FeatureSetDefaults_FeatureSetEditionDefault{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if p, q := this.MinimumEdition, that.MinimumEdition; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MaximumEdition, that.MaximumEdition; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FeatureSetDefaults) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*FeatureSetDefaults)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SourceCodeInfo_Location) EqualVT(that *SourceCodeInfo_Location) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Path) != len(that.Path) {
		return false
	}
	for i, vx := range this.Path {
		vy := that.Path[i]
		if vx != vy {
			return false
		}
	}
	if len(this.Span) != len(that.Span) {
		return false
	}
	for i, vx := range this.Span {
		vy := that.Span[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.LeadingComments, that.LeadingComments; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.TrailingComments, that.TrailingComments; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.LeadingDetachedComments) != len(that.LeadingDetachedComments) {
		return false
	}
	for i, vx := range this.LeadingDetachedComments {
		vy := that.LeadingDetachedComments[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SourceCodeInfo_Location) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SourceCodeInfo_Location)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SourceCodeInfo) EqualVT(that *SourceCodeInfo) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Location) != len(that.Location) {
		return false
	}
	for i, vx := range this.Location {
		vy := that.Location[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &SourceCodeInfo_Location{}
			}
			if q == nil {
				q = &SourceCodeInfo_Location{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SourceCodeInfo) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*SourceCodeInfo)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *GeneratedCodeInfo_Annotation) EqualVT(that *GeneratedCodeInfo_Annotation) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Path) != len(that.Path) {
		return false
	}
	for i, vx := range this.Path {
		vy := that.Path[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.SourceFile, that.SourceFile; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Begin, that.Begin; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.End, that.End; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Semantic, that.Semantic; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GeneratedCodeInfo_Annotation) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*GeneratedCodeInfo_Annotation)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *GeneratedCodeInfo) EqualVT(that *GeneratedCodeInfo) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Annotation) != len(that.Annotation) {
		return false
	}
	for i, vx := range this.Annotation {
		vy := that.Annotation[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &GeneratedCodeInfo_Annotation{}
			}
			if q == nil {
				q = &GeneratedCodeInfo_Annotation{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *GeneratedCodeInfo) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*GeneratedCodeInfo)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// NOTE: protobuf-go-lite json only supports proto3: proto2 is not supported.

func (m *FileDescriptorSet) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDescriptorSet) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FileDescriptorSet) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.File) > 0 {
		for iNdEx := len(m.File) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.File[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FileDescriptorProto) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDescriptorProto) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FileDescriptorProto) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Edition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Edition))
		i--
		dAtA[i] = 0x70
	}
	if m.Syntax != nil {
		i -= len(*m.Syntax)
		copy(dAtA[i:], *m.Syntax)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Syntax)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.WeakDependency) > 0 {
		for iNdEx := len(m.WeakDependency) - 1; iNdEx >= 0; iNdEx-- {
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.WeakDependency[iNdEx]))
			i--
			dAtA[i] = 0x58
		}
	}
	if len(m.PublicDependency) > 0 {
		for iNdEx := len(m.PublicDependency) - 1; iNdEx >= 0; iNdEx-- {
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.PublicDependency[iNdEx]))
			i--
			dAtA[i] = 0x50
		}
	}
	if m.SourceCodeInfo != nil {
		size, err := m.SourceCodeInfo.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Extension[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Service) > 0 {
		for iNdEx := len(m.Service) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Service[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EnumType) > 0 {
		for iNdEx := len(m.EnumType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.EnumType[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MessageType) > 0 {
		for iNdEx := len(m.MessageType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.MessageType[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Dependency) > 0 {
		for iNdEx := len(m.Dependency) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dependency[iNdEx])
			copy(dAtA[i:], m.Dependency[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Dependency[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Package != nil {
		i -= len(*m.Package)
		copy(dAtA[i:], *m.Package)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Package)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DescriptorProto_ExtensionRange) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorProto_ExtensionRange) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *DescriptorProto_ExtensionRange) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.End != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DescriptorProto_ReservedRange) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorProto_ReservedRange) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *DescriptorProto_ReservedRange) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.End != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DescriptorProto) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorProto) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *DescriptorProto) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ReservedName) > 0 {
		for iNdEx := len(m.ReservedName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReservedName[iNdEx])
			copy(dAtA[i:], m.ReservedName[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ReservedName[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ReservedRange) > 0 {
		for iNdEx := len(m.ReservedRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ReservedRange[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.OneofDecl) > 0 {
		for iNdEx := len(m.OneofDecl) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.OneofDecl[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Extension[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ExtensionRange) > 0 {
		for iNdEx := len(m.ExtensionRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ExtensionRange[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EnumType) > 0 {
		for iNdEx := len(m.EnumType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.EnumType[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NestedType) > 0 {
		for iNdEx := len(m.NestedType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.NestedType[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Field) > 0 {
		for iNdEx := len(m.Field) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Field[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtensionRangeOptions_Declaration) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtensionRangeOptions_Declaration) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExtensionRangeOptions_Declaration) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Repeated != nil {
		i--
		if *m.Repeated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Reserved != nil {
		i--
		if *m.Reserved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FullName != nil {
		i -= len(*m.FullName)
		copy(dAtA[i:], *m.FullName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.FullName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtensionRangeOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtensionRangeOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ExtensionRangeOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.Verification != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Verification))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Declaration) > 0 {
		for iNdEx := len(m.Declaration) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Declaration[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *FieldDescriptorProto) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldDescriptorProto) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldDescriptorProto) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Proto3Optional != nil {
		i--
		if *m.Proto3Optional {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.JsonName != nil {
		i -= len(*m.JsonName)
		copy(dAtA[i:], *m.JsonName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.JsonName)))
		i--
		dAtA[i] = 0x52
	}
	if m.OneofIndex != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.OneofIndex))
		i--
		dAtA[i] = 0x48
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if m.DefaultValue != nil {
		i -= len(*m.DefaultValue)
		copy(dAtA[i:], *m.DefaultValue)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.DefaultValue)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TypeName != nil {
		i -= len(*m.TypeName)
		copy(dAtA[i:], *m.TypeName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.TypeName)))
		i--
		dAtA[i] = 0x32
	}
	if m.Type != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.Label != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Label))
		i--
		dAtA[i] = 0x20
	}
	if m.Number != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x18
	}
	if m.Extendee != nil {
		i -= len(*m.Extendee)
		copy(dAtA[i:], *m.Extendee)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Extendee)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OneofDescriptorProto) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneofDescriptorProto) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *OneofDescriptorProto) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnumDescriptorProto_EnumReservedRange) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumDescriptorProto_EnumReservedRange) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnumDescriptorProto_EnumReservedRange) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.End != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnumDescriptorProto) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumDescriptorProto) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnumDescriptorProto) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ReservedName) > 0 {
		for iNdEx := len(m.ReservedName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReservedName[iNdEx])
			copy(dAtA[i:], m.ReservedName[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ReservedName[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ReservedRange) > 0 {
		for iNdEx := len(m.ReservedRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ReservedRange[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Value[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnumValueDescriptorProto) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumValueDescriptorProto) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnumValueDescriptorProto) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Number != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x10
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDescriptorProto) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDescriptorProto) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ServiceDescriptorProto) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Method) > 0 {
		for iNdEx := len(m.Method) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Method[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MethodDescriptorProto) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MethodDescriptorProto) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MethodDescriptorProto) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.ServerStreaming != nil {
		i--
		if *m.ServerStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ClientStreaming != nil {
		i--
		if *m.ClientStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.OutputType != nil {
		i -= len(*m.OutputType)
		copy(dAtA[i:], *m.OutputType)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.OutputType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.InputType != nil {
		i -= len(*m.InputType)
		copy(dAtA[i:], *m.InputType)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.InputType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FileOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.RubyPackage != nil {
		i -= len(*m.RubyPackage)
		copy(dAtA[i:], *m.RubyPackage)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.RubyPackage)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.PhpMetadataNamespace != nil {
		i -= len(*m.PhpMetadataNamespace)
		copy(dAtA[i:], *m.PhpMetadataNamespace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.PhpMetadataNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.PhpNamespace != nil {
		i -= len(*m.PhpNamespace)
		copy(dAtA[i:], *m.PhpNamespace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.PhpNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.PhpClassPrefix != nil {
		i -= len(*m.PhpClassPrefix)
		copy(dAtA[i:], *m.PhpClassPrefix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.PhpClassPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.SwiftPrefix != nil {
		i -= len(*m.SwiftPrefix)
		copy(dAtA[i:], *m.SwiftPrefix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.SwiftPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.CsharpNamespace != nil {
		i -= len(*m.CsharpNamespace)
		copy(dAtA[i:], *m.CsharpNamespace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.CsharpNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.ObjcClassPrefix != nil {
		i -= len(*m.ObjcClassPrefix)
		copy(dAtA[i:], *m.ObjcClassPrefix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.ObjcClassPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.CcEnableArenas != nil {
		i--
		if *m.CcEnableArenas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.JavaStringCheckUtf8 != nil {
		i--
		if *m.JavaStringCheckUtf8 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.JavaGenerateEqualsAndHash != nil {
		i--
		if *m.JavaGenerateEqualsAndHash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.PyGenericServices != nil {
		i--
		if *m.PyGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.JavaGenericServices != nil {
		i--
		if *m.JavaGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.CcGenericServices != nil {
		i--
		if *m.CcGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GoPackage != nil {
		i -= len(*m.GoPackage)
		copy(dAtA[i:], *m.GoPackage)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.GoPackage)))
		i--
		dAtA[i] = 0x5a
	}
	if m.JavaMultipleFiles != nil {
		i--
		if *m.JavaMultipleFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OptimizeFor != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.OptimizeFor))
		i--
		dAtA[i] = 0x48
	}
	if m.JavaOuterClassname != nil {
		i -= len(*m.JavaOuterClassname)
		copy(dAtA[i:], *m.JavaOuterClassname)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.JavaOuterClassname)))
		i--
		dAtA[i] = 0x42
	}
	if m.JavaPackage != nil {
		i -= len(*m.JavaPackage)
		copy(dAtA[i:], *m.JavaPackage)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.JavaPackage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MessageOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	}
	if m.DeprecatedLegacyJsonFieldConflicts != nil {
		i--
		if *m.DeprecatedLegacyJsonFieldConflicts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.MapEntry != nil {
		i--
		if *m.MapEntry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NoStandardDescriptorAccessor != nil {
		i--
		if *m.NoStandardDescriptorAccessor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MessageSetWireFormat != nil {
		i--
		if *m.MessageSetWireFormat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldOptions_EditionDefault) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldOptions_EditionDefault) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldOptions_EditionDefault) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Edition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Edition))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *FieldOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.EditionDefaults) > 0 {
		for iNdEx := len(m.EditionDefaults) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.EditionDefaults[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Targets[iNdEx]))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x98
		}
	}
	if m.Retention != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Retention))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.DebugRedact != nil {
		i--
		if *m.DebugRedact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.UnverifiedLazy != nil {
		i--
		if *m.UnverifiedLazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Weak != nil {
		i--
		if *m.Weak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Jstype != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Jstype))
		i--
		dAtA[i] = 0x30
	}
	if m.Lazy != nil {
		i--
		if *m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Packed != nil {
		i--
		if *m.Packed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ctype != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Ctype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OneofOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneofOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *OneofOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnumOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnumOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if m.DeprecatedLegacyJsonFieldConflicts != nil {
		i--
		if *m.DeprecatedLegacyJsonFieldConflicts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllowAlias != nil {
		i--
		if *m.AllowAlias {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *EnumValueOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumValueOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnumValueOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.DebugRedact != nil {
		i--
		if *m.DebugRedact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ServiceOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	return len(dAtA) - i, nil
}

func (m *MethodOptions) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MethodOptions) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MethodOptions) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.IdempotencyLevel != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.IdempotencyLevel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	return len(dAtA) - i, nil
}

func (m *UninterpretedOption_NamePart) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UninterpretedOption_NamePart) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *UninterpretedOption_NamePart) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IsExtension == nil {
		return 0, errors.Errorf("proto: required field is_extension not set")
	} else {
		i--
		if *m.IsExtension {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NamePart == nil {
		return 0, errors.Errorf("proto: required field name_part not set")
	} else {
		i -= len(*m.NamePart)
		copy(dAtA[i:], *m.NamePart)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.NamePart)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UninterpretedOption) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UninterpretedOption) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *UninterpretedOption) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.AggregateValue != nil {
		i -= len(*m.AggregateValue)
		copy(dAtA[i:], *m.AggregateValue)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.AggregateValue)))
		i--
		dAtA[i] = 0x42
	}
	if m.StringValue != nil {
		i -= len(m.StringValue)
		copy(dAtA[i:], m.StringValue)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.StringValue)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DoubleValue != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DoubleValue))))
		i--
		dAtA[i] = 0x31
	}
	if m.NegativeIntValue != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.NegativeIntValue))
		i--
		dAtA[i] = 0x28
	}
	if m.PositiveIntValue != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.PositiveIntValue))
		i--
		dAtA[i] = 0x20
	}
	if m.IdentifierValue != nil {
		i -= len(*m.IdentifierValue)
		copy(dAtA[i:], *m.IdentifierValue)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.IdentifierValue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		for iNdEx := len(m.Name) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Name[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *FeatureSet) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureSet) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FeatureSet) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.JsonFormat != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.JsonFormat))
		i--
		dAtA[i] = 0x30
	}
	if m.MessageEncoding != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MessageEncoding))
		i--
		dAtA[i] = 0x28
	}
	if m.Utf8Validation != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Utf8Validation))
		i--
		dAtA[i] = 0x20
	}
	if m.RepeatedFieldEncoding != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.RepeatedFieldEncoding))
		i--
		dAtA[i] = 0x18
	}
	if m.EnumType != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.EnumType))
		i--
		dAtA[i] = 0x10
	}
	if m.FieldPresence != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.FieldPresence))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Edition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Edition))
		i--
		dAtA[i] = 0x18
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *FeatureSetDefaults) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureSetDefaults) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FeatureSetDefaults) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.MaximumEdition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MaximumEdition))
		i--
		dAtA[i] = 0x28
	}
	if m.MinimumEdition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MinimumEdition))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Defaults) > 0 {
		for iNdEx := len(m.Defaults) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Defaults[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SourceCodeInfo_Location) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceCodeInfo_Location) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SourceCodeInfo_Location) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.LeadingDetachedComments) > 0 {
		for iNdEx := len(m.LeadingDetachedComments) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LeadingDetachedComments[iNdEx])
			copy(dAtA[i:], m.LeadingDetachedComments[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.LeadingDetachedComments[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.TrailingComments != nil {
		i -= len(*m.TrailingComments)
		copy(dAtA[i:], *m.TrailingComments)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.TrailingComments)))
		i--
		dAtA[i] = 0x22
	}
	if m.LeadingComments != nil {
		i -= len(*m.LeadingComments)
		copy(dAtA[i:], *m.LeadingComments)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.LeadingComments)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Span) > 0 {
		var pksize2 int
		for _, num := range m.Span {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.Span {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		var pksize4 int
		for _, num := range m.Path {
			pksize4 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize4
		j3 := i
		for _, num1 := range m.Path {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA[j3] = uint8(num)
			j3++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceCodeInfo) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceCodeInfo) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SourceCodeInfo) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Location) > 0 {
		for iNdEx := len(m.Location) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Location[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeneratedCodeInfo_Annotation) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedCodeInfo_Annotation) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GeneratedCodeInfo_Annotation) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Semantic != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Semantic))
		i--
		dAtA[i] = 0x28
	}
	if m.End != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x20
	}
	if m.Begin != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Begin))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceFile != nil {
		i -= len(*m.SourceFile)
		copy(dAtA[i:], *m.SourceFile)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.SourceFile)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		var pksize2 int
		for _, num := range m.Path {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.Path {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GeneratedCodeInfo) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedCodeInfo) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *GeneratedCodeInfo) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Annotation) > 0 {
		for iNdEx := len(m.Annotation) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Annotation[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FileDescriptorSet) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDescriptorSet) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FileDescriptorSet) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.File) > 0 {
		for iNdEx := len(m.File) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.File[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FileDescriptorProto) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDescriptorProto) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FileDescriptorProto) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Edition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Edition))
		i--
		dAtA[i] = 0x70
	}
	if m.Syntax != nil {
		i -= len(*m.Syntax)
		copy(dAtA[i:], *m.Syntax)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Syntax)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.WeakDependency) > 0 {
		for iNdEx := len(m.WeakDependency) - 1; iNdEx >= 0; iNdEx-- {
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.WeakDependency[iNdEx]))
			i--
			dAtA[i] = 0x58
		}
	}
	if len(m.PublicDependency) > 0 {
		for iNdEx := len(m.PublicDependency) - 1; iNdEx >= 0; iNdEx-- {
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.PublicDependency[iNdEx]))
			i--
			dAtA[i] = 0x50
		}
	}
	if m.SourceCodeInfo != nil {
		size, err := m.SourceCodeInfo.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Extension[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Service) > 0 {
		for iNdEx := len(m.Service) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Service[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EnumType) > 0 {
		for iNdEx := len(m.EnumType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.EnumType[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MessageType) > 0 {
		for iNdEx := len(m.MessageType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.MessageType[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Dependency) > 0 {
		for iNdEx := len(m.Dependency) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dependency[iNdEx])
			copy(dAtA[i:], m.Dependency[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Dependency[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Package != nil {
		i -= len(*m.Package)
		copy(dAtA[i:], *m.Package)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Package)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DescriptorProto_ExtensionRange) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorProto_ExtensionRange) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *DescriptorProto_ExtensionRange) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.End != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DescriptorProto_ReservedRange) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorProto_ReservedRange) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *DescriptorProto_ReservedRange) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.End != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DescriptorProto) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorProto) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *DescriptorProto) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ReservedName) > 0 {
		for iNdEx := len(m.ReservedName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReservedName[iNdEx])
			copy(dAtA[i:], m.ReservedName[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ReservedName[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ReservedRange) > 0 {
		for iNdEx := len(m.ReservedRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ReservedRange[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.OneofDecl) > 0 {
		for iNdEx := len(m.OneofDecl) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.OneofDecl[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Extension[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ExtensionRange) > 0 {
		for iNdEx := len(m.ExtensionRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ExtensionRange[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EnumType) > 0 {
		for iNdEx := len(m.EnumType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.EnumType[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NestedType) > 0 {
		for iNdEx := len(m.NestedType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.NestedType[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Field) > 0 {
		for iNdEx := len(m.Field) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Field[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtensionRangeOptions_Declaration) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtensionRangeOptions_Declaration) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *ExtensionRangeOptions_Declaration) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Repeated != nil {
		i--
		if *m.Repeated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Reserved != nil {
		i--
		if *m.Reserved {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Type != nil {
		i -= len(*m.Type)
		copy(dAtA[i:], *m.Type)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FullName != nil {
		i -= len(*m.FullName)
		copy(dAtA[i:], *m.FullName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.FullName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExtensionRangeOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtensionRangeOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *ExtensionRangeOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.Verification != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Verification))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Declaration) > 0 {
		for iNdEx := len(m.Declaration) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Declaration[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *FieldDescriptorProto) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldDescriptorProto) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FieldDescriptorProto) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Proto3Optional != nil {
		i--
		if *m.Proto3Optional {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.JsonName != nil {
		i -= len(*m.JsonName)
		copy(dAtA[i:], *m.JsonName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.JsonName)))
		i--
		dAtA[i] = 0x52
	}
	if m.OneofIndex != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.OneofIndex))
		i--
		dAtA[i] = 0x48
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if m.DefaultValue != nil {
		i -= len(*m.DefaultValue)
		copy(dAtA[i:], *m.DefaultValue)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.DefaultValue)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TypeName != nil {
		i -= len(*m.TypeName)
		copy(dAtA[i:], *m.TypeName)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.TypeName)))
		i--
		dAtA[i] = 0x32
	}
	if m.Type != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.Label != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Label))
		i--
		dAtA[i] = 0x20
	}
	if m.Number != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x18
	}
	if m.Extendee != nil {
		i -= len(*m.Extendee)
		copy(dAtA[i:], *m.Extendee)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Extendee)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OneofDescriptorProto) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneofDescriptorProto) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *OneofDescriptorProto) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnumDescriptorProto_EnumReservedRange) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumDescriptorProto_EnumReservedRange) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *EnumDescriptorProto_EnumReservedRange) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.End != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnumDescriptorProto) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumDescriptorProto) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *EnumDescriptorProto) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ReservedName) > 0 {
		for iNdEx := len(m.ReservedName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReservedName[iNdEx])
			copy(dAtA[i:], m.ReservedName[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ReservedName[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ReservedRange) > 0 {
		for iNdEx := len(m.ReservedRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ReservedRange[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Value[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnumValueDescriptorProto) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumValueDescriptorProto) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *EnumValueDescriptorProto) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Number != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x10
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceDescriptorProto) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDescriptorProto) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *ServiceDescriptorProto) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Method) > 0 {
		for iNdEx := len(m.Method) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Method[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MethodDescriptorProto) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MethodDescriptorProto) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *MethodDescriptorProto) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.ServerStreaming != nil {
		i--
		if *m.ServerStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ClientStreaming != nil {
		i--
		if *m.ClientStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Options != nil {
		size, err := m.Options.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.OutputType != nil {
		i -= len(*m.OutputType)
		copy(dAtA[i:], *m.OutputType)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.OutputType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.InputType != nil {
		i -= len(*m.InputType)
		copy(dAtA[i:], *m.InputType)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.InputType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FileOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.RubyPackage != nil {
		i -= len(*m.RubyPackage)
		copy(dAtA[i:], *m.RubyPackage)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.RubyPackage)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.PhpMetadataNamespace != nil {
		i -= len(*m.PhpMetadataNamespace)
		copy(dAtA[i:], *m.PhpMetadataNamespace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.PhpMetadataNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.PhpNamespace != nil {
		i -= len(*m.PhpNamespace)
		copy(dAtA[i:], *m.PhpNamespace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.PhpNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.PhpClassPrefix != nil {
		i -= len(*m.PhpClassPrefix)
		copy(dAtA[i:], *m.PhpClassPrefix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.PhpClassPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.SwiftPrefix != nil {
		i -= len(*m.SwiftPrefix)
		copy(dAtA[i:], *m.SwiftPrefix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.SwiftPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.CsharpNamespace != nil {
		i -= len(*m.CsharpNamespace)
		copy(dAtA[i:], *m.CsharpNamespace)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.CsharpNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.ObjcClassPrefix != nil {
		i -= len(*m.ObjcClassPrefix)
		copy(dAtA[i:], *m.ObjcClassPrefix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.ObjcClassPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.CcEnableArenas != nil {
		i--
		if *m.CcEnableArenas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.JavaStringCheckUtf8 != nil {
		i--
		if *m.JavaStringCheckUtf8 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.JavaGenerateEqualsAndHash != nil {
		i--
		if *m.JavaGenerateEqualsAndHash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.PyGenericServices != nil {
		i--
		if *m.PyGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.JavaGenericServices != nil {
		i--
		if *m.JavaGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.CcGenericServices != nil {
		i--
		if *m.CcGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GoPackage != nil {
		i -= len(*m.GoPackage)
		copy(dAtA[i:], *m.GoPackage)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.GoPackage)))
		i--
		dAtA[i] = 0x5a
	}
	if m.JavaMultipleFiles != nil {
		i--
		if *m.JavaMultipleFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OptimizeFor != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.OptimizeFor))
		i--
		dAtA[i] = 0x48
	}
	if m.JavaOuterClassname != nil {
		i -= len(*m.JavaOuterClassname)
		copy(dAtA[i:], *m.JavaOuterClassname)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.JavaOuterClassname)))
		i--
		dAtA[i] = 0x42
	}
	if m.JavaPackage != nil {
		i -= len(*m.JavaPackage)
		copy(dAtA[i:], *m.JavaPackage)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.JavaPackage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *MessageOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	}
	if m.DeprecatedLegacyJsonFieldConflicts != nil {
		i--
		if *m.DeprecatedLegacyJsonFieldConflicts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.MapEntry != nil {
		i--
		if *m.MapEntry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NoStandardDescriptorAccessor != nil {
		i--
		if *m.NoStandardDescriptorAccessor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MessageSetWireFormat != nil {
		i--
		if *m.MessageSetWireFormat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldOptions_EditionDefault) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldOptions_EditionDefault) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FieldOptions_EditionDefault) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Edition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Edition))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != nil {
		i -= len(*m.Value)
		copy(dAtA[i:], *m.Value)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Value)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *FieldOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FieldOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.EditionDefaults) > 0 {
		for iNdEx := len(m.EditionDefaults) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.EditionDefaults[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Targets[iNdEx]))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x98
		}
	}
	if m.Retention != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Retention))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.DebugRedact != nil {
		i--
		if *m.DebugRedact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.UnverifiedLazy != nil {
		i--
		if *m.UnverifiedLazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Weak != nil {
		i--
		if *m.Weak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Jstype != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Jstype))
		i--
		dAtA[i] = 0x30
	}
	if m.Lazy != nil {
		i--
		if *m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Packed != nil {
		i--
		if *m.Packed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ctype != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Ctype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OneofOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneofOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *OneofOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnumOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *EnumOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if m.DeprecatedLegacyJsonFieldConflicts != nil {
		i--
		if *m.DeprecatedLegacyJsonFieldConflicts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllowAlias != nil {
		i--
		if *m.AllowAlias {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *EnumValueOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumValueOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *EnumValueOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.DebugRedact != nil {
		i--
		if *m.DebugRedact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *ServiceOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	return len(dAtA) - i, nil
}

func (m *MethodOptions) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MethodOptions) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *MethodOptions) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.UninterpretedOption[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.IdempotencyLevel != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.IdempotencyLevel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	return len(dAtA) - i, nil
}

func (m *UninterpretedOption_NamePart) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UninterpretedOption_NamePart) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *UninterpretedOption_NamePart) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IsExtension == nil {
		return 0, errors.Errorf("proto: required field is_extension not set")
	} else {
		i--
		if *m.IsExtension {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NamePart == nil {
		return 0, errors.Errorf("proto: required field name_part not set")
	} else {
		i -= len(*m.NamePart)
		copy(dAtA[i:], *m.NamePart)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.NamePart)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UninterpretedOption) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UninterpretedOption) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *UninterpretedOption) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.AggregateValue != nil {
		i -= len(*m.AggregateValue)
		copy(dAtA[i:], *m.AggregateValue)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.AggregateValue)))
		i--
		dAtA[i] = 0x42
	}
	if m.StringValue != nil {
		i -= len(m.StringValue)
		copy(dAtA[i:], m.StringValue)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.StringValue)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DoubleValue != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DoubleValue))))
		i--
		dAtA[i] = 0x31
	}
	if m.NegativeIntValue != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.NegativeIntValue))
		i--
		dAtA[i] = 0x28
	}
	if m.PositiveIntValue != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.PositiveIntValue))
		i--
		dAtA[i] = 0x20
	}
	if m.IdentifierValue != nil {
		i -= len(*m.IdentifierValue)
		copy(dAtA[i:], *m.IdentifierValue)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.IdentifierValue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		for iNdEx := len(m.Name) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Name[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *FeatureSet) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureSet) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FeatureSet) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.JsonFormat != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.JsonFormat))
		i--
		dAtA[i] = 0x30
	}
	if m.MessageEncoding != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MessageEncoding))
		i--
		dAtA[i] = 0x28
	}
	if m.Utf8Validation != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Utf8Validation))
		i--
		dAtA[i] = 0x20
	}
	if m.RepeatedFieldEncoding != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.RepeatedFieldEncoding))
		i--
		dAtA[i] = 0x18
	}
	if m.EnumType != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.EnumType))
		i--
		dAtA[i] = 0x10
	}
	if m.FieldPresence != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.FieldPresence))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Edition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Edition))
		i--
		dAtA[i] = 0x18
	}
	if m.Features != nil {
		size, err := m.Features.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *FeatureSetDefaults) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureSetDefaults) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *FeatureSetDefaults) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.MaximumEdition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MaximumEdition))
		i--
		dAtA[i] = 0x28
	}
	if m.MinimumEdition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MinimumEdition))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Defaults) > 0 {
		for iNdEx := len(m.Defaults) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Defaults[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SourceCodeInfo_Location) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceCodeInfo_Location) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *SourceCodeInfo_Location) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.LeadingDetachedComments) > 0 {
		for iNdEx := len(m.LeadingDetachedComments) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LeadingDetachedComments[iNdEx])
			copy(dAtA[i:], m.LeadingDetachedComments[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.LeadingDetachedComments[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.TrailingComments != nil {
		i -= len(*m.TrailingComments)
		copy(dAtA[i:], *m.TrailingComments)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.TrailingComments)))
		i--
		dAtA[i] = 0x22
	}
	if m.LeadingComments != nil {
		i -= len(*m.LeadingComments)
		copy(dAtA[i:], *m.LeadingComments)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.LeadingComments)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Span) > 0 {
		var pksize2 int
		for _, num := range m.Span {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.Span {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		var pksize4 int
		for _, num := range m.Path {
			pksize4 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize4
		j3 := i
		for _, num1 := range m.Path {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA[j3] = uint8(num)
			j3++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceCodeInfo) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceCodeInfo) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *SourceCodeInfo) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Location) > 0 {
		for iNdEx := len(m.Location) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Location[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GeneratedCodeInfo_Annotation) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedCodeInfo_Annotation) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *GeneratedCodeInfo_Annotation) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Semantic != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Semantic))
		i--
		dAtA[i] = 0x28
	}
	if m.End != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x20
	}
	if m.Begin != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Begin))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceFile != nil {
		i -= len(*m.SourceFile)
		copy(dAtA[i:], *m.SourceFile)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.SourceFile)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		var pksize2 int
		for _, num := range m.Path {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.Path {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GeneratedCodeInfo) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedCodeInfo) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *GeneratedCodeInfo) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Annotation) > 0 {
		for iNdEx := len(m.Annotation) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Annotation[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FileDescriptorSet) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.File) > 0 {
		for _, e := range m.File {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *FileDescriptorProto) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Package != nil {
		l = len(*m.Package)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Dependency) > 0 {
		for _, s := range m.Dependency {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.MessageType) > 0 {
		for _, e := range m.MessageType {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.EnumType) > 0 {
		for _, e := range m.EnumType {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.Service) > 0 {
		for _, e := range m.Service {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.SourceCodeInfo != nil {
		l = m.SourceCodeInfo.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.PublicDependency) > 0 {
		for _, e := range m.PublicDependency {
			n += 1 + protobuf_go_lite.SizeOfVarint(uint64(e))
		}
	}
	if len(m.WeakDependency) > 0 {
		for _, e := range m.WeakDependency {
			n += 1 + protobuf_go_lite.SizeOfVarint(uint64(e))
		}
	}
	if m.Syntax != nil {
		l = len(*m.Syntax)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Edition != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Edition))
	}
	n += len(m.unknownFields)
	return n
}

func (m *DescriptorProto_ExtensionRange) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Start))
	}
	if m.End != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.End))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *DescriptorProto_ReservedRange) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Start))
	}
	if m.End != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.End))
	}
	n += len(m.unknownFields)
	return n
}

func (m *DescriptorProto) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Field) > 0 {
		for _, e := range m.Field {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.NestedType) > 0 {
		for _, e := range m.NestedType {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.EnumType) > 0 {
		for _, e := range m.EnumType {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.ExtensionRange) > 0 {
		for _, e := range m.ExtensionRange {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.OneofDecl) > 0 {
		for _, e := range m.OneofDecl {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.ReservedRange) > 0 {
		for _, e := range m.ReservedRange {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.ReservedName) > 0 {
		for _, s := range m.ReservedName {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExtensionRangeOptions_Declaration) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Number))
	}
	if m.FullName != nil {
		l = len(*m.FullName)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Reserved != nil {
		n += 2
	}
	if m.Repeated != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *ExtensionRangeOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Declaration) > 0 {
		for _, e := range m.Declaration {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Verification != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Verification))
	}
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *FieldDescriptorProto) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Extendee != nil {
		l = len(*m.Extendee)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Number != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Number))
	}
	if m.Label != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Label))
	}
	if m.Type != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Type))
	}
	if m.TypeName != nil {
		l = len(*m.TypeName)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.DefaultValue != nil {
		l = len(*m.DefaultValue)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.OneofIndex != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.OneofIndex))
	}
	if m.JsonName != nil {
		l = len(*m.JsonName)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Proto3Optional != nil {
		n += 3
	}
	n += len(m.unknownFields)
	return n
}

func (m *OneofDescriptorProto) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnumDescriptorProto_EnumReservedRange) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Start))
	}
	if m.End != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.End))
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnumDescriptorProto) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.ReservedRange) > 0 {
		for _, e := range m.ReservedRange {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.ReservedName) > 0 {
		for _, s := range m.ReservedName {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnumValueDescriptorProto) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Number != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Number))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ServiceDescriptorProto) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Method) > 0 {
		for _, e := range m.Method {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *MethodDescriptorProto) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.InputType != nil {
		l = len(*m.InputType)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.OutputType != nil {
		l = len(*m.OutputType)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.ClientStreaming != nil {
		n += 2
	}
	if m.ServerStreaming != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *FileOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JavaPackage != nil {
		l = len(*m.JavaPackage)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.JavaOuterClassname != nil {
		l = len(*m.JavaOuterClassname)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.OptimizeFor != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.OptimizeFor))
	}
	if m.JavaMultipleFiles != nil {
		n += 2
	}
	if m.GoPackage != nil {
		l = len(*m.GoPackage)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.CcGenericServices != nil {
		n += 3
	}
	if m.JavaGenericServices != nil {
		n += 3
	}
	if m.PyGenericServices != nil {
		n += 3
	}
	if m.JavaGenerateEqualsAndHash != nil {
		n += 3
	}
	if m.Deprecated != nil {
		n += 3
	}
	if m.JavaStringCheckUtf8 != nil {
		n += 3
	}
	if m.CcEnableArenas != nil {
		n += 3
	}
	if m.ObjcClassPrefix != nil {
		l = len(*m.ObjcClassPrefix)
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.CsharpNamespace != nil {
		l = len(*m.CsharpNamespace)
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.SwiftPrefix != nil {
		l = len(*m.SwiftPrefix)
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.PhpClassPrefix != nil {
		l = len(*m.PhpClassPrefix)
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.PhpNamespace != nil {
		l = len(*m.PhpNamespace)
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.PhpMetadataNamespace != nil {
		l = len(*m.PhpMetadataNamespace)
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.RubyPackage != nil {
		l = len(*m.RubyPackage)
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *MessageOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageSetWireFormat != nil {
		n += 2
	}
	if m.NoStandardDescriptorAccessor != nil {
		n += 2
	}
	if m.Deprecated != nil {
		n += 2
	}
	if m.MapEntry != nil {
		n += 2
	}
	if m.DeprecatedLegacyJsonFieldConflicts != nil {
		n += 2
	}
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *FieldOptions_EditionDefault) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Edition != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Edition))
	}
	n += len(m.unknownFields)
	return n
}

func (m *FieldOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ctype != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Ctype))
	}
	if m.Packed != nil {
		n += 2
	}
	if m.Deprecated != nil {
		n += 2
	}
	if m.Lazy != nil {
		n += 2
	}
	if m.Jstype != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Jstype))
	}
	if m.Weak != nil {
		n += 2
	}
	if m.UnverifiedLazy != nil {
		n += 2
	}
	if m.DebugRedact != nil {
		n += 3
	}
	if m.Retention != nil {
		n += 2 + protobuf_go_lite.SizeOfVarint(uint64(*m.Retention))
	}
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			n += 2 + protobuf_go_lite.SizeOfVarint(uint64(e))
		}
	}
	if len(m.EditionDefaults) > 0 {
		for _, e := range m.EditionDefaults {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *OneofOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnumOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAlias != nil {
		n += 2
	}
	if m.Deprecated != nil {
		n += 2
	}
	if m.DeprecatedLegacyJsonFieldConflicts != nil {
		n += 2
	}
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnumValueOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deprecated != nil {
		n += 2
	}
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.DebugRedact != nil {
		n += 2
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ServiceOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deprecated != nil {
		n += 3
	}
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *MethodOptions) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deprecated != nil {
		n += 3
	}
	if m.IdempotencyLevel != nil {
		n += 2 + protobuf_go_lite.SizeOfVarint(uint64(*m.IdempotencyLevel))
	}
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *UninterpretedOption_NamePart) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NamePart != nil {
		l = len(*m.NamePart)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.IsExtension != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *UninterpretedOption) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Name) > 0 {
		for _, e := range m.Name {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.IdentifierValue != nil {
		l = len(*m.IdentifierValue)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.PositiveIntValue != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.PositiveIntValue))
	}
	if m.NegativeIntValue != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.NegativeIntValue))
	}
	if m.DoubleValue != nil {
		n += 9
	}
	if m.StringValue != nil {
		l = len(m.StringValue)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.AggregateValue != nil {
		l = len(*m.AggregateValue)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *FeatureSet) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FieldPresence != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.FieldPresence))
	}
	if m.EnumType != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.EnumType))
	}
	if m.RepeatedFieldEncoding != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.RepeatedFieldEncoding))
	}
	if m.Utf8Validation != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Utf8Validation))
	}
	if m.MessageEncoding != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.MessageEncoding))
	}
	if m.JsonFormat != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.JsonFormat))
	}
	n += len(m.unknownFields)
	return n
}

func (m *FeatureSetDefaults_FeatureSetEditionDefault) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Features != nil {
		l = m.Features.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Edition != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Edition))
	}
	n += len(m.unknownFields)
	return n
}

func (m *FeatureSetDefaults) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Defaults) > 0 {
		for _, e := range m.Defaults {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.MinimumEdition != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.MinimumEdition))
	}
	if m.MaximumEdition != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.MaximumEdition))
	}
	n += len(m.unknownFields)
	return n
}

func (m *SourceCodeInfo_Location) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Path) > 0 {
		l = 0
		for _, e := range m.Path {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if len(m.Span) > 0 {
		l = 0
		for _, e := range m.Span {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if m.LeadingComments != nil {
		l = len(*m.LeadingComments)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.TrailingComments != nil {
		l = len(*m.TrailingComments)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.LeadingDetachedComments) > 0 {
		for _, s := range m.LeadingDetachedComments {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *SourceCodeInfo) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Location) > 0 {
		for _, e := range m.Location {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *GeneratedCodeInfo_Annotation) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Path) > 0 {
		l = 0
		for _, e := range m.Path {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if m.SourceFile != nil {
		l = len(*m.SourceFile)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Begin != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Begin))
	}
	if m.End != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.End))
	}
	if m.Semantic != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Semantic))
	}
	n += len(m.unknownFields)
	return n
}

func (m *GeneratedCodeInfo) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Annotation) > 0 {
		for _, e := range m.Annotation {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (x Edition) MarshalProtoText() string {
	return x.String()
}
func (x *FileDescriptorSet) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("FileDescriptorSet { ")
	if len(x.File) > 0 {
		sb.WriteString(" file: [")
		for i, v := range x.File {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FileDescriptorSet) String() string {
	return x.MarshalProtoText()
}
func (x *FileDescriptorProto) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("FileDescriptorProto { ")
	if x.Name != nil {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if x.Package != nil {
		sb.WriteString(" package: ")
		sb.WriteString(strconv.Quote(*x.Package))
	}
	if len(x.Dependency) > 0 {
		sb.WriteString(" dependency: [")
		for i, v := range x.Dependency {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	if len(x.MessageType) > 0 {
		sb.WriteString(" message_type: [")
		for i, v := range x.MessageType {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.EnumType) > 0 {
		sb.WriteString(" enum_type: [")
		for i, v := range x.EnumType {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.Service) > 0 {
		sb.WriteString(" service: [")
		for i, v := range x.Service {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.Extension) > 0 {
		sb.WriteString(" extension: [")
		for i, v := range x.Extension {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	if x.SourceCodeInfo != nil {
		sb.WriteString(" source_code_info: ")
		sb.WriteString(x.SourceCodeInfo.MarshalProtoText())
	}
	if len(x.PublicDependency) > 0 {
		sb.WriteString(" public_dependency: [")
		for i, v := range x.PublicDependency {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.FormatInt(int64(v), 10))
		}
		sb.WriteString("]")
	}
	if len(x.WeakDependency) > 0 {
		sb.WriteString(" weak_dependency: [")
		for i, v := range x.WeakDependency {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.FormatInt(int64(v), 10))
		}
		sb.WriteString("]")
	}
	if x.Syntax != nil {
		sb.WriteString(" syntax: ")
		sb.WriteString(strconv.Quote(*x.Syntax))
	}
	if x.Edition != nil {
		sb.WriteString(" edition: ")
		sb.WriteString(x.Edition.String())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FileDescriptorProto) String() string {
	return x.MarshalProtoText()
}
func (x *DescriptorProto_ExtensionRange) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExtensionRange { ")
	if x.Start != nil {
		sb.WriteString(" start: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Start), 10))
	}
	if x.End != nil {
		sb.WriteString(" end: ")
		sb.WriteString(strconv.FormatInt(int64(*x.End), 10))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *DescriptorProto_ExtensionRange) String() string {
	return x.MarshalProtoText()
}
func (x *DescriptorProto_ReservedRange) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ReservedRange { ")
	if x.Start != nil {
		sb.WriteString(" start: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Start), 10))
	}
	if x.End != nil {
		sb.WriteString(" end: ")
		sb.WriteString(strconv.FormatInt(int64(*x.End), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *DescriptorProto_ReservedRange) String() string {
	return x.MarshalProtoText()
}
func (x *DescriptorProto) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("DescriptorProto { ")
	if x.Name != nil {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if len(x.Field) > 0 {
		sb.WriteString(" field: [")
		for i, v := range x.Field {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.NestedType) > 0 {
		sb.WriteString(" nested_type: [")
		for i, v := range x.NestedType {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.EnumType) > 0 {
		sb.WriteString(" enum_type: [")
		for i, v := range x.EnumType {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.ExtensionRange) > 0 {
		sb.WriteString(" extension_range: [")
		for i, v := range x.ExtensionRange {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.Extension) > 0 {
		sb.WriteString(" extension: [")
		for i, v := range x.Extension {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	if len(x.OneofDecl) > 0 {
		sb.WriteString(" oneof_decl: [")
		for i, v := range x.OneofDecl {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.ReservedRange) > 0 {
		sb.WriteString(" reserved_range: [")
		for i, v := range x.ReservedRange {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.ReservedName) > 0 {
		sb.WriteString(" reserved_name: [")
		for i, v := range x.ReservedName {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *DescriptorProto) String() string {
	return x.MarshalProtoText()
}
func (x ExtensionRangeOptions_VerificationState) MarshalProtoText() string {
	return x.String()
}
func (x *ExtensionRangeOptions_Declaration) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Declaration { ")
	if x.Number != nil {
		sb.WriteString(" number: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Number), 10))
	}
	if x.FullName != nil {
		sb.WriteString(" full_name: ")
		sb.WriteString(strconv.Quote(*x.FullName))
	}
	if x.Type != nil {
		sb.WriteString(" type: ")
		sb.WriteString(strconv.Quote(*x.Type))
	}
	if x.Reserved != nil {
		sb.WriteString(" reserved: ")
		sb.WriteString(strconv.FormatBool(*x.Reserved))
	}
	if x.Repeated != nil {
		sb.WriteString(" repeated: ")
		sb.WriteString(strconv.FormatBool(*x.Repeated))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExtensionRangeOptions_Declaration) String() string {
	return x.MarshalProtoText()
}
func (x *ExtensionRangeOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ExtensionRangeOptions { ")
	if len(x.Declaration) > 0 {
		sb.WriteString(" declaration: [")
		for i, v := range x.Declaration {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.Verification != nil {
		sb.WriteString(" verification: ")
		sb.WriteString(x.Verification.String())
	}
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ExtensionRangeOptions) String() string {
	return x.MarshalProtoText()
}
func (x FieldDescriptorProto_Type) MarshalProtoText() string {
	return x.String()
}
func (x FieldDescriptorProto_Label) MarshalProtoText() string {
	return x.String()
}
func (x *FieldDescriptorProto) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("FieldDescriptorProto { ")
	if x.Name != nil {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if x.Extendee != nil {
		sb.WriteString(" extendee: ")
		sb.WriteString(strconv.Quote(*x.Extendee))
	}
	if x.Number != nil {
		sb.WriteString(" number: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Number), 10))
	}
	if x.Label != nil {
		sb.WriteString(" label: ")
		sb.WriteString(x.Label.String())
	}
	if x.Type != nil {
		sb.WriteString(" type: ")
		sb.WriteString(x.Type.String())
	}
	if x.TypeName != nil {
		sb.WriteString(" type_name: ")
		sb.WriteString(strconv.Quote(*x.TypeName))
	}
	if x.DefaultValue != nil {
		sb.WriteString(" default_value: ")
		sb.WriteString(strconv.Quote(*x.DefaultValue))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	if x.OneofIndex != nil {
		sb.WriteString(" oneof_index: ")
		sb.WriteString(strconv.FormatInt(int64(*x.OneofIndex), 10))
	}
	if x.JsonName != nil {
		sb.WriteString(" json_name: ")
		sb.WriteString(strconv.Quote(*x.JsonName))
	}
	if x.Proto3Optional != nil {
		sb.WriteString(" proto3_optional: ")
		sb.WriteString(strconv.FormatBool(*x.Proto3Optional))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FieldDescriptorProto) String() string {
	return x.MarshalProtoText()
}
func (x *OneofDescriptorProto) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("OneofDescriptorProto { ")
	if x.Name != nil {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *OneofDescriptorProto) String() string {
	return x.MarshalProtoText()
}
func (x *EnumDescriptorProto_EnumReservedRange) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnumReservedRange { ")
	if x.Start != nil {
		sb.WriteString(" start: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Start), 10))
	}
	if x.End != nil {
		sb.WriteString(" end: ")
		sb.WriteString(strconv.FormatInt(int64(*x.End), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *EnumDescriptorProto_EnumReservedRange) String() string {
	return x.MarshalProtoText()
}
func (x *EnumDescriptorProto) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnumDescriptorProto { ")
	if x.Name != nil {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if len(x.Value) > 0 {
		sb.WriteString(" value: [")
		for i, v := range x.Value {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	if len(x.ReservedRange) > 0 {
		sb.WriteString(" reserved_range: [")
		for i, v := range x.ReservedRange {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.ReservedName) > 0 {
		sb.WriteString(" reserved_name: [")
		for i, v := range x.ReservedName {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *EnumDescriptorProto) String() string {
	return x.MarshalProtoText()
}
func (x *EnumValueDescriptorProto) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnumValueDescriptorProto { ")
	if x.Name != nil {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if x.Number != nil {
		sb.WriteString(" number: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Number), 10))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *EnumValueDescriptorProto) String() string {
	return x.MarshalProtoText()
}
func (x *ServiceDescriptorProto) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ServiceDescriptorProto { ")
	if x.Name != nil {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if len(x.Method) > 0 {
		sb.WriteString(" method: [")
		for i, v := range x.Method {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ServiceDescriptorProto) String() string {
	return x.MarshalProtoText()
}
func (x *MethodDescriptorProto) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("MethodDescriptorProto { ")
	if x.Name != nil {
		sb.WriteString(" name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if x.InputType != nil {
		sb.WriteString(" input_type: ")
		sb.WriteString(strconv.Quote(*x.InputType))
	}
	if x.OutputType != nil {
		sb.WriteString(" output_type: ")
		sb.WriteString(strconv.Quote(*x.OutputType))
	}
	if x.Options != nil {
		sb.WriteString(" options: ")
		sb.WriteString(x.Options.MarshalProtoText())
	}
	if x.ClientStreaming != nil {
		sb.WriteString(" client_streaming: ")
		sb.WriteString(strconv.FormatBool(*x.ClientStreaming))
	}
	if x.ServerStreaming != nil {
		sb.WriteString(" server_streaming: ")
		sb.WriteString(strconv.FormatBool(*x.ServerStreaming))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *MethodDescriptorProto) String() string {
	return x.MarshalProtoText()
}
func (x FileOptions_OptimizeMode) MarshalProtoText() string {
	return x.String()
}
func (x *FileOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("FileOptions { ")
	if x.JavaPackage != nil {
		sb.WriteString(" java_package: ")
		sb.WriteString(strconv.Quote(*x.JavaPackage))
	}
	if x.JavaOuterClassname != nil {
		sb.WriteString(" java_outer_classname: ")
		sb.WriteString(strconv.Quote(*x.JavaOuterClassname))
	}
	if x.OptimizeFor != nil {
		sb.WriteString(" optimize_for: ")
		sb.WriteString(x.OptimizeFor.String())
	}
	if x.JavaMultipleFiles != nil {
		sb.WriteString(" java_multiple_files: ")
		sb.WriteString(strconv.FormatBool(*x.JavaMultipleFiles))
	}
	if x.GoPackage != nil {
		sb.WriteString(" go_package: ")
		sb.WriteString(strconv.Quote(*x.GoPackage))
	}
	if x.CcGenericServices != nil {
		sb.WriteString(" cc_generic_services: ")
		sb.WriteString(strconv.FormatBool(*x.CcGenericServices))
	}
	if x.JavaGenericServices != nil {
		sb.WriteString(" java_generic_services: ")
		sb.WriteString(strconv.FormatBool(*x.JavaGenericServices))
	}
	if x.PyGenericServices != nil {
		sb.WriteString(" py_generic_services: ")
		sb.WriteString(strconv.FormatBool(*x.PyGenericServices))
	}
	if x.JavaGenerateEqualsAndHash != nil {
		sb.WriteString(" java_generate_equals_and_hash: ")
		sb.WriteString(strconv.FormatBool(*x.JavaGenerateEqualsAndHash))
	}
	if x.Deprecated != nil {
		sb.WriteString(" deprecated: ")
		sb.WriteString(strconv.FormatBool(*x.Deprecated))
	}
	if x.JavaStringCheckUtf8 != nil {
		sb.WriteString(" java_string_check_utf8: ")
		sb.WriteString(strconv.FormatBool(*x.JavaStringCheckUtf8))
	}
	if x.CcEnableArenas != nil {
		sb.WriteString(" cc_enable_arenas: ")
		sb.WriteString(strconv.FormatBool(*x.CcEnableArenas))
	}
	if x.ObjcClassPrefix != nil {
		sb.WriteString(" objc_class_prefix: ")
		sb.WriteString(strconv.Quote(*x.ObjcClassPrefix))
	}
	if x.CsharpNamespace != nil {
		sb.WriteString(" csharp_namespace: ")
		sb.WriteString(strconv.Quote(*x.CsharpNamespace))
	}
	if x.SwiftPrefix != nil {
		sb.WriteString(" swift_prefix: ")
		sb.WriteString(strconv.Quote(*x.SwiftPrefix))
	}
	if x.PhpClassPrefix != nil {
		sb.WriteString(" php_class_prefix: ")
		sb.WriteString(strconv.Quote(*x.PhpClassPrefix))
	}
	if x.PhpNamespace != nil {
		sb.WriteString(" php_namespace: ")
		sb.WriteString(strconv.Quote(*x.PhpNamespace))
	}
	if x.PhpMetadataNamespace != nil {
		sb.WriteString(" php_metadata_namespace: ")
		sb.WriteString(strconv.Quote(*x.PhpMetadataNamespace))
	}
	if x.RubyPackage != nil {
		sb.WriteString(" ruby_package: ")
		sb.WriteString(strconv.Quote(*x.RubyPackage))
	}
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FileOptions) String() string {
	return x.MarshalProtoText()
}
func (x *MessageOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("MessageOptions { ")
	if x.MessageSetWireFormat != nil {
		sb.WriteString(" message_set_wire_format: ")
		sb.WriteString(strconv.FormatBool(*x.MessageSetWireFormat))
	}
	if x.NoStandardDescriptorAccessor != nil {
		sb.WriteString(" no_standard_descriptor_accessor: ")
		sb.WriteString(strconv.FormatBool(*x.NoStandardDescriptorAccessor))
	}
	if x.Deprecated != nil {
		sb.WriteString(" deprecated: ")
		sb.WriteString(strconv.FormatBool(*x.Deprecated))
	}
	if x.MapEntry != nil {
		sb.WriteString(" map_entry: ")
		sb.WriteString(strconv.FormatBool(*x.MapEntry))
	}
	if x.DeprecatedLegacyJsonFieldConflicts != nil {
		sb.WriteString(" deprecated_legacy_json_field_conflicts: ")
		sb.WriteString(strconv.FormatBool(*x.DeprecatedLegacyJsonFieldConflicts))
	}
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *MessageOptions) String() string {
	return x.MarshalProtoText()
}
func (x FieldOptions_CType) MarshalProtoText() string {
	return x.String()
}
func (x FieldOptions_JSType) MarshalProtoText() string {
	return x.String()
}
func (x FieldOptions_OptionRetention) MarshalProtoText() string {
	return x.String()
}
func (x FieldOptions_OptionTargetType) MarshalProtoText() string {
	return x.String()
}
func (x *FieldOptions_EditionDefault) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EditionDefault { ")
	if x.Value != nil {
		sb.WriteString(" value: ")
		sb.WriteString(strconv.Quote(*x.Value))
	}
	if x.Edition != nil {
		sb.WriteString(" edition: ")
		sb.WriteString(x.Edition.String())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FieldOptions_EditionDefault) String() string {
	return x.MarshalProtoText()
}
func (x *FieldOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("FieldOptions { ")
	if x.Ctype != nil {
		sb.WriteString(" ctype: ")
		sb.WriteString(x.Ctype.String())
	}
	if x.Packed != nil {
		sb.WriteString(" packed: ")
		sb.WriteString(strconv.FormatBool(*x.Packed))
	}
	if x.Deprecated != nil {
		sb.WriteString(" deprecated: ")
		sb.WriteString(strconv.FormatBool(*x.Deprecated))
	}
	if x.Lazy != nil {
		sb.WriteString(" lazy: ")
		sb.WriteString(strconv.FormatBool(*x.Lazy))
	}
	if x.Jstype != nil {
		sb.WriteString(" jstype: ")
		sb.WriteString(x.Jstype.String())
	}
	if x.Weak != nil {
		sb.WriteString(" weak: ")
		sb.WriteString(strconv.FormatBool(*x.Weak))
	}
	if x.UnverifiedLazy != nil {
		sb.WriteString(" unverified_lazy: ")
		sb.WriteString(strconv.FormatBool(*x.UnverifiedLazy))
	}
	if x.DebugRedact != nil {
		sb.WriteString(" debug_redact: ")
		sb.WriteString(strconv.FormatBool(*x.DebugRedact))
	}
	if x.Retention != nil {
		sb.WriteString(" retention: ")
		sb.WriteString(x.Retention.String())
	}
	if len(x.Targets) > 0 {
		sb.WriteString(" targets: [")
		for i, v := range x.Targets {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(FieldOptions_OptionTargetType(v).String())
		}
		sb.WriteString("]")
	}
	if len(x.EditionDefaults) > 0 {
		sb.WriteString(" edition_defaults: [")
		for i, v := range x.EditionDefaults {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FieldOptions) String() string {
	return x.MarshalProtoText()
}
func (x *OneofOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("OneofOptions { ")
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *OneofOptions) String() string {
	return x.MarshalProtoText()
}
func (x *EnumOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnumOptions { ")
	if x.AllowAlias != nil {
		sb.WriteString(" allow_alias: ")
		sb.WriteString(strconv.FormatBool(*x.AllowAlias))
	}
	if x.Deprecated != nil {
		sb.WriteString(" deprecated: ")
		sb.WriteString(strconv.FormatBool(*x.Deprecated))
	}
	if x.DeprecatedLegacyJsonFieldConflicts != nil {
		sb.WriteString(" deprecated_legacy_json_field_conflicts: ")
		sb.WriteString(strconv.FormatBool(*x.DeprecatedLegacyJsonFieldConflicts))
	}
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *EnumOptions) String() string {
	return x.MarshalProtoText()
}
func (x *EnumValueOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnumValueOptions { ")
	if x.Deprecated != nil {
		sb.WriteString(" deprecated: ")
		sb.WriteString(strconv.FormatBool(*x.Deprecated))
	}
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if x.DebugRedact != nil {
		sb.WriteString(" debug_redact: ")
		sb.WriteString(strconv.FormatBool(*x.DebugRedact))
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *EnumValueOptions) String() string {
	return x.MarshalProtoText()
}
func (x *ServiceOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("ServiceOptions { ")
	if x.Deprecated != nil {
		sb.WriteString(" deprecated: ")
		sb.WriteString(strconv.FormatBool(*x.Deprecated))
	}
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *ServiceOptions) String() string {
	return x.MarshalProtoText()
}
func (x MethodOptions_IdempotencyLevel) MarshalProtoText() string {
	return x.String()
}
func (x *MethodOptions) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("MethodOptions { ")
	if x.Deprecated != nil {
		sb.WriteString(" deprecated: ")
		sb.WriteString(strconv.FormatBool(*x.Deprecated))
	}
	if x.IdempotencyLevel != nil {
		sb.WriteString(" idempotency_level: ")
		sb.WriteString(x.IdempotencyLevel.String())
	}
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if len(x.UninterpretedOption) > 0 {
		sb.WriteString(" uninterpreted_option: [")
		for i, v := range x.UninterpretedOption {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *MethodOptions) String() string {
	return x.MarshalProtoText()
}
func (x *UninterpretedOption_NamePart) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("NamePart { ")
	if x.NamePart != nil {
		sb.WriteString(" name_part: ")
		sb.WriteString(strconv.Quote(*x.NamePart))
	}
	if x.IsExtension != nil {
		sb.WriteString(" is_extension: ")
		sb.WriteString(strconv.FormatBool(*x.IsExtension))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *UninterpretedOption_NamePart) String() string {
	return x.MarshalProtoText()
}
func (x *UninterpretedOption) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("UninterpretedOption { ")
	if len(x.Name) > 0 {
		sb.WriteString(" name: [")
		for i, v := range x.Name {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.IdentifierValue != nil {
		sb.WriteString(" identifier_value: ")
		sb.WriteString(strconv.Quote(*x.IdentifierValue))
	}
	if x.PositiveIntValue != nil {
		sb.WriteString(" positive_int_value: ")
		sb.WriteString(strconv.FormatUint(uint64(*x.PositiveIntValue), 10))
	}
	if x.NegativeIntValue != nil {
		sb.WriteString(" negative_int_value: ")
		sb.WriteString(strconv.FormatInt(int64(*x.NegativeIntValue), 10))
	}
	if x.DoubleValue != nil {
		sb.WriteString(" double_value: ")
		sb.WriteString(strconv.FormatFloat(*x.DoubleValue, 'g', -1, 64))
	}
	if len(x.StringValue) > 0 {
		sb.WriteString(" string_value: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.StringValue))
		sb.WriteString("\"")
	}
	if x.AggregateValue != nil {
		sb.WriteString(" aggregate_value: ")
		sb.WriteString(strconv.Quote(*x.AggregateValue))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *UninterpretedOption) String() string {
	return x.MarshalProtoText()
}
func (x FeatureSet_FieldPresence) MarshalProtoText() string {
	return x.String()
}
func (x FeatureSet_EnumType) MarshalProtoText() string {
	return x.String()
}
func (x FeatureSet_RepeatedFieldEncoding) MarshalProtoText() string {
	return x.String()
}
func (x FeatureSet_Utf8Validation) MarshalProtoText() string {
	return x.String()
}
func (x FeatureSet_MessageEncoding) MarshalProtoText() string {
	return x.String()
}
func (x FeatureSet_JsonFormat) MarshalProtoText() string {
	return x.String()
}
func (x *FeatureSet) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("FeatureSet { ")
	if x.FieldPresence != nil {
		sb.WriteString(" field_presence: ")
		sb.WriteString(x.FieldPresence.String())
	}
	if x.EnumType != nil {
		sb.WriteString(" enum_type: ")
		sb.WriteString(x.EnumType.String())
	}
	if x.RepeatedFieldEncoding != nil {
		sb.WriteString(" repeated_field_encoding: ")
		sb.WriteString(x.RepeatedFieldEncoding.String())
	}
	if x.Utf8Validation != nil {
		sb.WriteString(" utf8_validation: ")
		sb.WriteString(x.Utf8Validation.String())
	}
	if x.MessageEncoding != nil {
		sb.WriteString(" message_encoding: ")
		sb.WriteString(x.MessageEncoding.String())
	}
	if x.JsonFormat != nil {
		sb.WriteString(" json_format: ")
		sb.WriteString(x.JsonFormat.String())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FeatureSet) String() string {
	return x.MarshalProtoText()
}
func (x *FeatureSetDefaults_FeatureSetEditionDefault) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("FeatureSetEditionDefault { ")
	if x.Features != nil {
		sb.WriteString(" features: ")
		sb.WriteString(x.Features.MarshalProtoText())
	}
	if x.Edition != nil {
		sb.WriteString(" edition: ")
		sb.WriteString(x.Edition.String())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FeatureSetDefaults_FeatureSetEditionDefault) String() string {
	return x.MarshalProtoText()
}
func (x *FeatureSetDefaults) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("FeatureSetDefaults { ")
	if len(x.Defaults) > 0 {
		sb.WriteString(" defaults: [")
		for i, v := range x.Defaults {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.MinimumEdition != nil {
		sb.WriteString(" minimum_edition: ")
		sb.WriteString(x.MinimumEdition.String())
	}
	if x.MaximumEdition != nil {
		sb.WriteString(" maximum_edition: ")
		sb.WriteString(x.MaximumEdition.String())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *FeatureSetDefaults) String() string {
	return x.MarshalProtoText()
}
func (x *SourceCodeInfo_Location) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Location { ")
	if len(x.Path) > 0 {
		sb.WriteString(" path: [")
		for i, v := range x.Path {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.FormatInt(int64(v), 10))
		}
		sb.WriteString("]")
	}
	if len(x.Span) > 0 {
		sb.WriteString(" span: [")
		for i, v := range x.Span {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.FormatInt(int64(v), 10))
		}
		sb.WriteString("]")
	}
	if x.LeadingComments != nil {
		sb.WriteString(" leading_comments: ")
		sb.WriteString(strconv.Quote(*x.LeadingComments))
	}
	if x.TrailingComments != nil {
		sb.WriteString(" trailing_comments: ")
		sb.WriteString(strconv.Quote(*x.TrailingComments))
	}
	if len(x.LeadingDetachedComments) > 0 {
		sb.WriteString(" leading_detached_comments: [")
		for i, v := range x.LeadingDetachedComments {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SourceCodeInfo_Location) String() string {
	return x.MarshalProtoText()
}
func (x *SourceCodeInfo) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("SourceCodeInfo { ")
	if len(x.Location) > 0 {
		sb.WriteString(" location: [")
		for i, v := range x.Location {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *SourceCodeInfo) String() string {
	return x.MarshalProtoText()
}
func (x GeneratedCodeInfo_Annotation_Semantic) MarshalProtoText() string {
	return x.String()
}
func (x *GeneratedCodeInfo_Annotation) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Annotation { ")
	if len(x.Path) > 0 {
		sb.WriteString(" path: [")
		for i, v := range x.Path {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.FormatInt(int64(v), 10))
		}
		sb.WriteString("]")
	}
	if x.SourceFile != nil {
		sb.WriteString(" source_file: ")
		sb.WriteString(strconv.Quote(*x.SourceFile))
	}
	if x.Begin != nil {
		sb.WriteString(" begin: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Begin), 10))
	}
	if x.End != nil {
		sb.WriteString(" end: ")
		sb.WriteString(strconv.FormatInt(int64(*x.End), 10))
	}
	if x.Semantic != nil {
		sb.WriteString(" semantic: ")
		sb.WriteString(x.Semantic.String())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *GeneratedCodeInfo_Annotation) String() string {
	return x.MarshalProtoText()
}
func (x *GeneratedCodeInfo) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("GeneratedCodeInfo { ")
	if len(x.Annotation) > 0 {
		sb.WriteString(" annotation: [")
		for i, v := range x.Annotation {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *GeneratedCodeInfo) String() string {
	return x.MarshalProtoText()
}
func (m *FileDescriptorSet) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FileDescriptorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FileDescriptorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File, &FileDescriptorProto{})
			if err := m.File[len(m.File)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDescriptorProto) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FileDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FileDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Package = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Dependency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependency = append(m.Dependency, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageType = append(m.MessageType, &DescriptorProto{})
			if err := m.MessageType[len(m.MessageType)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnumType = append(m.EnumType, &EnumDescriptorProto{})
			if err := m.EnumType[len(m.EnumType)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = append(m.Service, &ServiceDescriptorProto{})
			if err := m.Service[len(m.Service)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &FieldDescriptorProto{})
			if err := m.Extension[len(m.Extension)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &FileOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field SourceCodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceCodeInfo == nil {
				m.SourceCodeInfo = &SourceCodeInfo{}
			}
			if err := m.SourceCodeInfo.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PublicDependency = append(m.PublicDependency, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PublicDependency) == 0 {
					m.PublicDependency = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PublicDependency = append(m.PublicDependency, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field PublicDependency", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WeakDependency = append(m.WeakDependency, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WeakDependency) == 0 {
					m.WeakDependency = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WeakDependency = append(m.WeakDependency, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field WeakDependency", wireType)
			}
		case 12:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Syntax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Syntax = &s
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Edition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edition = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorProto_ExtensionRange) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: DescriptorProto_ExtensionRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: DescriptorProto_ExtensionRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &ExtensionRangeOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorProto_ReservedRange) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: DescriptorProto_ReservedRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: DescriptorProto_ReservedRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorProto) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: DescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: DescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = append(m.Field, &FieldDescriptorProto{})
			if err := m.Field[len(m.Field)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field NestedType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NestedType = append(m.NestedType, &DescriptorProto{})
			if err := m.NestedType[len(m.NestedType)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnumType = append(m.EnumType, &EnumDescriptorProto{})
			if err := m.EnumType[len(m.EnumType)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ExtensionRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtensionRange = append(m.ExtensionRange, &DescriptorProto_ExtensionRange{})
			if err := m.ExtensionRange[len(m.ExtensionRange)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &FieldDescriptorProto{})
			if err := m.Extension[len(m.Extension)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &MessageOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field OneofDecl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneofDecl = append(m.OneofDecl, &OneofDescriptorProto{})
			if err := m.OneofDecl[len(m.OneofDecl)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ReservedRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedRange = append(m.ReservedRange, &DescriptorProto_ReservedRange{})
			if err := m.ReservedRange[len(m.ReservedRange)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ReservedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedName = append(m.ReservedName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtensionRangeOptions_Declaration) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: ExtensionRangeOptions_Declaration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: ExtensionRangeOptions_Declaration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field FullName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FullName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reserved = &b
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Repeated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Repeated = &b
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtensionRangeOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: ExtensionRangeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: ExtensionRangeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Declaration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Declaration = append(m.Declaration, &ExtensionRangeOptions_Declaration{})
			if err := m.Declaration[len(m.Declaration)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Verification", wireType)
			}
			var v ExtensionRangeOptions_VerificationState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ExtensionRangeOptions_VerificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verification = &v
		case 50:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldDescriptorProto) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FieldDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FieldDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Extendee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Extendee = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var v FieldDescriptorProto_Label
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldDescriptorProto_Label(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Label = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v FieldDescriptorProto_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldDescriptorProto_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 6:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TypeName = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultValue = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &FieldOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field OneofIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofIndex = &v
		case 10:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field JsonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JsonName = &s
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Proto3Optional", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Proto3Optional = &b
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneofDescriptorProto) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: OneofDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: OneofDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &OneofOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumDescriptorProto_EnumReservedRange) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumDescriptorProto_EnumReservedRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumDescriptorProto_EnumReservedRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumDescriptorProto) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &EnumValueDescriptorProto{})
			if err := m.Value[len(m.Value)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &EnumOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ReservedRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedRange = append(m.ReservedRange, &EnumDescriptorProto_EnumReservedRange{})
			if err := m.ReservedRange[len(m.ReservedRange)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ReservedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedName = append(m.ReservedName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumValueDescriptorProto) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumValueDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumValueDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &EnumValueOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDescriptorProto) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: ServiceDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: ServiceDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = append(m.Method, &MethodDescriptorProto{})
			if err := m.Method[len(m.Method)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &ServiceOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MethodDescriptorProto) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: MethodDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: MethodDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field InputType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InputType = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OutputType = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &MethodOptions{}
			}
			if err := m.Options.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field ClientStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ClientStreaming = &b
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field ServerStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ServerStreaming = &b
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FileOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FileOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JavaPackage = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaOuterClassname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JavaOuterClassname = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field OptimizeFor", wireType)
			}
			var v FileOptions_OptimizeMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FileOptions_OptimizeMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizeFor = &v
		case 10:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaMultipleFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaMultipleFiles = &b
		case 11:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field GoPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GoPackage = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field CcGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CcGenericServices = &b
		case 17:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaGenericServices = &b
		case 18:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field PyGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PyGenericServices = &b
		case 20:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaGenerateEqualsAndHash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaGenerateEqualsAndHash = &b
		case 23:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 27:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaStringCheckUtf8", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaStringCheckUtf8 = &b
		case 31:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field CcEnableArenas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CcEnableArenas = &b
		case 36:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ObjcClassPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ObjcClassPrefix = &s
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field CsharpNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CsharpNamespace = &s
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field SwiftPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SwiftPrefix = &s
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field PhpClassPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PhpClassPrefix = &s
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field PhpNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PhpNamespace = &s
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field PhpMetadataNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PhpMetadataNamespace = &s
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field RubyPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RubyPackage = &s
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: MessageOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: MessageOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MessageSetWireFormat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MessageSetWireFormat = &b
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field NoStandardDescriptorAccessor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NoStandardDescriptorAccessor = &b
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 7:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MapEntry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MapEntry = &b
		case 11:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field DeprecatedLegacyJsonFieldConflicts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DeprecatedLegacyJsonFieldConflicts = &b
		case 12:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldOptions_EditionDefault) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FieldOptions_EditionDefault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FieldOptions_EditionDefault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Edition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edition = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FieldOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FieldOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Ctype", wireType)
			}
			var v FieldOptions_CType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldOptions_CType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ctype = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Packed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Packed = &b
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Lazy = &b
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Jstype", wireType)
			}
			var v FieldOptions_JSType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldOptions_JSType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jstype = &v
		case 10:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Weak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Weak = &b
		case 15:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field UnverifiedLazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UnverifiedLazy = &b
		case 16:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field DebugRedact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DebugRedact = &b
		case 17:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			var v FieldOptions_OptionRetention
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldOptions_OptionRetention(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retention = &v
		case 19:
			if wireType == 0 {
				var v FieldOptions_OptionTargetType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FieldOptions_OptionTargetType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Targets = append(m.Targets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Targets) == 0 {
					m.Targets = make([]FieldOptions_OptionTargetType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FieldOptions_OptionTargetType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FieldOptions_OptionTargetType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Targets = append(m.Targets, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
		case 20:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field EditionDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditionDefaults = append(m.EditionDefaults, &FieldOptions_EditionDefault{})
			if err := m.EditionDefaults[len(m.EditionDefaults)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneofOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: OneofOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: OneofOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field AllowAlias", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AllowAlias = &b
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field DeprecatedLegacyJsonFieldConflicts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DeprecatedLegacyJsonFieldConflicts = &b
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumValueOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumValueOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumValueOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field DebugRedact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DebugRedact = &b
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: ServiceOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: ServiceOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 33:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 34:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MethodOptions) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: MethodOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: MethodOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 33:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 34:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field IdempotencyLevel", wireType)
			}
			var v MethodOptions_IdempotencyLevel
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MethodOptions_IdempotencyLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IdempotencyLevel = &v
		case 35:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UninterpretedOption_NamePart) UnmarshalVT(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: UninterpretedOption_NamePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: UninterpretedOption_NamePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field NamePart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NamePart = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field IsExtension", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsExtension = &b
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return errors.Errorf("proto: required field name_part not set")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return errors.Errorf("proto: required field is_extension not set")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UninterpretedOption) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: UninterpretedOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: UninterpretedOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name, &UninterpretedOption_NamePart{})
			if err := m.Name[len(m.Name)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field IdentifierValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IdentifierValue = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field PositiveIntValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PositiveIntValue = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field NegativeIntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NegativeIntValue = &v
		case 6:
			if wireType != 1 {
				return errors.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringValue = append(m.StringValue[:0], dAtA[iNdEx:postIndex]...)
			if m.StringValue == nil {
				m.StringValue = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field AggregateValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AggregateValue = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureSet) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FeatureSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FeatureSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field FieldPresence", wireType)
			}
			var v FeatureSet_FieldPresence
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_FieldPresence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FieldPresence = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var v FeatureSet_EnumType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_EnumType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnumType = &v
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field RepeatedFieldEncoding", wireType)
			}
			var v FeatureSet_RepeatedFieldEncoding
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_RepeatedFieldEncoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RepeatedFieldEncoding = &v
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Utf8Validation", wireType)
			}
			var v FeatureSet_Utf8Validation
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_Utf8Validation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Utf8Validation = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MessageEncoding", wireType)
			}
			var v FeatureSet_MessageEncoding
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_MessageEncoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MessageEncoding = &v
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JsonFormat", wireType)
			}
			var v FeatureSet_JsonFormat
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_JsonFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JsonFormat = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureSetDefaults_FeatureSetEditionDefault) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FeatureSetDefaults_FeatureSetEditionDefault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FeatureSetDefaults_FeatureSetEditionDefault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Edition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edition = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureSetDefaults) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FeatureSetDefaults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FeatureSetDefaults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Defaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defaults = append(m.Defaults, &FeatureSetDefaults_FeatureSetEditionDefault{})
			if err := m.Defaults[len(m.Defaults)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MinimumEdition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinimumEdition = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MaximumEdition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaximumEdition = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceCodeInfo_Location) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: SourceCodeInfo_Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: SourceCodeInfo_Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Path = append(m.Path, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Path) == 0 {
					m.Path = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Path = append(m.Path, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Span = append(m.Span, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Span) == 0 {
					m.Span = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Span = append(m.Span, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field LeadingComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LeadingComments = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field TrailingComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TrailingComments = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field LeadingDetachedComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeadingDetachedComments = append(m.LeadingDetachedComments, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceCodeInfo) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: SourceCodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: SourceCodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = append(m.Location, &SourceCodeInfo_Location{})
			if err := m.Location[len(m.Location)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedCodeInfo_Annotation) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: GeneratedCodeInfo_Annotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: GeneratedCodeInfo_Annotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Path = append(m.Path, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Path) == 0 {
					m.Path = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Path = append(m.Path, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field SourceFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SourceFile = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Begin = &v
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Semantic", wireType)
			}
			var v GeneratedCodeInfo_Annotation_Semantic
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= GeneratedCodeInfo_Annotation_Semantic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Semantic = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedCodeInfo) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: GeneratedCodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: GeneratedCodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotation = append(m.Annotation, &GeneratedCodeInfo_Annotation{})
			if err := m.Annotation[len(m.Annotation)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDescriptorSet) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FileDescriptorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FileDescriptorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File, &FileDescriptorProto{})
			if err := m.File[len(m.File)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDescriptorProto) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FileDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FileDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Package = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Dependency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			m.Dependency = append(m.Dependency, stringValue)
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageType = append(m.MessageType, &DescriptorProto{})
			if err := m.MessageType[len(m.MessageType)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnumType = append(m.EnumType, &EnumDescriptorProto{})
			if err := m.EnumType[len(m.EnumType)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = append(m.Service, &ServiceDescriptorProto{})
			if err := m.Service[len(m.Service)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &FieldDescriptorProto{})
			if err := m.Extension[len(m.Extension)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &FileOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field SourceCodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceCodeInfo == nil {
				m.SourceCodeInfo = &SourceCodeInfo{}
			}
			if err := m.SourceCodeInfo.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PublicDependency = append(m.PublicDependency, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PublicDependency) == 0 {
					m.PublicDependency = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PublicDependency = append(m.PublicDependency, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field PublicDependency", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WeakDependency = append(m.WeakDependency, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WeakDependency) == 0 {
					m.WeakDependency = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WeakDependency = append(m.WeakDependency, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field WeakDependency", wireType)
			}
		case 12:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Syntax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Syntax = &s
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Edition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edition = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorProto_ExtensionRange) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: DescriptorProto_ExtensionRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: DescriptorProto_ExtensionRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &ExtensionRangeOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorProto_ReservedRange) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: DescriptorProto_ReservedRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: DescriptorProto_ReservedRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorProto) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: DescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: DescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = append(m.Field, &FieldDescriptorProto{})
			if err := m.Field[len(m.Field)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field NestedType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NestedType = append(m.NestedType, &DescriptorProto{})
			if err := m.NestedType[len(m.NestedType)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnumType = append(m.EnumType, &EnumDescriptorProto{})
			if err := m.EnumType[len(m.EnumType)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ExtensionRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtensionRange = append(m.ExtensionRange, &DescriptorProto_ExtensionRange{})
			if err := m.ExtensionRange[len(m.ExtensionRange)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &FieldDescriptorProto{})
			if err := m.Extension[len(m.Extension)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &MessageOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field OneofDecl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneofDecl = append(m.OneofDecl, &OneofDescriptorProto{})
			if err := m.OneofDecl[len(m.OneofDecl)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ReservedRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedRange = append(m.ReservedRange, &DescriptorProto_ReservedRange{})
			if err := m.ReservedRange[len(m.ReservedRange)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ReservedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			m.ReservedName = append(m.ReservedName, stringValue)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtensionRangeOptions_Declaration) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: ExtensionRangeOptions_Declaration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: ExtensionRangeOptions_Declaration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field FullName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.FullName = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Type = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reserved = &b
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Repeated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Repeated = &b
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtensionRangeOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: ExtensionRangeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: ExtensionRangeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Declaration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Declaration = append(m.Declaration, &ExtensionRangeOptions_Declaration{})
			if err := m.Declaration[len(m.Declaration)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Verification", wireType)
			}
			var v ExtensionRangeOptions_VerificationState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ExtensionRangeOptions_VerificationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verification = &v
		case 50:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldDescriptorProto) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FieldDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FieldDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Extendee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Extendee = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var v FieldDescriptorProto_Label
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldDescriptorProto_Label(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Label = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v FieldDescriptorProto_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldDescriptorProto_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 6:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.TypeName = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.DefaultValue = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &FieldOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field OneofIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofIndex = &v
		case 10:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field JsonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.JsonName = &s
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Proto3Optional", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Proto3Optional = &b
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneofDescriptorProto) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: OneofDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: OneofDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &OneofOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumDescriptorProto_EnumReservedRange) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumDescriptorProto_EnumReservedRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumDescriptorProto_EnumReservedRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumDescriptorProto) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &EnumValueDescriptorProto{})
			if err := m.Value[len(m.Value)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &EnumOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ReservedRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedRange = append(m.ReservedRange, &EnumDescriptorProto_EnumReservedRange{})
			if err := m.ReservedRange[len(m.ReservedRange)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ReservedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			m.ReservedName = append(m.ReservedName, stringValue)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumValueDescriptorProto) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumValueDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumValueDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &EnumValueOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDescriptorProto) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: ServiceDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: ServiceDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = append(m.Method, &MethodDescriptorProto{})
			if err := m.Method[len(m.Method)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &ServiceOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MethodDescriptorProto) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: MethodDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: MethodDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field InputType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.InputType = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.OutputType = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &MethodOptions{}
			}
			if err := m.Options.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field ClientStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ClientStreaming = &b
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field ServerStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ServerStreaming = &b
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FileOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FileOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.JavaPackage = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaOuterClassname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.JavaOuterClassname = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field OptimizeFor", wireType)
			}
			var v FileOptions_OptimizeMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FileOptions_OptimizeMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizeFor = &v
		case 10:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaMultipleFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaMultipleFiles = &b
		case 11:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field GoPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.GoPackage = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field CcGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CcGenericServices = &b
		case 17:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaGenericServices = &b
		case 18:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field PyGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PyGenericServices = &b
		case 20:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaGenerateEqualsAndHash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaGenerateEqualsAndHash = &b
		case 23:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 27:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JavaStringCheckUtf8", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaStringCheckUtf8 = &b
		case 31:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field CcEnableArenas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CcEnableArenas = &b
		case 36:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field ObjcClassPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.ObjcClassPrefix = &s
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field CsharpNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.CsharpNamespace = &s
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field SwiftPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.SwiftPrefix = &s
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field PhpClassPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.PhpClassPrefix = &s
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field PhpNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.PhpNamespace = &s
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field PhpMetadataNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.PhpMetadataNamespace = &s
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field RubyPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.RubyPackage = &s
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: MessageOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: MessageOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MessageSetWireFormat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MessageSetWireFormat = &b
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field NoStandardDescriptorAccessor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NoStandardDescriptorAccessor = &b
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 7:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MapEntry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MapEntry = &b
		case 11:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field DeprecatedLegacyJsonFieldConflicts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DeprecatedLegacyJsonFieldConflicts = &b
		case 12:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldOptions_EditionDefault) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FieldOptions_EditionDefault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FieldOptions_EditionDefault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Value = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Edition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edition = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FieldOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FieldOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Ctype", wireType)
			}
			var v FieldOptions_CType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldOptions_CType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ctype = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Packed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Packed = &b
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Lazy = &b
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Jstype", wireType)
			}
			var v FieldOptions_JSType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldOptions_JSType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jstype = &v
		case 10:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Weak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Weak = &b
		case 15:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field UnverifiedLazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UnverifiedLazy = &b
		case 16:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field DebugRedact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DebugRedact = &b
		case 17:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Retention", wireType)
			}
			var v FieldOptions_OptionRetention
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FieldOptions_OptionRetention(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retention = &v
		case 19:
			if wireType == 0 {
				var v FieldOptions_OptionTargetType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FieldOptions_OptionTargetType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Targets = append(m.Targets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Targets) == 0 {
					m.Targets = make([]FieldOptions_OptionTargetType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FieldOptions_OptionTargetType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FieldOptions_OptionTargetType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Targets = append(m.Targets, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
		case 20:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field EditionDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditionDefaults = append(m.EditionDefaults, &FieldOptions_EditionDefault{})
			if err := m.EditionDefaults[len(m.EditionDefaults)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneofOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: OneofOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: OneofOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field AllowAlias", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AllowAlias = &b
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field DeprecatedLegacyJsonFieldConflicts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DeprecatedLegacyJsonFieldConflicts = &b
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumValueOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: EnumValueOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: EnumValueOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field DebugRedact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DebugRedact = &b
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: ServiceOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: ServiceOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 33:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 34:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MethodOptions) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: MethodOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: MethodOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 33:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 34:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field IdempotencyLevel", wireType)
			}
			var v MethodOptions_IdempotencyLevel
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MethodOptions_IdempotencyLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IdempotencyLevel = &v
		case 35:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &UninterpretedOption{})
			if err := m.UninterpretedOption[len(m.UninterpretedOption)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UninterpretedOption_NamePart) UnmarshalVTUnsafe(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: UninterpretedOption_NamePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: UninterpretedOption_NamePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field NamePart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.NamePart = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field IsExtension", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsExtension = &b
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return errors.Errorf("proto: required field name_part not set")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return errors.Errorf("proto: required field is_extension not set")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UninterpretedOption) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: UninterpretedOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: UninterpretedOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name, &UninterpretedOption_NamePart{})
			if err := m.Name[len(m.Name)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field IdentifierValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.IdentifierValue = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field PositiveIntValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PositiveIntValue = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field NegativeIntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NegativeIntValue = &v
		case 6:
			if wireType != 1 {
				return errors.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 7:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringValue = dAtA[iNdEx:postIndex]
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field AggregateValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.AggregateValue = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureSet) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FeatureSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FeatureSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field FieldPresence", wireType)
			}
			var v FeatureSet_FieldPresence
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_FieldPresence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FieldPresence = &v
		case 2:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var v FeatureSet_EnumType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_EnumType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnumType = &v
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field RepeatedFieldEncoding", wireType)
			}
			var v FeatureSet_RepeatedFieldEncoding
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_RepeatedFieldEncoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RepeatedFieldEncoding = &v
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Utf8Validation", wireType)
			}
			var v FeatureSet_Utf8Validation
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_Utf8Validation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Utf8Validation = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MessageEncoding", wireType)
			}
			var v FeatureSet_MessageEncoding
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_MessageEncoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MessageEncoding = &v
		case 6:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field JsonFormat", wireType)
			}
			var v FeatureSet_JsonFormat
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FeatureSet_JsonFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JsonFormat = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureSetDefaults_FeatureSetEditionDefault) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FeatureSetDefaults_FeatureSetEditionDefault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FeatureSetDefaults_FeatureSetEditionDefault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &FeatureSet{}
			}
			if err := m.Features.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Edition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edition = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureSetDefaults) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: FeatureSetDefaults: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: FeatureSetDefaults: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Defaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defaults = append(m.Defaults, &FeatureSetDefaults_FeatureSetEditionDefault{})
			if err := m.Defaults[len(m.Defaults)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MinimumEdition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinimumEdition = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field MaximumEdition", wireType)
			}
			var v Edition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Edition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaximumEdition = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceCodeInfo_Location) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: SourceCodeInfo_Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: SourceCodeInfo_Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Path = append(m.Path, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Path) == 0 {
					m.Path = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Path = append(m.Path, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Span = append(m.Span, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Span) == 0 {
					m.Span = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Span = append(m.Span, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
		case 3:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field LeadingComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.LeadingComments = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field TrailingComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.TrailingComments = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field LeadingDetachedComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			m.LeadingDetachedComments = append(m.LeadingDetachedComments, stringValue)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceCodeInfo) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: SourceCodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: SourceCodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = append(m.Location, &SourceCodeInfo_Location{})
			if err := m.Location[len(m.Location)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedCodeInfo_Annotation) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: GeneratedCodeInfo_Annotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: GeneratedCodeInfo_Annotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Path = append(m.Path, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Path) == 0 {
					m.Path = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Path = append(m.Path, v)
				}
			} else {
				return errors.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
		case 2:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field SourceFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.SourceFile = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Begin = &v
		case 4:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		case 5:
			if wireType != 0 {
				return errors.Errorf("proto: wrong wireType = %d for field Semantic", wireType)
			}
			var v GeneratedCodeInfo_Annotation_Semantic
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= GeneratedCodeInfo_Annotation_Semantic(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Semantic = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedCodeInfo) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return errors.Errorf("proto: GeneratedCodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return errors.Errorf("proto: GeneratedCodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return errors.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotation = append(m.Annotation, &GeneratedCodeInfo_Annotation{})
			if err := m.Annotation[len(m.Annotation)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
