// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.1.2
// source: github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto

package descriptorpb

import (
	strconv "strconv"
)

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// The messages in this file describe the definitions found in .proto files.
// A valid .proto file can be translated directly to a FileDescriptorProto
// without any other information (e.g. without reading its imports).

// The full set of known editions.
type Edition int32

const (
	// A placeholder for an unknown edition value.
	Edition_EDITION_UNKNOWN Edition = 0
	// Legacy syntax "editions".  These pre-date editions, but behave much like
	// distinct editions.  These can't be used to specify the edition of proto
	// files, but feature definitions must supply proto2/proto3 defaults for
	// backwards compatibility.
	Edition_EDITION_PROTO2 Edition = 998
	Edition_EDITION_PROTO3 Edition = 999
	// Editions that have been released.  The specific values are arbitrary and
	// should not be depended on, but they will always be time-ordered for easy
	// comparison.
	Edition_EDITION_2023 Edition = 1000
	Edition_EDITION_2024 Edition = 1001
	// Placeholder editions for testing feature resolution.  These should not be
	// used or relyed on outside of tests.
	Edition_EDITION_1_TEST_ONLY     Edition = 1
	Edition_EDITION_2_TEST_ONLY     Edition = 2
	Edition_EDITION_99997_TEST_ONLY Edition = 99997
	Edition_EDITION_99998_TEST_ONLY Edition = 99998
	Edition_EDITION_99999_TEST_ONLY Edition = 99999
	// Placeholder for specifying unbounded edition support.  This should only
	// ever be used by plugins that can expect to never require any changes to
	// support a new edition.
	Edition_EDITION_MAX Edition = 2147483647
)

// Enum value maps for Edition.
var (
	Edition_name = map[int32]string{
		0:          "EDITION_UNKNOWN",
		998:        "EDITION_PROTO2",
		999:        "EDITION_PROTO3",
		1000:       "EDITION_2023",
		1001:       "EDITION_2024",
		1:          "EDITION_1_TEST_ONLY",
		2:          "EDITION_2_TEST_ONLY",
		99997:      "EDITION_99997_TEST_ONLY",
		99998:      "EDITION_99998_TEST_ONLY",
		99999:      "EDITION_99999_TEST_ONLY",
		2147483647: "EDITION_MAX",
	}
	Edition_value = map[string]int32{
		"EDITION_UNKNOWN":         0,
		"EDITION_PROTO2":          998,
		"EDITION_PROTO3":          999,
		"EDITION_2023":            1000,
		"EDITION_2024":            1001,
		"EDITION_1_TEST_ONLY":     1,
		"EDITION_2_TEST_ONLY":     2,
		"EDITION_99997_TEST_ONLY": 99997,
		"EDITION_99998_TEST_ONLY": 99998,
		"EDITION_99999_TEST_ONLY": 99999,
		"EDITION_MAX":             2147483647,
	}
)

func (x Edition) Enum() *Edition {
	p := new(Edition)
	*p = x
	return p
}

func (x Edition) String() string {
	name, valid := Edition_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// The verification state of the extension range.
type ExtensionRangeOptions_VerificationState int32

const (
	// All the extensions of the range must be declared.
	ExtensionRangeOptions_DECLARATION ExtensionRangeOptions_VerificationState = 0
	ExtensionRangeOptions_UNVERIFIED  ExtensionRangeOptions_VerificationState = 1
)

// Enum value maps for ExtensionRangeOptions_VerificationState.
var (
	ExtensionRangeOptions_VerificationState_name = map[int32]string{
		0: "DECLARATION",
		1: "UNVERIFIED",
	}
	ExtensionRangeOptions_VerificationState_value = map[string]int32{
		"DECLARATION": 0,
		"UNVERIFIED":  1,
	}
)

func (x ExtensionRangeOptions_VerificationState) Enum() *ExtensionRangeOptions_VerificationState {
	p := new(ExtensionRangeOptions_VerificationState)
	*p = x
	return p
}

func (x ExtensionRangeOptions_VerificationState) String() string {
	name, valid := ExtensionRangeOptions_VerificationState_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FieldDescriptorProto_Type int32

const (
	// 0 is reserved for errors.
	// Order is weird for historical reasons.
	FieldDescriptorProto_TYPE_DOUBLE FieldDescriptorProto_Type = 1
	FieldDescriptorProto_TYPE_FLOAT  FieldDescriptorProto_Type = 2
	// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
	// negative values are likely.
	FieldDescriptorProto_TYPE_INT64  FieldDescriptorProto_Type = 3
	FieldDescriptorProto_TYPE_UINT64 FieldDescriptorProto_Type = 4
	// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
	// negative values are likely.
	FieldDescriptorProto_TYPE_INT32   FieldDescriptorProto_Type = 5
	FieldDescriptorProto_TYPE_FIXED64 FieldDescriptorProto_Type = 6
	FieldDescriptorProto_TYPE_FIXED32 FieldDescriptorProto_Type = 7
	FieldDescriptorProto_TYPE_BOOL    FieldDescriptorProto_Type = 8
	FieldDescriptorProto_TYPE_STRING  FieldDescriptorProto_Type = 9
	// Tag-delimited aggregate.
	// Group type is deprecated and not supported after google.protobuf. However, Proto3
	// implementations should still be able to parse the group wire format and
	// treat group fields as unknown fields.  In Editions, the group wire format
	// can be enabled via the `message_encoding` feature.
	FieldDescriptorProto_TYPE_GROUP   FieldDescriptorProto_Type = 10
	FieldDescriptorProto_TYPE_MESSAGE FieldDescriptorProto_Type = 11 // Length-delimited aggregate.
	// New in version 2.
	FieldDescriptorProto_TYPE_BYTES    FieldDescriptorProto_Type = 12
	FieldDescriptorProto_TYPE_UINT32   FieldDescriptorProto_Type = 13
	FieldDescriptorProto_TYPE_ENUM     FieldDescriptorProto_Type = 14
	FieldDescriptorProto_TYPE_SFIXED32 FieldDescriptorProto_Type = 15
	FieldDescriptorProto_TYPE_SFIXED64 FieldDescriptorProto_Type = 16
	FieldDescriptorProto_TYPE_SINT32   FieldDescriptorProto_Type = 17 // Uses ZigZag encoding.
	FieldDescriptorProto_TYPE_SINT64   FieldDescriptorProto_Type = 18 // Uses ZigZag encoding.
)

// Enum value maps for FieldDescriptorProto_Type.
var (
	FieldDescriptorProto_Type_name = map[int32]string{
		1:  "TYPE_DOUBLE",
		2:  "TYPE_FLOAT",
		3:  "TYPE_INT64",
		4:  "TYPE_UINT64",
		5:  "TYPE_INT32",
		6:  "TYPE_FIXED64",
		7:  "TYPE_FIXED32",
		8:  "TYPE_BOOL",
		9:  "TYPE_STRING",
		10: "TYPE_GROUP",
		11: "TYPE_MESSAGE",
		12: "TYPE_BYTES",
		13: "TYPE_UINT32",
		14: "TYPE_ENUM",
		15: "TYPE_SFIXED32",
		16: "TYPE_SFIXED64",
		17: "TYPE_SINT32",
		18: "TYPE_SINT64",
	}
	FieldDescriptorProto_Type_value = map[string]int32{
		"TYPE_DOUBLE":   1,
		"TYPE_FLOAT":    2,
		"TYPE_INT64":    3,
		"TYPE_UINT64":   4,
		"TYPE_INT32":    5,
		"TYPE_FIXED64":  6,
		"TYPE_FIXED32":  7,
		"TYPE_BOOL":     8,
		"TYPE_STRING":   9,
		"TYPE_GROUP":    10,
		"TYPE_MESSAGE":  11,
		"TYPE_BYTES":    12,
		"TYPE_UINT32":   13,
		"TYPE_ENUM":     14,
		"TYPE_SFIXED32": 15,
		"TYPE_SFIXED64": 16,
		"TYPE_SINT32":   17,
		"TYPE_SINT64":   18,
	}
)

func (x FieldDescriptorProto_Type) Enum() *FieldDescriptorProto_Type {
	p := new(FieldDescriptorProto_Type)
	*p = x
	return p
}

func (x FieldDescriptorProto_Type) String() string {
	name, valid := FieldDescriptorProto_Type_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FieldDescriptorProto_Label int32

const (
	// 0 is reserved for errors
	FieldDescriptorProto_LABEL_OPTIONAL FieldDescriptorProto_Label = 1
	FieldDescriptorProto_LABEL_REPEATED FieldDescriptorProto_Label = 3
	// The required label is only allowed in google.protobuf.  In proto3 and Editions
	// it's explicitly prohibited.  In Editions, the `field_presence` feature
	// can be used to get this behavior.
	FieldDescriptorProto_LABEL_REQUIRED FieldDescriptorProto_Label = 2
)

// Enum value maps for FieldDescriptorProto_Label.
var (
	FieldDescriptorProto_Label_name = map[int32]string{
		1: "LABEL_OPTIONAL",
		3: "LABEL_REPEATED",
		2: "LABEL_REQUIRED",
	}
	FieldDescriptorProto_Label_value = map[string]int32{
		"LABEL_OPTIONAL": 1,
		"LABEL_REPEATED": 3,
		"LABEL_REQUIRED": 2,
	}
)

func (x FieldDescriptorProto_Label) Enum() *FieldDescriptorProto_Label {
	p := new(FieldDescriptorProto_Label)
	*p = x
	return p
}

func (x FieldDescriptorProto_Label) String() string {
	name, valid := FieldDescriptorProto_Label_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Generated classes can be optimized for speed or code size.
type FileOptions_OptimizeMode int32

const (
	FileOptions_SPEED FileOptions_OptimizeMode = 1 // Generate complete code for parsing, serialization,
	// etc.
	FileOptions_CODE_SIZE    FileOptions_OptimizeMode = 2 // Use ReflectionOps to implement these methods.
	FileOptions_LITE_RUNTIME FileOptions_OptimizeMode = 3 // Generate code using MessageLite and the lite runtime.
)

// Enum value maps for FileOptions_OptimizeMode.
var (
	FileOptions_OptimizeMode_name = map[int32]string{
		1: "SPEED",
		2: "CODE_SIZE",
		3: "LITE_RUNTIME",
	}
	FileOptions_OptimizeMode_value = map[string]int32{
		"SPEED":        1,
		"CODE_SIZE":    2,
		"LITE_RUNTIME": 3,
	}
)

func (x FileOptions_OptimizeMode) Enum() *FileOptions_OptimizeMode {
	p := new(FileOptions_OptimizeMode)
	*p = x
	return p
}

func (x FileOptions_OptimizeMode) String() string {
	name, valid := FileOptions_OptimizeMode_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FieldOptions_CType int32

const (
	// Default mode.
	FieldOptions_STRING FieldOptions_CType = 0
	// The option [ctype=CORD] may be applied to a non-repeated field of type
	// "bytes". It indicates that in C++, the data should be stored in a Cord
	// instead of a string.  For very large strings, this may reduce memory
	// fragmentation. It may also allow better performance when parsing from a
	// Cord, or when parsing with aliasing enabled, as the parsed Cord may then
	// alias the original buffer.
	FieldOptions_CORD         FieldOptions_CType = 1
	FieldOptions_STRING_PIECE FieldOptions_CType = 2
)

// Enum value maps for FieldOptions_CType.
var (
	FieldOptions_CType_name = map[int32]string{
		0: "STRING",
		1: "CORD",
		2: "STRING_PIECE",
	}
	FieldOptions_CType_value = map[string]int32{
		"STRING":       0,
		"CORD":         1,
		"STRING_PIECE": 2,
	}
)

func (x FieldOptions_CType) Enum() *FieldOptions_CType {
	p := new(FieldOptions_CType)
	*p = x
	return p
}

func (x FieldOptions_CType) String() string {
	name, valid := FieldOptions_CType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FieldOptions_JSType int32

const (
	// Use the default type.
	FieldOptions_JS_NORMAL FieldOptions_JSType = 0
	// Use JavaScript strings.
	FieldOptions_JS_STRING FieldOptions_JSType = 1
	// Use JavaScript numbers.
	FieldOptions_JS_NUMBER FieldOptions_JSType = 2
)

// Enum value maps for FieldOptions_JSType.
var (
	FieldOptions_JSType_name = map[int32]string{
		0: "JS_NORMAL",
		1: "JS_STRING",
		2: "JS_NUMBER",
	}
	FieldOptions_JSType_value = map[string]int32{
		"JS_NORMAL": 0,
		"JS_STRING": 1,
		"JS_NUMBER": 2,
	}
)

func (x FieldOptions_JSType) Enum() *FieldOptions_JSType {
	p := new(FieldOptions_JSType)
	*p = x
	return p
}

func (x FieldOptions_JSType) String() string {
	name, valid := FieldOptions_JSType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// If set to RETENTION_SOURCE, the option will be omitted from the binary.
// Note: as of January 2023, support for this is in progress and does not yet
// have an effect (b/264593489).
type FieldOptions_OptionRetention int32

const (
	FieldOptions_RETENTION_UNKNOWN FieldOptions_OptionRetention = 0
	FieldOptions_RETENTION_RUNTIME FieldOptions_OptionRetention = 1
	FieldOptions_RETENTION_SOURCE  FieldOptions_OptionRetention = 2
)

// Enum value maps for FieldOptions_OptionRetention.
var (
	FieldOptions_OptionRetention_name = map[int32]string{
		0: "RETENTION_UNKNOWN",
		1: "RETENTION_RUNTIME",
		2: "RETENTION_SOURCE",
	}
	FieldOptions_OptionRetention_value = map[string]int32{
		"RETENTION_UNKNOWN": 0,
		"RETENTION_RUNTIME": 1,
		"RETENTION_SOURCE":  2,
	}
)

func (x FieldOptions_OptionRetention) Enum() *FieldOptions_OptionRetention {
	p := new(FieldOptions_OptionRetention)
	*p = x
	return p
}

func (x FieldOptions_OptionRetention) String() string {
	name, valid := FieldOptions_OptionRetention_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// This indicates the types of entities that the field may apply to when used
// as an option. If it is unset, then the field may be freely used as an
// option on any kind of entity. Note: as of January 2023, support for this is
// in progress and does not yet have an effect (b/264593489).
type FieldOptions_OptionTargetType int32

const (
	FieldOptions_TARGET_TYPE_UNKNOWN         FieldOptions_OptionTargetType = 0
	FieldOptions_TARGET_TYPE_FILE            FieldOptions_OptionTargetType = 1
	FieldOptions_TARGET_TYPE_EXTENSION_RANGE FieldOptions_OptionTargetType = 2
	FieldOptions_TARGET_TYPE_MESSAGE         FieldOptions_OptionTargetType = 3
	FieldOptions_TARGET_TYPE_FIELD           FieldOptions_OptionTargetType = 4
	FieldOptions_TARGET_TYPE_ONEOF           FieldOptions_OptionTargetType = 5
	FieldOptions_TARGET_TYPE_ENUM            FieldOptions_OptionTargetType = 6
	FieldOptions_TARGET_TYPE_ENUM_ENTRY      FieldOptions_OptionTargetType = 7
	FieldOptions_TARGET_TYPE_SERVICE         FieldOptions_OptionTargetType = 8
	FieldOptions_TARGET_TYPE_METHOD          FieldOptions_OptionTargetType = 9
)

// Enum value maps for FieldOptions_OptionTargetType.
var (
	FieldOptions_OptionTargetType_name = map[int32]string{
		0: "TARGET_TYPE_UNKNOWN",
		1: "TARGET_TYPE_FILE",
		2: "TARGET_TYPE_EXTENSION_RANGE",
		3: "TARGET_TYPE_MESSAGE",
		4: "TARGET_TYPE_FIELD",
		5: "TARGET_TYPE_ONEOF",
		6: "TARGET_TYPE_ENUM",
		7: "TARGET_TYPE_ENUM_ENTRY",
		8: "TARGET_TYPE_SERVICE",
		9: "TARGET_TYPE_METHOD",
	}
	FieldOptions_OptionTargetType_value = map[string]int32{
		"TARGET_TYPE_UNKNOWN":         0,
		"TARGET_TYPE_FILE":            1,
		"TARGET_TYPE_EXTENSION_RANGE": 2,
		"TARGET_TYPE_MESSAGE":         3,
		"TARGET_TYPE_FIELD":           4,
		"TARGET_TYPE_ONEOF":           5,
		"TARGET_TYPE_ENUM":            6,
		"TARGET_TYPE_ENUM_ENTRY":      7,
		"TARGET_TYPE_SERVICE":         8,
		"TARGET_TYPE_METHOD":          9,
	}
)

func (x FieldOptions_OptionTargetType) Enum() *FieldOptions_OptionTargetType {
	p := new(FieldOptions_OptionTargetType)
	*p = x
	return p
}

func (x FieldOptions_OptionTargetType) String() string {
	name, valid := FieldOptions_OptionTargetType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
// or neither? HTTP based RPC implementation may choose GET verb for safe
// methods, and PUT verb for idempotent methods instead of the default POST.
type MethodOptions_IdempotencyLevel int32

const (
	MethodOptions_IDEMPOTENCY_UNKNOWN MethodOptions_IdempotencyLevel = 0
	MethodOptions_NO_SIDE_EFFECTS     MethodOptions_IdempotencyLevel = 1 // implies idempotent
	MethodOptions_IDEMPOTENT          MethodOptions_IdempotencyLevel = 2 // idempotent, but may have side effects
)

// Enum value maps for MethodOptions_IdempotencyLevel.
var (
	MethodOptions_IdempotencyLevel_name = map[int32]string{
		0: "IDEMPOTENCY_UNKNOWN",
		1: "NO_SIDE_EFFECTS",
		2: "IDEMPOTENT",
	}
	MethodOptions_IdempotencyLevel_value = map[string]int32{
		"IDEMPOTENCY_UNKNOWN": 0,
		"NO_SIDE_EFFECTS":     1,
		"IDEMPOTENT":          2,
	}
)

func (x MethodOptions_IdempotencyLevel) Enum() *MethodOptions_IdempotencyLevel {
	p := new(MethodOptions_IdempotencyLevel)
	*p = x
	return p
}

func (x MethodOptions_IdempotencyLevel) String() string {
	name, valid := MethodOptions_IdempotencyLevel_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_FieldPresence int32

const (
	FeatureSet_FIELD_PRESENCE_UNKNOWN FeatureSet_FieldPresence = 0
	FeatureSet_EXPLICIT               FeatureSet_FieldPresence = 1
	FeatureSet_IMPLICIT               FeatureSet_FieldPresence = 2
	FeatureSet_LEGACY_REQUIRED        FeatureSet_FieldPresence = 3
)

// Enum value maps for FeatureSet_FieldPresence.
var (
	FeatureSet_FieldPresence_name = map[int32]string{
		0: "FIELD_PRESENCE_UNKNOWN",
		1: "EXPLICIT",
		2: "IMPLICIT",
		3: "LEGACY_REQUIRED",
	}
	FeatureSet_FieldPresence_value = map[string]int32{
		"FIELD_PRESENCE_UNKNOWN": 0,
		"EXPLICIT":               1,
		"IMPLICIT":               2,
		"LEGACY_REQUIRED":        3,
	}
)

func (x FeatureSet_FieldPresence) Enum() *FeatureSet_FieldPresence {
	p := new(FeatureSet_FieldPresence)
	*p = x
	return p
}

func (x FeatureSet_FieldPresence) String() string {
	name, valid := FeatureSet_FieldPresence_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_EnumType int32

const (
	FeatureSet_ENUM_TYPE_UNKNOWN FeatureSet_EnumType = 0
	FeatureSet_OPEN              FeatureSet_EnumType = 1
	FeatureSet_CLOSED            FeatureSet_EnumType = 2
)

// Enum value maps for FeatureSet_EnumType.
var (
	FeatureSet_EnumType_name = map[int32]string{
		0: "ENUM_TYPE_UNKNOWN",
		1: "OPEN",
		2: "CLOSED",
	}
	FeatureSet_EnumType_value = map[string]int32{
		"ENUM_TYPE_UNKNOWN": 0,
		"OPEN":              1,
		"CLOSED":            2,
	}
)

func (x FeatureSet_EnumType) Enum() *FeatureSet_EnumType {
	p := new(FeatureSet_EnumType)
	*p = x
	return p
}

func (x FeatureSet_EnumType) String() string {
	name, valid := FeatureSet_EnumType_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_RepeatedFieldEncoding int32

const (
	FeatureSet_REPEATED_FIELD_ENCODING_UNKNOWN FeatureSet_RepeatedFieldEncoding = 0
	FeatureSet_PACKED                          FeatureSet_RepeatedFieldEncoding = 1
	FeatureSet_EXPANDED                        FeatureSet_RepeatedFieldEncoding = 2
)

// Enum value maps for FeatureSet_RepeatedFieldEncoding.
var (
	FeatureSet_RepeatedFieldEncoding_name = map[int32]string{
		0: "REPEATED_FIELD_ENCODING_UNKNOWN",
		1: "PACKED",
		2: "EXPANDED",
	}
	FeatureSet_RepeatedFieldEncoding_value = map[string]int32{
		"REPEATED_FIELD_ENCODING_UNKNOWN": 0,
		"PACKED":                          1,
		"EXPANDED":                        2,
	}
)

func (x FeatureSet_RepeatedFieldEncoding) Enum() *FeatureSet_RepeatedFieldEncoding {
	p := new(FeatureSet_RepeatedFieldEncoding)
	*p = x
	return p
}

func (x FeatureSet_RepeatedFieldEncoding) String() string {
	name, valid := FeatureSet_RepeatedFieldEncoding_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_Utf8Validation int32

const (
	FeatureSet_UTF8_VALIDATION_UNKNOWN FeatureSet_Utf8Validation = 0
	FeatureSet_VERIFY                  FeatureSet_Utf8Validation = 2
	FeatureSet_NONE                    FeatureSet_Utf8Validation = 3
)

// Enum value maps for FeatureSet_Utf8Validation.
var (
	FeatureSet_Utf8Validation_name = map[int32]string{
		0: "UTF8_VALIDATION_UNKNOWN",
		2: "VERIFY",
		3: "NONE",
	}
	FeatureSet_Utf8Validation_value = map[string]int32{
		"UTF8_VALIDATION_UNKNOWN": 0,
		"VERIFY":                  2,
		"NONE":                    3,
	}
)

func (x FeatureSet_Utf8Validation) Enum() *FeatureSet_Utf8Validation {
	p := new(FeatureSet_Utf8Validation)
	*p = x
	return p
}

func (x FeatureSet_Utf8Validation) String() string {
	name, valid := FeatureSet_Utf8Validation_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_MessageEncoding int32

const (
	FeatureSet_MESSAGE_ENCODING_UNKNOWN FeatureSet_MessageEncoding = 0
	FeatureSet_LENGTH_PREFIXED          FeatureSet_MessageEncoding = 1
	FeatureSet_DELIMITED                FeatureSet_MessageEncoding = 2
)

// Enum value maps for FeatureSet_MessageEncoding.
var (
	FeatureSet_MessageEncoding_name = map[int32]string{
		0: "MESSAGE_ENCODING_UNKNOWN",
		1: "LENGTH_PREFIXED",
		2: "DELIMITED",
	}
	FeatureSet_MessageEncoding_value = map[string]int32{
		"MESSAGE_ENCODING_UNKNOWN": 0,
		"LENGTH_PREFIXED":          1,
		"DELIMITED":                2,
	}
)

func (x FeatureSet_MessageEncoding) Enum() *FeatureSet_MessageEncoding {
	p := new(FeatureSet_MessageEncoding)
	*p = x
	return p
}

func (x FeatureSet_MessageEncoding) String() string {
	name, valid := FeatureSet_MessageEncoding_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type FeatureSet_JsonFormat int32

const (
	FeatureSet_JSON_FORMAT_UNKNOWN FeatureSet_JsonFormat = 0
	FeatureSet_ALLOW               FeatureSet_JsonFormat = 1
	FeatureSet_LEGACY_BEST_EFFORT  FeatureSet_JsonFormat = 2
)

// Enum value maps for FeatureSet_JsonFormat.
var (
	FeatureSet_JsonFormat_name = map[int32]string{
		0: "JSON_FORMAT_UNKNOWN",
		1: "ALLOW",
		2: "LEGACY_BEST_EFFORT",
	}
	FeatureSet_JsonFormat_value = map[string]int32{
		"JSON_FORMAT_UNKNOWN": 0,
		"ALLOW":               1,
		"LEGACY_BEST_EFFORT":  2,
	}
)

func (x FeatureSet_JsonFormat) Enum() *FeatureSet_JsonFormat {
	p := new(FeatureSet_JsonFormat)
	*p = x
	return p
}

func (x FeatureSet_JsonFormat) String() string {
	name, valid := FeatureSet_JsonFormat_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// Represents the identified object's effect on the element in the original
// .proto file.
type GeneratedCodeInfo_Annotation_Semantic int32

const (
	// There is no effect or the effect is indescribable.
	GeneratedCodeInfo_Annotation_NONE GeneratedCodeInfo_Annotation_Semantic = 0
	// The element is set or otherwise mutated.
	GeneratedCodeInfo_Annotation_SET GeneratedCodeInfo_Annotation_Semantic = 1
	// An alias to the element is returned.
	GeneratedCodeInfo_Annotation_ALIAS GeneratedCodeInfo_Annotation_Semantic = 2
)

// Enum value maps for GeneratedCodeInfo_Annotation_Semantic.
var (
	GeneratedCodeInfo_Annotation_Semantic_name = map[int32]string{
		0: "NONE",
		1: "SET",
		2: "ALIAS",
	}
	GeneratedCodeInfo_Annotation_Semantic_value = map[string]int32{
		"NONE":  0,
		"SET":   1,
		"ALIAS": 2,
	}
)

func (x GeneratedCodeInfo_Annotation_Semantic) Enum() *GeneratedCodeInfo_Annotation_Semantic {
	p := new(GeneratedCodeInfo_Annotation_Semantic)
	*p = x
	return p
}

func (x GeneratedCodeInfo_Annotation_Semantic) String() string {
	name, valid := GeneratedCodeInfo_Annotation_Semantic_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
type FileDescriptorSet struct {
	unknownFields []byte
	File          []*FileDescriptorProto `protobuf:"bytes,1,rep,name=file" json:"file,omitempty"`
}

func (x *FileDescriptorSet) Reset() {
	*x = FileDescriptorSet{}
}

func (*FileDescriptorSet) ProtoMessage() {}

func (x *FileDescriptorSet) GetFile() []*FileDescriptorProto {
	if x != nil {
		return x.File
	}
	return nil
}

// Describes a complete .proto file.
type FileDescriptorProto struct {
	unknownFields []byte
	Name          *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`       // file name, relative to root of source tree
	Package       *string `protobuf:"bytes,2,opt,name=package" json:"package,omitempty"` // e.g. "foo", "foo.bar", etc.
	// Names of files imported by this file.
	Dependency []string `protobuf:"bytes,3,rep,name=dependency" json:"dependency,omitempty"`
	// Indexes of the public imported files in the dependency list above.
	PublicDependency []int32 `protobuf:"varint,10,rep,name=public_dependency,json=publicDependency" json:"public_dependency,omitempty"`
	// Indexes of the weak imported files in the dependency list.
	// For Google-internal migration only. Do not use.
	WeakDependency []int32 `protobuf:"varint,11,rep,name=weak_dependency,json=weakDependency" json:"weak_dependency,omitempty"`
	// All top-level definitions in this file.
	MessageType []*DescriptorProto        `protobuf:"bytes,4,rep,name=message_type,json=messageType" json:"message_type,omitempty"`
	EnumType    []*EnumDescriptorProto    `protobuf:"bytes,5,rep,name=enum_type,json=enumType" json:"enum_type,omitempty"`
	Service     []*ServiceDescriptorProto `protobuf:"bytes,6,rep,name=service" json:"service,omitempty"`
	Extension   []*FieldDescriptorProto   `protobuf:"bytes,7,rep,name=extension" json:"extension,omitempty"`
	Options     *FileOptions              `protobuf:"bytes,8,opt,name=options" json:"options,omitempty"`
	// This field contains optional information about the original source code.
	// You may safely remove this entire field without harming runtime
	// functionality of the descriptors -- the information is needed only by
	// development tools.
	SourceCodeInfo *SourceCodeInfo `protobuf:"bytes,9,opt,name=source_code_info,json=sourceCodeInfo" json:"source_code_info,omitempty"`
	// The syntax of the proto file.
	// The supported values are "proto2", "proto3", and "editions".
	//
	// If `edition` is present, this value must be "editions".
	Syntax *string `protobuf:"bytes,12,opt,name=syntax" json:"syntax,omitempty"`
	// The edition of the proto file.
	Edition *Edition `protobuf:"varint,14,opt,name=edition" json:"edition,omitempty"`
}

func (x *FileDescriptorProto) Reset() {
	*x = FileDescriptorProto{}
}

func (*FileDescriptorProto) ProtoMessage() {}

func (x *FileDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *FileDescriptorProto) GetPackage() string {
	if x != nil && x.Package != nil {
		return *x.Package
	}
	return ""
}

func (x *FileDescriptorProto) GetDependency() []string {
	if x != nil {
		return x.Dependency
	}
	return nil
}

func (x *FileDescriptorProto) GetPublicDependency() []int32 {
	if x != nil {
		return x.PublicDependency
	}
	return nil
}

func (x *FileDescriptorProto) GetWeakDependency() []int32 {
	if x != nil {
		return x.WeakDependency
	}
	return nil
}

func (x *FileDescriptorProto) GetMessageType() []*DescriptorProto {
	if x != nil {
		return x.MessageType
	}
	return nil
}

func (x *FileDescriptorProto) GetEnumType() []*EnumDescriptorProto {
	if x != nil {
		return x.EnumType
	}
	return nil
}

func (x *FileDescriptorProto) GetService() []*ServiceDescriptorProto {
	if x != nil {
		return x.Service
	}
	return nil
}

func (x *FileDescriptorProto) GetExtension() []*FieldDescriptorProto {
	if x != nil {
		return x.Extension
	}
	return nil
}

func (x *FileDescriptorProto) GetOptions() *FileOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *FileDescriptorProto) GetSourceCodeInfo() *SourceCodeInfo {
	if x != nil {
		return x.SourceCodeInfo
	}
	return nil
}

func (x *FileDescriptorProto) GetSyntax() string {
	if x != nil && x.Syntax != nil {
		return *x.Syntax
	}
	return ""
}

func (x *FileDescriptorProto) GetEdition() Edition {
	if x != nil && x.Edition != nil {
		return *x.Edition
	}
	return Edition_EDITION_UNKNOWN
}

// Describes a message type.
type DescriptorProto struct {
	unknownFields  []byte
	Name           *string                           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Field          []*FieldDescriptorProto           `protobuf:"bytes,2,rep,name=field" json:"field,omitempty"`
	Extension      []*FieldDescriptorProto           `protobuf:"bytes,6,rep,name=extension" json:"extension,omitempty"`
	NestedType     []*DescriptorProto                `protobuf:"bytes,3,rep,name=nested_type,json=nestedType" json:"nested_type,omitempty"`
	EnumType       []*EnumDescriptorProto            `protobuf:"bytes,4,rep,name=enum_type,json=enumType" json:"enum_type,omitempty"`
	ExtensionRange []*DescriptorProto_ExtensionRange `protobuf:"bytes,5,rep,name=extension_range,json=extensionRange" json:"extension_range,omitempty"`
	OneofDecl      []*OneofDescriptorProto           `protobuf:"bytes,8,rep,name=oneof_decl,json=oneofDecl" json:"oneof_decl,omitempty"`
	Options        *MessageOptions                   `protobuf:"bytes,7,opt,name=options" json:"options,omitempty"`
	ReservedRange  []*DescriptorProto_ReservedRange  `protobuf:"bytes,9,rep,name=reserved_range,json=reservedRange" json:"reserved_range,omitempty"`
	// Reserved field names, which may not be used by fields in the same message.
	// A given name may only be reserved once.
	ReservedName []string `protobuf:"bytes,10,rep,name=reserved_name,json=reservedName" json:"reserved_name,omitempty"`
}

func (x *DescriptorProto) Reset() {
	*x = DescriptorProto{}
}

func (*DescriptorProto) ProtoMessage() {}

func (x *DescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *DescriptorProto) GetField() []*FieldDescriptorProto {
	if x != nil {
		return x.Field
	}
	return nil
}

func (x *DescriptorProto) GetExtension() []*FieldDescriptorProto {
	if x != nil {
		return x.Extension
	}
	return nil
}

func (x *DescriptorProto) GetNestedType() []*DescriptorProto {
	if x != nil {
		return x.NestedType
	}
	return nil
}

func (x *DescriptorProto) GetEnumType() []*EnumDescriptorProto {
	if x != nil {
		return x.EnumType
	}
	return nil
}

func (x *DescriptorProto) GetExtensionRange() []*DescriptorProto_ExtensionRange {
	if x != nil {
		return x.ExtensionRange
	}
	return nil
}

func (x *DescriptorProto) GetOneofDecl() []*OneofDescriptorProto {
	if x != nil {
		return x.OneofDecl
	}
	return nil
}

func (x *DescriptorProto) GetOptions() *MessageOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *DescriptorProto) GetReservedRange() []*DescriptorProto_ReservedRange {
	if x != nil {
		return x.ReservedRange
	}
	return nil
}

func (x *DescriptorProto) GetReservedName() []string {
	if x != nil {
		return x.ReservedName
	}
	return nil
}

type ExtensionRangeOptions struct {
	unknownFields []byte
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
	// For external users: DO NOT USE. We are in the process of open sourcing
	// extension declaration and executing internal cleanups before it can be
	// used externally.
	Declaration []*ExtensionRangeOptions_Declaration `protobuf:"bytes,2,rep,name=declaration" json:"declaration,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,50,opt,name=features" json:"features,omitempty"`
	// The verification state of the range.
	// TODO: flip the default to DECLARATION once all empty ranges
	// are marked as UNVERIFIED.
	Verification *ExtensionRangeOptions_VerificationState `protobuf:"varint,3,opt,name=verification,def=1" json:"verification,omitempty"`
}

// Default values for ExtensionRangeOptions fields.
const (
	Default_ExtensionRangeOptions_Verification = ExtensionRangeOptions_UNVERIFIED
)

func (x *ExtensionRangeOptions) Reset() {
	*x = ExtensionRangeOptions{}
}

func (*ExtensionRangeOptions) ProtoMessage() {}

func (x *ExtensionRangeOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

func (x *ExtensionRangeOptions) GetDeclaration() []*ExtensionRangeOptions_Declaration {
	if x != nil {
		return x.Declaration
	}
	return nil
}

func (x *ExtensionRangeOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *ExtensionRangeOptions) GetVerification() ExtensionRangeOptions_VerificationState {
	if x != nil && x.Verification != nil {
		return *x.Verification
	}
	return Default_ExtensionRangeOptions_Verification
}

// Describes a field within a message.
type FieldDescriptorProto struct {
	unknownFields []byte
	Name          *string                     `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Number        *int32                      `protobuf:"varint,3,opt,name=number" json:"number,omitempty"`
	Label         *FieldDescriptorProto_Label `protobuf:"varint,4,opt,name=label" json:"label,omitempty"`
	// If type_name is set, this need not be set.  If both this and type_name
	// are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
	Type *FieldDescriptorProto_Type `protobuf:"varint,5,opt,name=type" json:"type,omitempty"`
	// For message and enum types, this is the name of the type.  If the name
	// starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
	// rules are used to find the type (i.e. first the nested types within this
	// message are searched, then within the parent, on up to the root
	// namespace).
	TypeName *string `protobuf:"bytes,6,opt,name=type_name,json=typeName" json:"type_name,omitempty"`
	// For extensions, this is the name of the type being extended.  It is
	// resolved in the same manner as type_name.
	Extendee *string `protobuf:"bytes,2,opt,name=extendee" json:"extendee,omitempty"`
	// For numeric types, contains the original text representation of the value.
	// For booleans, "true" or "false".
	// For strings, contains the default text contents (not escaped in any way).
	// For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
	DefaultValue *string `protobuf:"bytes,7,opt,name=default_value,json=defaultValue" json:"default_value,omitempty"`
	// If set, gives the index of a oneof in the containing type's oneof_decl
	// list.  This field is a member of that oneof.
	OneofIndex *int32 `protobuf:"varint,9,opt,name=oneof_index,json=oneofIndex" json:"oneof_index,omitempty"`
	// JSON name of this field. The value is set by protocol compiler. If the
	// user has set a "json_name" option on this field, that option's value
	// will be used. Otherwise, it's deduced from the field's name by converting
	// it to camelCase.
	JsonName *string       `protobuf:"bytes,10,opt,name=json_name,json=jsonName" json:"json_name,omitempty"`
	Options  *FieldOptions `protobuf:"bytes,8,opt,name=options" json:"options,omitempty"`
	// If true, this is a proto3 "optional". When a proto3 field is optional, it
	// tracks presence regardless of field type.
	//
	// When proto3_optional is true, this field must belong to a oneof to signal
	// to old proto3 clients that presence is tracked for this field. This oneof
	// is known as a "synthetic" oneof, and this field must be its sole member
	// (each proto3 optional field gets its own synthetic oneof). Synthetic oneofs
	// exist in the descriptor only, and do not generate any API. Synthetic oneofs
	// must be ordered after all "real" oneofs.
	//
	// For message fields, proto3_optional doesn't create any semantic change,
	// since non-repeated message fields always track presence. However it still
	// indicates the semantic detail of whether the user wrote "optional" or not.
	// This can be useful for round-tripping the .proto file. For consistency we
	// give message fields a synthetic oneof also, even though it is not required
	// to track presence. This is especially important because the parser can't
	// tell if a field is a message or an enum, so it must always create a
	// synthetic oneof.
	//
	// Proto2 optional fields do not set this flag, because they already indicate
	// optional with `LABEL_OPTIONAL`.
	Proto3Optional *bool `protobuf:"varint,17,opt,name=proto3_optional,json=proto3Optional" json:"proto3_optional,omitempty"`
}

func (x *FieldDescriptorProto) Reset() {
	*x = FieldDescriptorProto{}
}

func (*FieldDescriptorProto) ProtoMessage() {}

func (x *FieldDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *FieldDescriptorProto) GetNumber() int32 {
	if x != nil && x.Number != nil {
		return *x.Number
	}
	return 0
}

func (x *FieldDescriptorProto) GetLabel() FieldDescriptorProto_Label {
	if x != nil && x.Label != nil {
		return *x.Label
	}
	return FieldDescriptorProto_LABEL_OPTIONAL
}

func (x *FieldDescriptorProto) GetType() FieldDescriptorProto_Type {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return FieldDescriptorProto_TYPE_DOUBLE
}

func (x *FieldDescriptorProto) GetTypeName() string {
	if x != nil && x.TypeName != nil {
		return *x.TypeName
	}
	return ""
}

func (x *FieldDescriptorProto) GetExtendee() string {
	if x != nil && x.Extendee != nil {
		return *x.Extendee
	}
	return ""
}

func (x *FieldDescriptorProto) GetDefaultValue() string {
	if x != nil && x.DefaultValue != nil {
		return *x.DefaultValue
	}
	return ""
}

func (x *FieldDescriptorProto) GetOneofIndex() int32 {
	if x != nil && x.OneofIndex != nil {
		return *x.OneofIndex
	}
	return 0
}

func (x *FieldDescriptorProto) GetJsonName() string {
	if x != nil && x.JsonName != nil {
		return *x.JsonName
	}
	return ""
}

func (x *FieldDescriptorProto) GetOptions() *FieldOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *FieldDescriptorProto) GetProto3Optional() bool {
	if x != nil && x.Proto3Optional != nil {
		return *x.Proto3Optional
	}
	return false
}

// Describes a oneof.
type OneofDescriptorProto struct {
	unknownFields []byte
	Name          *string       `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Options       *OneofOptions `protobuf:"bytes,2,opt,name=options" json:"options,omitempty"`
}

func (x *OneofDescriptorProto) Reset() {
	*x = OneofDescriptorProto{}
}

func (*OneofDescriptorProto) ProtoMessage() {}

func (x *OneofDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *OneofDescriptorProto) GetOptions() *OneofOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Describes an enum type.
type EnumDescriptorProto struct {
	unknownFields []byte
	Name          *string                     `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value         []*EnumValueDescriptorProto `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
	Options       *EnumOptions                `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
	// Range of reserved numeric values. Reserved numeric values may not be used
	// by enum values in the same enum declaration. Reserved ranges may not
	// overlap.
	ReservedRange []*EnumDescriptorProto_EnumReservedRange `protobuf:"bytes,4,rep,name=reserved_range,json=reservedRange" json:"reserved_range,omitempty"`
	// Reserved enum value names, which may not be reused. A given name may only
	// be reserved once.
	ReservedName []string `protobuf:"bytes,5,rep,name=reserved_name,json=reservedName" json:"reserved_name,omitempty"`
}

func (x *EnumDescriptorProto) Reset() {
	*x = EnumDescriptorProto{}
}

func (*EnumDescriptorProto) ProtoMessage() {}

func (x *EnumDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *EnumDescriptorProto) GetValue() []*EnumValueDescriptorProto {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *EnumDescriptorProto) GetOptions() *EnumOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *EnumDescriptorProto) GetReservedRange() []*EnumDescriptorProto_EnumReservedRange {
	if x != nil {
		return x.ReservedRange
	}
	return nil
}

func (x *EnumDescriptorProto) GetReservedName() []string {
	if x != nil {
		return x.ReservedName
	}
	return nil
}

// Describes a value within an enum.
type EnumValueDescriptorProto struct {
	unknownFields []byte
	Name          *string           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Number        *int32            `protobuf:"varint,2,opt,name=number" json:"number,omitempty"`
	Options       *EnumValueOptions `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
}

func (x *EnumValueDescriptorProto) Reset() {
	*x = EnumValueDescriptorProto{}
}

func (*EnumValueDescriptorProto) ProtoMessage() {}

func (x *EnumValueDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *EnumValueDescriptorProto) GetNumber() int32 {
	if x != nil && x.Number != nil {
		return *x.Number
	}
	return 0
}

func (x *EnumValueDescriptorProto) GetOptions() *EnumValueOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Describes a service.
type ServiceDescriptorProto struct {
	unknownFields []byte
	Name          *string                  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Method        []*MethodDescriptorProto `protobuf:"bytes,2,rep,name=method" json:"method,omitempty"`
	Options       *ServiceOptions          `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
}

func (x *ServiceDescriptorProto) Reset() {
	*x = ServiceDescriptorProto{}
}

func (*ServiceDescriptorProto) ProtoMessage() {}

func (x *ServiceDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ServiceDescriptorProto) GetMethod() []*MethodDescriptorProto {
	if x != nil {
		return x.Method
	}
	return nil
}

func (x *ServiceDescriptorProto) GetOptions() *ServiceOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Describes a method of a service.
type MethodDescriptorProto struct {
	unknownFields []byte
	Name          *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Input and output type names.  These are resolved in the same way as
	// FieldDescriptorProto.type_name, but must refer to a message type.
	InputType  *string        `protobuf:"bytes,2,opt,name=input_type,json=inputType" json:"input_type,omitempty"`
	OutputType *string        `protobuf:"bytes,3,opt,name=output_type,json=outputType" json:"output_type,omitempty"`
	Options    *MethodOptions `protobuf:"bytes,4,opt,name=options" json:"options,omitempty"`
	// Identifies if client streams multiple client messages
	ClientStreaming *bool `protobuf:"varint,5,opt,name=client_streaming,json=clientStreaming,def=0" json:"client_streaming,omitempty"`
	// Identifies if server streams multiple server messages
	ServerStreaming *bool `protobuf:"varint,6,opt,name=server_streaming,json=serverStreaming,def=0" json:"server_streaming,omitempty"`
}

// Default values for MethodDescriptorProto fields.
const (
	Default_MethodDescriptorProto_ClientStreaming = bool(false)
	Default_MethodDescriptorProto_ServerStreaming = bool(false)
)

func (x *MethodDescriptorProto) Reset() {
	*x = MethodDescriptorProto{}
}

func (*MethodDescriptorProto) ProtoMessage() {}

func (x *MethodDescriptorProto) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *MethodDescriptorProto) GetInputType() string {
	if x != nil && x.InputType != nil {
		return *x.InputType
	}
	return ""
}

func (x *MethodDescriptorProto) GetOutputType() string {
	if x != nil && x.OutputType != nil {
		return *x.OutputType
	}
	return ""
}

func (x *MethodDescriptorProto) GetOptions() *MethodOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *MethodDescriptorProto) GetClientStreaming() bool {
	if x != nil && x.ClientStreaming != nil {
		return *x.ClientStreaming
	}
	return Default_MethodDescriptorProto_ClientStreaming
}

func (x *MethodDescriptorProto) GetServerStreaming() bool {
	if x != nil && x.ServerStreaming != nil {
		return *x.ServerStreaming
	}
	return Default_MethodDescriptorProto_ServerStreaming
}

type FileOptions struct {
	unknownFields []byte
	// Sets the Java package where classes generated from this .proto will be
	// placed.  By default, the proto package is used, but this is often
	// inappropriate because proto packages do not normally start with backwards
	// domain names.
	JavaPackage *string `protobuf:"bytes,1,opt,name=java_package,json=javaPackage" json:"java_package,omitempty"`
	// Controls the name of the wrapper Java class generated for the .proto file.
	// That class will always contain the .proto file's getDescriptor() method as
	// well as any top-level extensions defined in the .proto file.
	// If java_multiple_files is disabled, then all the other classes from the
	// .proto file will be nested inside the single wrapper outer class.
	JavaOuterClassname *string `protobuf:"bytes,8,opt,name=java_outer_classname,json=javaOuterClassname" json:"java_outer_classname,omitempty"`
	// If enabled, then the Java code generator will generate a separate .java
	// file for each top-level message, enum, and service defined in the .proto
	// file.  Thus, these types will *not* be nested inside the wrapper class
	// named by java_outer_classname.  However, the wrapper class will still be
	// generated to contain the file's getDescriptor() method as well as any
	// top-level extensions defined in the file.
	JavaMultipleFiles *bool `protobuf:"varint,10,opt,name=java_multiple_files,json=javaMultipleFiles,def=0" json:"java_multiple_files,omitempty"`
	// This option does nothing.
	//
	// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
	JavaGenerateEqualsAndHash *bool `protobuf:"varint,20,opt,name=java_generate_equals_and_hash,json=javaGenerateEqualsAndHash" json:"java_generate_equals_and_hash,omitempty"`
	// If set true, then the Java2 code generator will generate code that
	// throws an exception whenever an attempt is made to assign a non-UTF-8
	// byte sequence to a string field.
	// Message reflection will do the same.
	// However, an extension field still accepts non-UTF-8 byte sequences.
	// This option has no effect on when used with the lite runtime.
	JavaStringCheckUtf8 *bool                     `protobuf:"varint,27,opt,name=java_string_check_utf8,json=javaStringCheckUtf8,def=0" json:"java_string_check_utf8,omitempty"`
	OptimizeFor         *FileOptions_OptimizeMode `protobuf:"varint,9,opt,name=optimize_for,json=optimizeFor,def=1" json:"optimize_for,omitempty"`
	// Sets the Go package where structs generated from this .proto will be
	// placed. If omitted, the Go package will be derived from the following:
	//   - The basename of the package import path, if provided.
	//   - Otherwise, the package statement in the .proto file, if present.
	//   - Otherwise, the basename of the .proto file, without extension.
	GoPackage *string `protobuf:"bytes,11,opt,name=go_package,json=goPackage" json:"go_package,omitempty"`
	// Should generic services be generated in each language?  "Generic" services
	// are not specific to any particular RPC system.  They are generated by the
	// main code generators in each language (without additional plugins).
	// Generic services were the only kind of service generation supported by
	// early versions of google.protobuf.
	//
	// Generic services are now considered deprecated in favor of using plugins
	// that generate code specific to your particular RPC system.  Therefore,
	// these default to false.  Old code which depends on generic services should
	// explicitly set them to true.
	CcGenericServices   *bool `protobuf:"varint,16,opt,name=cc_generic_services,json=ccGenericServices,def=0" json:"cc_generic_services,omitempty"`
	JavaGenericServices *bool `protobuf:"varint,17,opt,name=java_generic_services,json=javaGenericServices,def=0" json:"java_generic_services,omitempty"`
	PyGenericServices   *bool `protobuf:"varint,18,opt,name=py_generic_services,json=pyGenericServices,def=0" json:"py_generic_services,omitempty"`
	// Is this file deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for everything in the file, or it will be completely ignored; in the very
	// least, this is a formalization for deprecating files.
	Deprecated *bool `protobuf:"varint,23,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// Enables the use of arenas for the proto messages in this file. This applies
	// only to generated classes for C++.
	CcEnableArenas *bool `protobuf:"varint,31,opt,name=cc_enable_arenas,json=ccEnableArenas,def=1" json:"cc_enable_arenas,omitempty"`
	// Sets the objective c class prefix which is prepended to all objective c
	// generated classes from this .proto. There is no default.
	ObjcClassPrefix *string `protobuf:"bytes,36,opt,name=objc_class_prefix,json=objcClassPrefix" json:"objc_class_prefix,omitempty"`
	// Namespace for generated classes; defaults to the package.
	CsharpNamespace *string `protobuf:"bytes,37,opt,name=csharp_namespace,json=csharpNamespace" json:"csharp_namespace,omitempty"`
	// By default Swift generators will take the proto package and CamelCase it
	// replacing '.' with underscore and use that to prefix the types/symbols
	// defined. When this options is provided, they will use this value instead
	// to prefix the types/symbols defined.
	SwiftPrefix *string `protobuf:"bytes,39,opt,name=swift_prefix,json=swiftPrefix" json:"swift_prefix,omitempty"`
	// Sets the php class prefix which is prepended to all php generated classes
	// from this .proto. Default is empty.
	PhpClassPrefix *string `protobuf:"bytes,40,opt,name=php_class_prefix,json=phpClassPrefix" json:"php_class_prefix,omitempty"`
	// Use this option to change the namespace of php generated classes. Default
	// is empty. When this option is empty, the package name will be used for
	// determining the namespace.
	PhpNamespace *string `protobuf:"bytes,41,opt,name=php_namespace,json=phpNamespace" json:"php_namespace,omitempty"`
	// Use this option to change the namespace of php generated metadata classes.
	// Default is empty. When this option is empty, the proto file name will be
	// used for determining the namespace.
	PhpMetadataNamespace *string `protobuf:"bytes,44,opt,name=php_metadata_namespace,json=phpMetadataNamespace" json:"php_metadata_namespace,omitempty"`
	// Use this option to change the package of ruby generated classes. Default
	// is empty. When this option is not set, the package name will be used for
	// determining the ruby package.
	RubyPackage *string `protobuf:"bytes,45,opt,name=ruby_package,json=rubyPackage" json:"ruby_package,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,50,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here.
	// See the documentation for the "Options" section above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
}

// Default values for FileOptions fields.
const (
	Default_FileOptions_JavaMultipleFiles   = bool(false)
	Default_FileOptions_JavaStringCheckUtf8 = bool(false)
	Default_FileOptions_OptimizeFor         = FileOptions_SPEED
	Default_FileOptions_CcGenericServices   = bool(false)
	Default_FileOptions_JavaGenericServices = bool(false)
	Default_FileOptions_PyGenericServices   = bool(false)
	Default_FileOptions_Deprecated          = bool(false)
	Default_FileOptions_CcEnableArenas      = bool(true)
)

func (x *FileOptions) Reset() {
	*x = FileOptions{}
}

func (*FileOptions) ProtoMessage() {}

func (x *FileOptions) GetJavaPackage() string {
	if x != nil && x.JavaPackage != nil {
		return *x.JavaPackage
	}
	return ""
}

func (x *FileOptions) GetJavaOuterClassname() string {
	if x != nil && x.JavaOuterClassname != nil {
		return *x.JavaOuterClassname
	}
	return ""
}

func (x *FileOptions) GetJavaMultipleFiles() bool {
	if x != nil && x.JavaMultipleFiles != nil {
		return *x.JavaMultipleFiles
	}
	return Default_FileOptions_JavaMultipleFiles
}

// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
func (x *FileOptions) GetJavaGenerateEqualsAndHash() bool {
	if x != nil && x.JavaGenerateEqualsAndHash != nil {
		return *x.JavaGenerateEqualsAndHash
	}
	return false
}

func (x *FileOptions) GetJavaStringCheckUtf8() bool {
	if x != nil && x.JavaStringCheckUtf8 != nil {
		return *x.JavaStringCheckUtf8
	}
	return Default_FileOptions_JavaStringCheckUtf8
}

func (x *FileOptions) GetOptimizeFor() FileOptions_OptimizeMode {
	if x != nil && x.OptimizeFor != nil {
		return *x.OptimizeFor
	}
	return Default_FileOptions_OptimizeFor
}

func (x *FileOptions) GetGoPackage() string {
	if x != nil && x.GoPackage != nil {
		return *x.GoPackage
	}
	return ""
}

func (x *FileOptions) GetCcGenericServices() bool {
	if x != nil && x.CcGenericServices != nil {
		return *x.CcGenericServices
	}
	return Default_FileOptions_CcGenericServices
}

func (x *FileOptions) GetJavaGenericServices() bool {
	if x != nil && x.JavaGenericServices != nil {
		return *x.JavaGenericServices
	}
	return Default_FileOptions_JavaGenericServices
}

func (x *FileOptions) GetPyGenericServices() bool {
	if x != nil && x.PyGenericServices != nil {
		return *x.PyGenericServices
	}
	return Default_FileOptions_PyGenericServices
}

func (x *FileOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_FileOptions_Deprecated
}

func (x *FileOptions) GetCcEnableArenas() bool {
	if x != nil && x.CcEnableArenas != nil {
		return *x.CcEnableArenas
	}
	return Default_FileOptions_CcEnableArenas
}

func (x *FileOptions) GetObjcClassPrefix() string {
	if x != nil && x.ObjcClassPrefix != nil {
		return *x.ObjcClassPrefix
	}
	return ""
}

func (x *FileOptions) GetCsharpNamespace() string {
	if x != nil && x.CsharpNamespace != nil {
		return *x.CsharpNamespace
	}
	return ""
}

func (x *FileOptions) GetSwiftPrefix() string {
	if x != nil && x.SwiftPrefix != nil {
		return *x.SwiftPrefix
	}
	return ""
}

func (x *FileOptions) GetPhpClassPrefix() string {
	if x != nil && x.PhpClassPrefix != nil {
		return *x.PhpClassPrefix
	}
	return ""
}

func (x *FileOptions) GetPhpNamespace() string {
	if x != nil && x.PhpNamespace != nil {
		return *x.PhpNamespace
	}
	return ""
}

func (x *FileOptions) GetPhpMetadataNamespace() string {
	if x != nil && x.PhpMetadataNamespace != nil {
		return *x.PhpMetadataNamespace
	}
	return ""
}

func (x *FileOptions) GetRubyPackage() string {
	if x != nil && x.RubyPackage != nil {
		return *x.RubyPackage
	}
	return ""
}

func (x *FileOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *FileOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type MessageOptions struct {
	unknownFields []byte
	// Set true to use the old proto1 MessageSet wire format for extensions.
	// This is provided for backwards-compatibility with the MessageSet wire
	// format.  You should not use this for any other reason:  It's less
	// efficient, has fewer features, and is more complicated.
	//
	// The message must be defined exactly as follows:
	//
	//	message Foo {
	//	  option message_set_wire_format = true;
	//	  extensions 4 to max;
	//	}
	//
	// Note that the message cannot have any defined fields; MessageSets only
	// have extensions.
	//
	// All extensions of your type must be singular messages; e.g. they cannot
	// be int32s, enums, or repeated messages.
	//
	// Because this is an option, the above two restrictions are not enforced by
	// the protocol compiler.
	MessageSetWireFormat *bool `protobuf:"varint,1,opt,name=message_set_wire_format,json=messageSetWireFormat,def=0" json:"message_set_wire_format,omitempty"`
	// Disables the generation of the standard "descriptor()" accessor, which can
	// conflict with a field of the same name.  This is meant to make migration
	// from proto1 easier; new code should avoid fields named "descriptor".
	NoStandardDescriptorAccessor *bool `protobuf:"varint,2,opt,name=no_standard_descriptor_accessor,json=noStandardDescriptorAccessor,def=0" json:"no_standard_descriptor_accessor,omitempty"`
	// Is this message deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the message, or it will be completely ignored; in the very least,
	// this is a formalization for deprecating messages.
	Deprecated *bool `protobuf:"varint,3,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// Whether the message is an automatically generated map entry type for the
	// maps field.
	//
	// For maps fields:
	//
	//	map<KeyType, ValueType> map_field = 1;
	//
	// The parsed descriptor looks like:
	//
	//	message MapFieldEntry {
	//	    option map_entry = true;
	//	    optional KeyType key = 1;
	//	    optional ValueType value = 2;
	//	}
	//	repeated MapFieldEntry map_field = 1;
	//
	// Implementations may choose not to generate the map_entry=true message, but
	// use a native map in the target language to hold the keys and values.
	// The reflection APIs in such implementations still need to work as
	// if the field is a repeated message field.
	//
	// NOTE: Do not set the option in .proto files. Always use the maps syntax
	// instead. The option should only be implicitly set by the proto compiler
	// parser.
	MapEntry *bool `protobuf:"varint,7,opt,name=map_entry,json=mapEntry" json:"map_entry,omitempty"`
	// Enable the legacy handling of JSON field name conflicts.  This lowercases
	// and strips underscored from the fields before comparison in proto3 only.
	// The new behavior takes `json_name` into account and applies to proto2 as
	// well.
	//
	// This should only be used as a temporary measure against broken builds due
	// to the change in behavior for JSON field name conflicts.
	//
	// TODO This is legacy behavior we plan to remove once downstream
	// teams have had time to migrate.
	//
	// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
	DeprecatedLegacyJsonFieldConflicts *bool `protobuf:"varint,11,opt,name=deprecated_legacy_json_field_conflicts,json=deprecatedLegacyJsonFieldConflicts" json:"deprecated_legacy_json_field_conflicts,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,12,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
}

// Default values for MessageOptions fields.
const (
	Default_MessageOptions_MessageSetWireFormat         = bool(false)
	Default_MessageOptions_NoStandardDescriptorAccessor = bool(false)
	Default_MessageOptions_Deprecated                   = bool(false)
)

func (x *MessageOptions) Reset() {
	*x = MessageOptions{}
}

func (*MessageOptions) ProtoMessage() {}

func (x *MessageOptions) GetMessageSetWireFormat() bool {
	if x != nil && x.MessageSetWireFormat != nil {
		return *x.MessageSetWireFormat
	}
	return Default_MessageOptions_MessageSetWireFormat
}

func (x *MessageOptions) GetNoStandardDescriptorAccessor() bool {
	if x != nil && x.NoStandardDescriptorAccessor != nil {
		return *x.NoStandardDescriptorAccessor
	}
	return Default_MessageOptions_NoStandardDescriptorAccessor
}

func (x *MessageOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_MessageOptions_Deprecated
}

func (x *MessageOptions) GetMapEntry() bool {
	if x != nil && x.MapEntry != nil {
		return *x.MapEntry
	}
	return false
}

// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
func (x *MessageOptions) GetDeprecatedLegacyJsonFieldConflicts() bool {
	if x != nil && x.DeprecatedLegacyJsonFieldConflicts != nil {
		return *x.DeprecatedLegacyJsonFieldConflicts
	}
	return false
}

func (x *MessageOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *MessageOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type FieldOptions struct {
	unknownFields []byte
	// The ctype option instructs the C++ code generator to use a different
	// representation of the field than it normally would.  See the specific
	// options below.  This option is only implemented to support use of
	// [ctype=CORD] and [ctype=STRING] (the default) on non-repeated fields of
	// type "bytes" in the open source release -- sorry, we'll try to include
	// other types in a future version!
	Ctype *FieldOptions_CType `protobuf:"varint,1,opt,name=ctype,def=0" json:"ctype,omitempty"`
	// The packed option can be enabled for repeated primitive fields to enable
	// a more efficient representation on the wire. Rather than repeatedly
	// writing the tag and type for each element, the entire array is encoded as
	// a single length-delimited blob. In proto3, only explicit setting it to
	// false will avoid using packed encoding.  This option is prohibited in
	// Editions, but the `repeated_field_encoding` feature can be used to control
	// the behavior.
	Packed *bool `protobuf:"varint,2,opt,name=packed" json:"packed,omitempty"`
	// The jstype option determines the JavaScript type used for values of the
	// field.  The option is permitted only for 64 bit integral and fixed types
	// (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
	// is represented as JavaScript string, which avoids loss of precision that
	// can happen when a large value is converted to a floating point JavaScript.
	// Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
	// use the JavaScript "number" type.  The behavior of the default option
	// JS_NORMAL is implementation dependent.
	//
	// This option is an enum to permit additional types to be added, e.g.
	// goog.math.Integer.
	Jstype *FieldOptions_JSType `protobuf:"varint,6,opt,name=jstype,def=0" json:"jstype,omitempty"`
	// Should this field be parsed lazily?  Lazy applies only to message-type
	// fields.  It means that when the outer message is initially parsed, the
	// inner message's contents will not be parsed but instead stored in encoded
	// form.  The inner message will actually be parsed when it is first accessed.
	//
	// This is only a hint.  Implementations are free to choose whether to use
	// eager or lazy parsing regardless of the value of this option.  However,
	// setting this option true suggests that the protocol author believes that
	// using lazy parsing on this field is worth the additional bookkeeping
	// overhead typically needed to implement it.
	//
	// This option does not affect the public interface of any generated code;
	// all method signatures remain the same.  Furthermore, thread-safety of the
	// interface is not affected by this option; const methods remain safe to
	// call from multiple threads concurrently, while non-const methods continue
	// to require exclusive access.
	//
	// Note that lazy message fields are still eagerly verified to check
	// ill-formed wireformat or missing required fields. Calling IsInitialized()
	// on the outer message would fail if the inner message has missing required
	// fields. Failed verification would result in parsing failure (except when
	// uninitialized messages are acceptable).
	Lazy *bool `protobuf:"varint,5,opt,name=lazy,def=0" json:"lazy,omitempty"`
	// unverified_lazy does no correctness checks on the byte stream. This should
	// only be used where lazy with verification is prohibitive for performance
	// reasons.
	UnverifiedLazy *bool `protobuf:"varint,15,opt,name=unverified_lazy,json=unverifiedLazy,def=0" json:"unverified_lazy,omitempty"`
	// Is this field deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for accessors, or it will be completely ignored; in the very least, this
	// is a formalization for deprecating fields.
	Deprecated *bool `protobuf:"varint,3,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// For Google-internal migration only. Do not use.
	Weak *bool `protobuf:"varint,10,opt,name=weak,def=0" json:"weak,omitempty"`
	// Indicate that the field value should not be printed out when using debug
	// formats, e.g. when the field contains sensitive credentials.
	DebugRedact     *bool                           `protobuf:"varint,16,opt,name=debug_redact,json=debugRedact,def=0" json:"debug_redact,omitempty"`
	Retention       *FieldOptions_OptionRetention   `protobuf:"varint,17,opt,name=retention" json:"retention,omitempty"`
	Targets         []FieldOptions_OptionTargetType `protobuf:"varint,19,rep,name=targets" json:"targets,omitempty"`
	EditionDefaults []*FieldOptions_EditionDefault  `protobuf:"bytes,20,rep,name=edition_defaults,json=editionDefaults" json:"edition_defaults,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,21,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
}

// Default values for FieldOptions fields.
const (
	Default_FieldOptions_Ctype          = FieldOptions_STRING
	Default_FieldOptions_Jstype         = FieldOptions_JS_NORMAL
	Default_FieldOptions_Lazy           = bool(false)
	Default_FieldOptions_UnverifiedLazy = bool(false)
	Default_FieldOptions_Deprecated     = bool(false)
	Default_FieldOptions_Weak           = bool(false)
	Default_FieldOptions_DebugRedact    = bool(false)
)

func (x *FieldOptions) Reset() {
	*x = FieldOptions{}
}

func (*FieldOptions) ProtoMessage() {}

func (x *FieldOptions) GetCtype() FieldOptions_CType {
	if x != nil && x.Ctype != nil {
		return *x.Ctype
	}
	return Default_FieldOptions_Ctype
}

func (x *FieldOptions) GetPacked() bool {
	if x != nil && x.Packed != nil {
		return *x.Packed
	}
	return false
}

func (x *FieldOptions) GetJstype() FieldOptions_JSType {
	if x != nil && x.Jstype != nil {
		return *x.Jstype
	}
	return Default_FieldOptions_Jstype
}

func (x *FieldOptions) GetLazy() bool {
	if x != nil && x.Lazy != nil {
		return *x.Lazy
	}
	return Default_FieldOptions_Lazy
}

func (x *FieldOptions) GetUnverifiedLazy() bool {
	if x != nil && x.UnverifiedLazy != nil {
		return *x.UnverifiedLazy
	}
	return Default_FieldOptions_UnverifiedLazy
}

func (x *FieldOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_FieldOptions_Deprecated
}

func (x *FieldOptions) GetWeak() bool {
	if x != nil && x.Weak != nil {
		return *x.Weak
	}
	return Default_FieldOptions_Weak
}

func (x *FieldOptions) GetDebugRedact() bool {
	if x != nil && x.DebugRedact != nil {
		return *x.DebugRedact
	}
	return Default_FieldOptions_DebugRedact
}

func (x *FieldOptions) GetRetention() FieldOptions_OptionRetention {
	if x != nil && x.Retention != nil {
		return *x.Retention
	}
	return FieldOptions_RETENTION_UNKNOWN
}

func (x *FieldOptions) GetTargets() []FieldOptions_OptionTargetType {
	if x != nil {
		return x.Targets
	}
	return nil
}

func (x *FieldOptions) GetEditionDefaults() []*FieldOptions_EditionDefault {
	if x != nil {
		return x.EditionDefaults
	}
	return nil
}

func (x *FieldOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *FieldOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type OneofOptions struct {
	unknownFields []byte
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,1,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
}

func (x *OneofOptions) Reset() {
	*x = OneofOptions{}
}

func (*OneofOptions) ProtoMessage() {}

func (x *OneofOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *OneofOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type EnumOptions struct {
	unknownFields []byte
	// Set this option to true to allow mapping different tag names to the same
	// value.
	AllowAlias *bool `protobuf:"varint,2,opt,name=allow_alias,json=allowAlias" json:"allow_alias,omitempty"`
	// Is this enum deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the enum, or it will be completely ignored; in the very least, this
	// is a formalization for deprecating enums.
	Deprecated *bool `protobuf:"varint,3,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// Enable the legacy handling of JSON field name conflicts.  This lowercases
	// and strips underscored from the fields before comparison in proto3 only.
	// The new behavior takes `json_name` into account and applies to proto2 as
	// well.
	// TODO Remove this legacy behavior once downstream teams have
	// had time to migrate.
	//
	// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
	DeprecatedLegacyJsonFieldConflicts *bool `protobuf:"varint,6,opt,name=deprecated_legacy_json_field_conflicts,json=deprecatedLegacyJsonFieldConflicts" json:"deprecated_legacy_json_field_conflicts,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,7,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
}

// Default values for EnumOptions fields.
const (
	Default_EnumOptions_Deprecated = bool(false)
)

func (x *EnumOptions) Reset() {
	*x = EnumOptions{}
}

func (*EnumOptions) ProtoMessage() {}

func (x *EnumOptions) GetAllowAlias() bool {
	if x != nil && x.AllowAlias != nil {
		return *x.AllowAlias
	}
	return false
}

func (x *EnumOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_EnumOptions_Deprecated
}

// Deprecated: Marked as deprecated in github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb/descriptor.proto.
func (x *EnumOptions) GetDeprecatedLegacyJsonFieldConflicts() bool {
	if x != nil && x.DeprecatedLegacyJsonFieldConflicts != nil {
		return *x.DeprecatedLegacyJsonFieldConflicts
	}
	return false
}

func (x *EnumOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *EnumOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type EnumValueOptions struct {
	unknownFields []byte
	// Is this enum value deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the enum value, or it will be completely ignored; in the very least,
	// this is a formalization for deprecating enum values.
	Deprecated *bool `protobuf:"varint,1,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,2,opt,name=features" json:"features,omitempty"`
	// Indicate that fields annotated with this enum value should not be printed
	// out when using debug formats, e.g. when the field contains sensitive
	// credentials.
	DebugRedact *bool `protobuf:"varint,3,opt,name=debug_redact,json=debugRedact,def=0" json:"debug_redact,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
}

// Default values for EnumValueOptions fields.
const (
	Default_EnumValueOptions_Deprecated  = bool(false)
	Default_EnumValueOptions_DebugRedact = bool(false)
)

func (x *EnumValueOptions) Reset() {
	*x = EnumValueOptions{}
}

func (*EnumValueOptions) ProtoMessage() {}

func (x *EnumValueOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_EnumValueOptions_Deprecated
}

func (x *EnumValueOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *EnumValueOptions) GetDebugRedact() bool {
	if x != nil && x.DebugRedact != nil {
		return *x.DebugRedact
	}
	return Default_EnumValueOptions_DebugRedact
}

func (x *EnumValueOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type ServiceOptions struct {
	unknownFields []byte
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,34,opt,name=features" json:"features,omitempty"`
	// Is this service deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the service, or it will be completely ignored; in the very least,
	// this is a formalization for deprecating services.
	Deprecated *bool `protobuf:"varint,33,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
}

// Default values for ServiceOptions fields.
const (
	Default_ServiceOptions_Deprecated = bool(false)
)

func (x *ServiceOptions) Reset() {
	*x = ServiceOptions{}
}

func (*ServiceOptions) ProtoMessage() {}

func (x *ServiceOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *ServiceOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_ServiceOptions_Deprecated
}

func (x *ServiceOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

type MethodOptions struct {
	unknownFields []byte
	// Is this method deprecated?
	// Depending on the target platform, this can emit Deprecated annotations
	// for the method, or it will be completely ignored; in the very least,
	// this is a formalization for deprecating methods.
	Deprecated       *bool                           `protobuf:"varint,33,opt,name=deprecated,def=0" json:"deprecated,omitempty"`
	IdempotencyLevel *MethodOptions_IdempotencyLevel `protobuf:"varint,34,opt,name=idempotency_level,json=idempotencyLevel,def=0" json:"idempotency_level,omitempty"`
	// Any features defined in the specific edition.
	Features *FeatureSet `protobuf:"bytes,35,opt,name=features" json:"features,omitempty"`
	// The parser stores options it doesn't recognize here. See above.
	UninterpretedOption []*UninterpretedOption `protobuf:"bytes,999,rep,name=uninterpreted_option,json=uninterpretedOption" json:"uninterpreted_option,omitempty"`
}

// Default values for MethodOptions fields.
const (
	Default_MethodOptions_Deprecated       = bool(false)
	Default_MethodOptions_IdempotencyLevel = MethodOptions_IDEMPOTENCY_UNKNOWN
)

func (x *MethodOptions) Reset() {
	*x = MethodOptions{}
}

func (*MethodOptions) ProtoMessage() {}

func (x *MethodOptions) GetDeprecated() bool {
	if x != nil && x.Deprecated != nil {
		return *x.Deprecated
	}
	return Default_MethodOptions_Deprecated
}

func (x *MethodOptions) GetIdempotencyLevel() MethodOptions_IdempotencyLevel {
	if x != nil && x.IdempotencyLevel != nil {
		return *x.IdempotencyLevel
	}
	return Default_MethodOptions_IdempotencyLevel
}

func (x *MethodOptions) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

func (x *MethodOptions) GetUninterpretedOption() []*UninterpretedOption {
	if x != nil {
		return x.UninterpretedOption
	}
	return nil
}

// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
type UninterpretedOption struct {
	unknownFields []byte
	Name          []*UninterpretedOption_NamePart `protobuf:"bytes,2,rep,name=name" json:"name,omitempty"`
	// The value of the uninterpreted option, in whatever type the tokenizer
	// identified it as during parsing. Exactly one of these should be set.
	IdentifierValue  *string  `protobuf:"bytes,3,opt,name=identifier_value,json=identifierValue" json:"identifier_value,omitempty"`
	PositiveIntValue *uint64  `protobuf:"varint,4,opt,name=positive_int_value,json=positiveIntValue" json:"positive_int_value,omitempty"`
	NegativeIntValue *int64   `protobuf:"varint,5,opt,name=negative_int_value,json=negativeIntValue" json:"negative_int_value,omitempty"`
	DoubleValue      *float64 `protobuf:"fixed64,6,opt,name=double_value,json=doubleValue" json:"double_value,omitempty"`
	StringValue      []byte   `protobuf:"bytes,7,opt,name=string_value,json=stringValue" json:"string_value,omitempty"`
	AggregateValue   *string  `protobuf:"bytes,8,opt,name=aggregate_value,json=aggregateValue" json:"aggregate_value,omitempty"`
}

func (x *UninterpretedOption) Reset() {
	*x = UninterpretedOption{}
}

func (*UninterpretedOption) ProtoMessage() {}

func (x *UninterpretedOption) GetName() []*UninterpretedOption_NamePart {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *UninterpretedOption) GetIdentifierValue() string {
	if x != nil && x.IdentifierValue != nil {
		return *x.IdentifierValue
	}
	return ""
}

func (x *UninterpretedOption) GetPositiveIntValue() uint64 {
	if x != nil && x.PositiveIntValue != nil {
		return *x.PositiveIntValue
	}
	return 0
}

func (x *UninterpretedOption) GetNegativeIntValue() int64 {
	if x != nil && x.NegativeIntValue != nil {
		return *x.NegativeIntValue
	}
	return 0
}

func (x *UninterpretedOption) GetDoubleValue() float64 {
	if x != nil && x.DoubleValue != nil {
		return *x.DoubleValue
	}
	return 0
}

func (x *UninterpretedOption) GetStringValue() []byte {
	if x != nil {
		return x.StringValue
	}
	return nil
}

func (x *UninterpretedOption) GetAggregateValue() string {
	if x != nil && x.AggregateValue != nil {
		return *x.AggregateValue
	}
	return ""
}

// TODO Enums in C++ gencode (and potentially other languages) are
// not well scoped.  This means that each of the feature enums below can clash
// with each other.  The short names we've chosen maximize call-site
// readability, but leave us very open to this scenario.  A future feature will
// be designed and implemented to handle this, hopefully before we ever hit a
// conflict here.
type FeatureSet struct {
	unknownFields         []byte
	FieldPresence         *FeatureSet_FieldPresence         `protobuf:"varint,1,opt,name=field_presence,json=fieldPresence" json:"field_presence,omitempty"`
	EnumType              *FeatureSet_EnumType              `protobuf:"varint,2,opt,name=enum_type,json=enumType" json:"enum_type,omitempty"`
	RepeatedFieldEncoding *FeatureSet_RepeatedFieldEncoding `protobuf:"varint,3,opt,name=repeated_field_encoding,json=repeatedFieldEncoding" json:"repeated_field_encoding,omitempty"`
	Utf8Validation        *FeatureSet_Utf8Validation        `protobuf:"varint,4,opt,name=utf8_validation,json=utf8Validation" json:"utf8_validation,omitempty"`
	MessageEncoding       *FeatureSet_MessageEncoding       `protobuf:"varint,5,opt,name=message_encoding,json=messageEncoding" json:"message_encoding,omitempty"`
	JsonFormat            *FeatureSet_JsonFormat            `protobuf:"varint,6,opt,name=json_format,json=jsonFormat" json:"json_format,omitempty"`
}

func (x *FeatureSet) Reset() {
	*x = FeatureSet{}
}

func (*FeatureSet) ProtoMessage() {}

func (x *FeatureSet) GetFieldPresence() FeatureSet_FieldPresence {
	if x != nil && x.FieldPresence != nil {
		return *x.FieldPresence
	}
	return FeatureSet_FIELD_PRESENCE_UNKNOWN
}

func (x *FeatureSet) GetEnumType() FeatureSet_EnumType {
	if x != nil && x.EnumType != nil {
		return *x.EnumType
	}
	return FeatureSet_ENUM_TYPE_UNKNOWN
}

func (x *FeatureSet) GetRepeatedFieldEncoding() FeatureSet_RepeatedFieldEncoding {
	if x != nil && x.RepeatedFieldEncoding != nil {
		return *x.RepeatedFieldEncoding
	}
	return FeatureSet_REPEATED_FIELD_ENCODING_UNKNOWN
}

func (x *FeatureSet) GetUtf8Validation() FeatureSet_Utf8Validation {
	if x != nil && x.Utf8Validation != nil {
		return *x.Utf8Validation
	}
	return FeatureSet_UTF8_VALIDATION_UNKNOWN
}

func (x *FeatureSet) GetMessageEncoding() FeatureSet_MessageEncoding {
	if x != nil && x.MessageEncoding != nil {
		return *x.MessageEncoding
	}
	return FeatureSet_MESSAGE_ENCODING_UNKNOWN
}

func (x *FeatureSet) GetJsonFormat() FeatureSet_JsonFormat {
	if x != nil && x.JsonFormat != nil {
		return *x.JsonFormat
	}
	return FeatureSet_JSON_FORMAT_UNKNOWN
}

// A compiled specification for the defaults of a set of features.  These
// messages are generated from FeatureSet extensions and can be used to seed
// feature resolution. The resolution with this object becomes a simple search
// for the closest matching edition, followed by proto merges.
type FeatureSetDefaults struct {
	unknownFields []byte
	Defaults      []*FeatureSetDefaults_FeatureSetEditionDefault `protobuf:"bytes,1,rep,name=defaults" json:"defaults,omitempty"`
	// The minimum supported edition (inclusive) when this was constructed.
	// Editions before this will not have defaults.
	MinimumEdition *Edition `protobuf:"varint,4,opt,name=minimum_edition,json=minimumEdition" json:"minimum_edition,omitempty"`
	// The maximum known edition (inclusive) when this was constructed. Editions
	// after this will not have reliable defaults.
	MaximumEdition *Edition `protobuf:"varint,5,opt,name=maximum_edition,json=maximumEdition" json:"maximum_edition,omitempty"`
}

func (x *FeatureSetDefaults) Reset() {
	*x = FeatureSetDefaults{}
}

func (*FeatureSetDefaults) ProtoMessage() {}

func (x *FeatureSetDefaults) GetDefaults() []*FeatureSetDefaults_FeatureSetEditionDefault {
	if x != nil {
		return x.Defaults
	}
	return nil
}

func (x *FeatureSetDefaults) GetMinimumEdition() Edition {
	if x != nil && x.MinimumEdition != nil {
		return *x.MinimumEdition
	}
	return Edition_EDITION_UNKNOWN
}

func (x *FeatureSetDefaults) GetMaximumEdition() Edition {
	if x != nil && x.MaximumEdition != nil {
		return *x.MaximumEdition
	}
	return Edition_EDITION_UNKNOWN
}

// Encapsulates information about the original source file from which a
// FileDescriptorProto was generated.
type SourceCodeInfo struct {
	unknownFields []byte
	// A Location identifies a piece of source code in a .proto file which
	// corresponds to a particular definition.  This information is intended
	// to be useful to IDEs, code indexers, documentation generators, and similar
	// tools.
	//
	// For example, say we have a file like:
	//
	//	message Foo {
	//	  optional string foo = 1;
	//	}
	//
	// Let's look at just the field definition:
	//
	//	optional string foo = 1;
	//	^       ^^     ^^  ^  ^^^
	//	a       bc     de  f  ghi
	//
	// We have the following locations:
	//
	//	span   path               represents
	//	[a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
	//	[a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
	//	[c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
	//	[e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
	//	[g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
	//
	// Notes:
	//   - A location may refer to a repeated field itself (i.e. not to any
	//     particular index within it).  This is used whenever a set of elements are
	//     logically enclosed in a single code segment.  For example, an entire
	//     extend block (possibly containing multiple extension definitions) will
	//     have an outer location whose path refers to the "extensions" repeated
	//     field without an index.
	//   - Multiple locations may have the same path.  This happens when a single
	//     logical declaration is spread out across multiple places.  The most
	//     obvious example is the "extend" block again -- there may be multiple
	//     extend blocks in the same scope, each of which will have the same path.
	//   - A location's span is not always a subset of its parent's span.  For
	//     example, the "extendee" of an extension declaration appears at the
	//     beginning of the "extend" block and is shared by all extensions within
	//     the block.
	//   - Just because a location's span is a subset of some other location's span
	//     does not mean that it is a descendant.  For example, a "group" defines
	//     both a type and a field in a single declaration.  Thus, the locations
	//     corresponding to the type and field and their components will overlap.
	//   - Code which tries to interpret locations should probably be designed to
	//     ignore those that it doesn't understand, as more types of locations could
	//     be recorded in the future.
	Location []*SourceCodeInfo_Location `protobuf:"bytes,1,rep,name=location" json:"location,omitempty"`
}

func (x *SourceCodeInfo) Reset() {
	*x = SourceCodeInfo{}
}

func (*SourceCodeInfo) ProtoMessage() {}

func (x *SourceCodeInfo) GetLocation() []*SourceCodeInfo_Location {
	if x != nil {
		return x.Location
	}
	return nil
}

// Describes the relationship between generated code and its original source
// file. A GeneratedCodeInfo message is associated with only one generated
// source file, but may contain references to different source .proto files.
type GeneratedCodeInfo struct {
	unknownFields []byte
	// An Annotation connects some span of text in generated code to an element
	// of its generating .proto file.
	Annotation []*GeneratedCodeInfo_Annotation `protobuf:"bytes,1,rep,name=annotation" json:"annotation,omitempty"`
}

func (x *GeneratedCodeInfo) Reset() {
	*x = GeneratedCodeInfo{}
}

func (*GeneratedCodeInfo) ProtoMessage() {}

func (x *GeneratedCodeInfo) GetAnnotation() []*GeneratedCodeInfo_Annotation {
	if x != nil {
		return x.Annotation
	}
	return nil
}

type DescriptorProto_ExtensionRange struct {
	unknownFields []byte
	Start         *int32                 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"` // Inclusive.
	End           *int32                 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`     // Exclusive.
	Options       *ExtensionRangeOptions `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
}

func (x *DescriptorProto_ExtensionRange) Reset() {
	*x = DescriptorProto_ExtensionRange{}
}

func (*DescriptorProto_ExtensionRange) ProtoMessage() {}

func (x *DescriptorProto_ExtensionRange) GetStart() int32 {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return 0
}

func (x *DescriptorProto_ExtensionRange) GetEnd() int32 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

func (x *DescriptorProto_ExtensionRange) GetOptions() *ExtensionRangeOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Range of reserved tag numbers. Reserved tag numbers may not be used by
// fields or extension ranges in the same message. Reserved ranges may
// not overlap.
type DescriptorProto_ReservedRange struct {
	unknownFields []byte
	Start         *int32 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"` // Inclusive.
	End           *int32 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`     // Exclusive.
}

func (x *DescriptorProto_ReservedRange) Reset() {
	*x = DescriptorProto_ReservedRange{}
}

func (*DescriptorProto_ReservedRange) ProtoMessage() {}

func (x *DescriptorProto_ReservedRange) GetStart() int32 {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return 0
}

func (x *DescriptorProto_ReservedRange) GetEnd() int32 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

type ExtensionRangeOptions_Declaration struct {
	unknownFields []byte
	// The extension number declared within the extension range.
	Number *int32 `protobuf:"varint,1,opt,name=number" json:"number,omitempty"`
	// The fully-qualified name of the extension field. There must be a leading
	// dot in front of the full name.
	FullName *string `protobuf:"bytes,2,opt,name=full_name,json=fullName" json:"full_name,omitempty"`
	// The fully-qualified type name of the extension field. Unlike
	// Metadata.type, Declaration.type must have a leading dot for messages
	// and enums.
	Type *string `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	// If true, indicates that the number is reserved in the extension range,
	// and any extension field with the number will fail to compile. Set this
	// when a declared extension field is deleted.
	Reserved *bool `protobuf:"varint,5,opt,name=reserved" json:"reserved,omitempty"`
	// If true, indicates that the extension must be defined as repeated.
	// Otherwise the extension must be defined as optional.
	Repeated *bool `protobuf:"varint,6,opt,name=repeated" json:"repeated,omitempty"`
}

func (x *ExtensionRangeOptions_Declaration) Reset() {
	*x = ExtensionRangeOptions_Declaration{}
}

func (*ExtensionRangeOptions_Declaration) ProtoMessage() {}

func (x *ExtensionRangeOptions_Declaration) GetNumber() int32 {
	if x != nil && x.Number != nil {
		return *x.Number
	}
	return 0
}

func (x *ExtensionRangeOptions_Declaration) GetFullName() string {
	if x != nil && x.FullName != nil {
		return *x.FullName
	}
	return ""
}

func (x *ExtensionRangeOptions_Declaration) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

func (x *ExtensionRangeOptions_Declaration) GetReserved() bool {
	if x != nil && x.Reserved != nil {
		return *x.Reserved
	}
	return false
}

func (x *ExtensionRangeOptions_Declaration) GetRepeated() bool {
	if x != nil && x.Repeated != nil {
		return *x.Repeated
	}
	return false
}

// Range of reserved numeric values. Reserved values may not be used by
// entries in the same enum. Reserved ranges may not overlap.
//
// Note that this is distinct from DescriptorProto.ReservedRange in that it
// is inclusive such that it can appropriately represent the entire int32
// domain.
type EnumDescriptorProto_EnumReservedRange struct {
	unknownFields []byte
	Start         *int32 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"` // Inclusive.
	End           *int32 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`     // Inclusive.
}

func (x *EnumDescriptorProto_EnumReservedRange) Reset() {
	*x = EnumDescriptorProto_EnumReservedRange{}
}

func (*EnumDescriptorProto_EnumReservedRange) ProtoMessage() {}

func (x *EnumDescriptorProto_EnumReservedRange) GetStart() int32 {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return 0
}

func (x *EnumDescriptorProto_EnumReservedRange) GetEnd() int32 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

type FieldOptions_EditionDefault struct {
	unknownFields []byte
	Edition       *Edition `protobuf:"varint,3,opt,name=edition" json:"edition,omitempty"`
	Value         *string  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"` // Textproto value.
}

func (x *FieldOptions_EditionDefault) Reset() {
	*x = FieldOptions_EditionDefault{}
}

func (*FieldOptions_EditionDefault) ProtoMessage() {}

func (x *FieldOptions_EditionDefault) GetEdition() Edition {
	if x != nil && x.Edition != nil {
		return *x.Edition
	}
	return Edition_EDITION_UNKNOWN
}

func (x *FieldOptions_EditionDefault) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

// The name of the uninterpreted option.  Each string represents a segment in
// a dot-separated name.  is_extension is true iff a segment represents an
// extension (denoted with parentheses in options specs in .proto files).
// E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
// "foo.(bar.baz).moo".
type UninterpretedOption_NamePart struct {
	unknownFields []byte
	NamePart      *string `protobuf:"bytes,1,req,name=name_part,json=namePart" json:"name_part,omitempty"`
	IsExtension   *bool   `protobuf:"varint,2,req,name=is_extension,json=isExtension" json:"is_extension,omitempty"`
}

func (x *UninterpretedOption_NamePart) Reset() {
	*x = UninterpretedOption_NamePart{}
}

func (*UninterpretedOption_NamePart) ProtoMessage() {}

func (x *UninterpretedOption_NamePart) GetNamePart() string {
	if x != nil && x.NamePart != nil {
		return *x.NamePart
	}
	return ""
}

func (x *UninterpretedOption_NamePart) GetIsExtension() bool {
	if x != nil && x.IsExtension != nil {
		return *x.IsExtension
	}
	return false
}

// A map from every known edition with a unique set of defaults to its
// defaults. Not all editions may be contained here.  For a given edition,
// the defaults at the closest matching edition ordered at or before it should
// be used.  This field must be in strict ascending order by edition.
type FeatureSetDefaults_FeatureSetEditionDefault struct {
	unknownFields []byte
	Edition       *Edition    `protobuf:"varint,3,opt,name=edition" json:"edition,omitempty"`
	Features      *FeatureSet `protobuf:"bytes,2,opt,name=features" json:"features,omitempty"`
}

func (x *FeatureSetDefaults_FeatureSetEditionDefault) Reset() {
	*x = FeatureSetDefaults_FeatureSetEditionDefault{}
}

func (*FeatureSetDefaults_FeatureSetEditionDefault) ProtoMessage() {}

func (x *FeatureSetDefaults_FeatureSetEditionDefault) GetEdition() Edition {
	if x != nil && x.Edition != nil {
		return *x.Edition
	}
	return Edition_EDITION_UNKNOWN
}

func (x *FeatureSetDefaults_FeatureSetEditionDefault) GetFeatures() *FeatureSet {
	if x != nil {
		return x.Features
	}
	return nil
}

type SourceCodeInfo_Location struct {
	unknownFields []byte
	// Identifies which part of the FileDescriptorProto was defined at this
	// location.
	//
	// Each element is a field number or an index.  They form a path from
	// the root FileDescriptorProto to the place where the definition appears.
	// For example, this path:
	//
	//	[ 4, 3, 2, 7, 1 ]
	//
	// refers to:
	//
	//	file.message_type(3)  // 4, 3
	//	    .field(7)         // 2, 7
	//	    .name()           // 1
	//
	// This is because FileDescriptorProto.message_type has field number 4:
	//
	//	repeated DescriptorProto message_type = 4;
	//
	// and DescriptorProto.field has field number 2:
	//
	//	repeated FieldDescriptorProto field = 2;
	//
	// and FieldDescriptorProto.name has field number 1:
	//
	//	optional string name = 1;
	//
	// Thus, the above path gives the location of a field name.  If we removed
	// the last element:
	//
	//	[ 4, 3, 2, 7 ]
	//
	// this path refers to the whole field declaration (from the beginning
	// of the label to the terminating semicolon).
	Path []int32 `protobuf:"varint,1,rep,packed,name=path" json:"path,omitempty"`
	// Always has exactly three or four elements: start line, start column,
	// end line (optional, otherwise assumed same as start line), end column.
	// These are packed into a single field for efficiency.  Note that line
	// and column numbers are zero-based -- typically you will want to add
	// 1 to each before displaying to a user.
	Span []int32 `protobuf:"varint,2,rep,packed,name=span" json:"span,omitempty"`
	// If this SourceCodeInfo represents a complete declaration, these are any
	// comments appearing before and after the declaration which appear to be
	// attached to the declaration.
	//
	// A series of line comments appearing on consecutive lines, with no other
	// tokens appearing on those lines, will be treated as a single comment.
	//
	// leading_detached_comments will keep paragraphs of comments that appear
	// before (but not connected to) the current element. Each paragraph,
	// separated by empty lines, will be one comment element in the repeated
	// field.
	//
	// Only the comment content is provided; comment markers (e.g. //) are
	// stripped out.  For block comments, leading whitespace and an asterisk
	// will be stripped from the beginning of each line other than the first.
	// Newlines are included in the output.
	//
	// Examples:
	//
	//	optional int32 foo = 1;  // Comment attached to foo.
	//	// Comment attached to bar.
	//	optional int32 bar = 2;
	//
	//	optional string baz = 3;
	//	// Comment attached to baz.
	//	// Another line attached to baz.
	//
	//	// Comment attached to moo.
	//	//
	//	// Another line attached to moo.
	//	optional double moo = 4;
	//
	//	// Detached comment for corge. This is not leading or trailing comments
	//	// to moo or corge because there are blank lines separating it from
	//	// both.
	//
	//	// Detached comment for corge paragraph 2.
	//
	//	optional string corge = 5;
	//	/* Block comment attached
	//	 * to corge.  Leading asterisks
	//	 * will be removed. */
	//	/* Block comment attached to
	//	 * grault. */
	//	optional int32 grault = 6;
	//
	//	// ignored detached comments.
	LeadingComments         *string  `protobuf:"bytes,3,opt,name=leading_comments,json=leadingComments" json:"leading_comments,omitempty"`
	TrailingComments        *string  `protobuf:"bytes,4,opt,name=trailing_comments,json=trailingComments" json:"trailing_comments,omitempty"`
	LeadingDetachedComments []string `protobuf:"bytes,6,rep,name=leading_detached_comments,json=leadingDetachedComments" json:"leading_detached_comments,omitempty"`
}

func (x *SourceCodeInfo_Location) Reset() {
	*x = SourceCodeInfo_Location{}
}

func (*SourceCodeInfo_Location) ProtoMessage() {}

func (x *SourceCodeInfo_Location) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *SourceCodeInfo_Location) GetSpan() []int32 {
	if x != nil {
		return x.Span
	}
	return nil
}

func (x *SourceCodeInfo_Location) GetLeadingComments() string {
	if x != nil && x.LeadingComments != nil {
		return *x.LeadingComments
	}
	return ""
}

func (x *SourceCodeInfo_Location) GetTrailingComments() string {
	if x != nil && x.TrailingComments != nil {
		return *x.TrailingComments
	}
	return ""
}

func (x *SourceCodeInfo_Location) GetLeadingDetachedComments() []string {
	if x != nil {
		return x.LeadingDetachedComments
	}
	return nil
}

type GeneratedCodeInfo_Annotation struct {
	unknownFields []byte
	// Identifies the element in the original source .proto file. This field
	// is formatted the same as SourceCodeInfo.Location.path.
	Path []int32 `protobuf:"varint,1,rep,packed,name=path" json:"path,omitempty"`
	// Identifies the filesystem path to the original source .proto.
	SourceFile *string `protobuf:"bytes,2,opt,name=source_file,json=sourceFile" json:"source_file,omitempty"`
	// Identifies the starting offset in bytes in the generated code
	// that relates to the identified object.
	Begin *int32 `protobuf:"varint,3,opt,name=begin" json:"begin,omitempty"`
	// Identifies the ending offset in bytes in the generated code that
	// relates to the identified object. The end offset should be one past
	// the last relevant byte (so the length of the text = end - begin).
	End      *int32                                 `protobuf:"varint,4,opt,name=end" json:"end,omitempty"`
	Semantic *GeneratedCodeInfo_Annotation_Semantic `protobuf:"varint,5,opt,name=semantic" json:"semantic,omitempty"`
}

func (x *GeneratedCodeInfo_Annotation) Reset() {
	*x = GeneratedCodeInfo_Annotation{}
}

func (*GeneratedCodeInfo_Annotation) ProtoMessage() {}

func (x *GeneratedCodeInfo_Annotation) GetPath() []int32 {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *GeneratedCodeInfo_Annotation) GetSourceFile() string {
	if x != nil && x.SourceFile != nil {
		return *x.SourceFile
	}
	return ""
}

func (x *GeneratedCodeInfo_Annotation) GetBegin() int32 {
	if x != nil && x.Begin != nil {
		return *x.Begin
	}
	return 0
}

func (x *GeneratedCodeInfo_Annotation) GetEnd() int32 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

func (x *GeneratedCodeInfo_Annotation) GetSemantic() GeneratedCodeInfo_Annotation_Semantic {
	if x != nil && x.Semantic != nil {
		return *x.Semantic
	}
	return GeneratedCodeInfo_Annotation_NONE
}
