// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.8.1
// source: github.com/aperturerobotics/protobuf-go-lite/types/pluginpb/plugin.proto

package google_protobuf_compiler

import (
	fmt "fmt"
	io "io"
	slices "slices"
	strconv "strconv"
	strings "strings"
	unsafe "unsafe"

	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	descriptorpb "github.com/aperturerobotics/protobuf-go-lite/types/descriptorpb"
)

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

// Author: kenton@google.com (Kenton Varda)
//
// protoc (aka the Protocol Compiler) can be extended via plugins.  A plugin is
// just a program that reads a CodeGeneratorRequest from stdin and writes a
// CodeGeneratorResponse to stdout.
//
// Plugins written using C++ can use google/protobuf/compiler/plugin.h instead
// of dealing with the raw protocol defined here.
//
// A plugin executable needs only to be placed somewhere in the path.  The
// plugin should be named "protoc-gen-$NAME", and will then be used when the
// flag "--${NAME}_out" is passed to protoc.

// Sync with code_generator.h.
type CodeGeneratorResponse_Feature int32

const (
	CodeGeneratorResponse_FEATURE_NONE              CodeGeneratorResponse_Feature = 0
	CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL   CodeGeneratorResponse_Feature = 1
	CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS CodeGeneratorResponse_Feature = 2
)

// Enum value maps for CodeGeneratorResponse_Feature.
var (
	CodeGeneratorResponse_Feature_name = map[int32]string{
		0: "FEATURE_NONE",
		1: "FEATURE_PROTO3_OPTIONAL",
		2: "FEATURE_SUPPORTS_EDITIONS",
	}
	CodeGeneratorResponse_Feature_value = map[string]int32{
		"FEATURE_NONE":              0,
		"FEATURE_PROTO3_OPTIONAL":   1,
		"FEATURE_SUPPORTS_EDITIONS": 2,
	}
)

func (x CodeGeneratorResponse_Feature) Enum() *CodeGeneratorResponse_Feature {
	p := new(CodeGeneratorResponse_Feature)
	*p = x
	return p
}

func (x CodeGeneratorResponse_Feature) String() string {
	name, valid := CodeGeneratorResponse_Feature_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// The version number of protocol compiler.
type Version struct {
	unknownFields []byte
	Major         *int32 `protobuf:"varint,1,opt,name=major" json:"major,omitempty"`
	Minor         *int32 `protobuf:"varint,2,opt,name=minor" json:"minor,omitempty"`
	Patch         *int32 `protobuf:"varint,3,opt,name=patch" json:"patch,omitempty"`
	// A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
	// be empty for mainline stable releases.
	Suffix *string `protobuf:"bytes,4,opt,name=suffix" json:"suffix,omitempty"`
}

func (x *Version) Reset() {
	*x = Version{}
}

func (*Version) ProtoMessage() {}

func (x *Version) GetMajor() int32 {
	if x != nil && x.Major != nil {
		return *x.Major
	}
	return 0
}

func (x *Version) GetMinor() int32 {
	if x != nil && x.Minor != nil {
		return *x.Minor
	}
	return 0
}

func (x *Version) GetPatch() int32 {
	if x != nil && x.Patch != nil {
		return *x.Patch
	}
	return 0
}

func (x *Version) GetSuffix() string {
	if x != nil && x.Suffix != nil {
		return *x.Suffix
	}
	return ""
}

// An encoded CodeGeneratorRequest is written to the plugin's stdin.
type CodeGeneratorRequest struct {
	unknownFields []byte
	// The .proto files that were explicitly listed on the command-line.  The
	// code generator should generate code only for these files.  Each file's
	// descriptor will be included in proto_file, below.
	FileToGenerate []string `protobuf:"bytes,1,rep,name=file_to_generate,json=fileToGenerate" json:"fileToGenerate,omitempty"`
	// The generator parameter passed on the command-line.
	Parameter *string `protobuf:"bytes,2,opt,name=parameter" json:"parameter,omitempty"`
	// FileDescriptorProtos for all files in files_to_generate and everything
	// they import.  The files will appear in topological order, so each file
	// appears before any file that imports it.
	//
	// Note: the files listed in files_to_generate will include runtime-retention
	// options only, but all other files will include source-retention options.
	// The source_file_descriptors field below is available in case you need
	// source-retention options for files_to_generate.
	//
	// protoc guarantees that all proto_files will be written after
	// the fields above, even though this is not technically guaranteed by the
	// protobuf wire format.  This theoretically could allow a plugin to stream
	// in the FileDescriptorProtos and handle them one by one rather than read
	// the entire set into memory at once.  However, as of this writing, this
	// is not similarly optimized on protoc's end -- it will store all fields in
	// memory at once before sending them to the plugin.
	//
	// Type names of fields and extensions in the FileDescriptorProto are always
	// fully qualified.
	ProtoFile []*descriptorpb.FileDescriptorProto `protobuf:"bytes,15,rep,name=proto_file,json=protoFile" json:"protoFile,omitempty"`
	// File descriptors with all options, including source-retention options.
	// These descriptors are only provided for the files listed in
	// files_to_generate.
	SourceFileDescriptors []*descriptorpb.FileDescriptorProto `protobuf:"bytes,17,rep,name=source_file_descriptors,json=sourceFileDescriptors" json:"sourceFileDescriptors,omitempty"`
	// The version number of protocol compiler.
	CompilerVersion *Version `protobuf:"bytes,3,opt,name=compiler_version,json=compilerVersion" json:"compilerVersion,omitempty"`
}

func (x *CodeGeneratorRequest) Reset() {
	*x = CodeGeneratorRequest{}
}

func (*CodeGeneratorRequest) ProtoMessage() {}

func (x *CodeGeneratorRequest) GetFileToGenerate() []string {
	if x != nil {
		return x.FileToGenerate
	}
	return nil
}

func (x *CodeGeneratorRequest) GetParameter() string {
	if x != nil && x.Parameter != nil {
		return *x.Parameter
	}
	return ""
}

func (x *CodeGeneratorRequest) GetProtoFile() []*descriptorpb.FileDescriptorProto {
	if x != nil {
		return x.ProtoFile
	}
	return nil
}

func (x *CodeGeneratorRequest) GetSourceFileDescriptors() []*descriptorpb.FileDescriptorProto {
	if x != nil {
		return x.SourceFileDescriptors
	}
	return nil
}

func (x *CodeGeneratorRequest) GetCompilerVersion() *Version {
	if x != nil {
		return x.CompilerVersion
	}
	return nil
}

// The plugin writes an encoded CodeGeneratorResponse to stdout.
type CodeGeneratorResponse struct {
	unknownFields []byte
	// Error message.  If non-empty, code generation failed.  The plugin process
	// should exit with status code zero even if it reports an error in this way.
	//
	// This should be used to indicate errors in .proto files which prevent the
	// code generator from generating correct code.  Errors which indicate a
	// problem in protoc itself -- such as the input CodeGeneratorRequest being
	// unparseable -- should be reported by writing a message to stderr and
	// exiting with a non-zero status code.
	Error *string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// A bitmask of supported features that the code generator supports.
	// This is a bitwise "or" of values from the Feature enum.
	SupportedFeatures *uint64 `protobuf:"varint,2,opt,name=supported_features,json=supportedFeatures" json:"supportedFeatures,omitempty"`
	// The minimum edition this plugin supports.  This will be treated as an
	// Edition enum, but we want to allow unknown values.  It should be specified
	// according the edition enum value, *not* the edition number.  Only takes
	// effect for plugins that have FEATURE_SUPPORTS_EDITIONS set.
	MinimumEdition *int32 `protobuf:"varint,3,opt,name=minimum_edition,json=minimumEdition" json:"minimumEdition,omitempty"`
	// The maximum edition this plugin supports.  This will be treated as an
	// Edition enum, but we want to allow unknown values.  It should be specified
	// according the edition enum value, *not* the edition number.  Only takes
	// effect for plugins that have FEATURE_SUPPORTS_EDITIONS set.
	MaximumEdition *int32                        `protobuf:"varint,4,opt,name=maximum_edition,json=maximumEdition" json:"maximumEdition,omitempty"`
	File           []*CodeGeneratorResponse_File `protobuf:"bytes,15,rep,name=file" json:"file,omitempty"`
}

func (x *CodeGeneratorResponse) Reset() {
	*x = CodeGeneratorResponse{}
}

func (*CodeGeneratorResponse) ProtoMessage() {}

func (x *CodeGeneratorResponse) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *CodeGeneratorResponse) GetSupportedFeatures() uint64 {
	if x != nil && x.SupportedFeatures != nil {
		return *x.SupportedFeatures
	}
	return 0
}

func (x *CodeGeneratorResponse) GetMinimumEdition() int32 {
	if x != nil && x.MinimumEdition != nil {
		return *x.MinimumEdition
	}
	return 0
}

func (x *CodeGeneratorResponse) GetMaximumEdition() int32 {
	if x != nil && x.MaximumEdition != nil {
		return *x.MaximumEdition
	}
	return 0
}

func (x *CodeGeneratorResponse) GetFile() []*CodeGeneratorResponse_File {
	if x != nil {
		return x.File
	}
	return nil
}

// Represents a single generated file.
type CodeGeneratorResponse_File struct {
	unknownFields []byte
	// The file name, relative to the output directory.  The name must not
	// contain "." or ".." components and must be relative, not be absolute (so,
	// the file cannot lie outside the output directory).  "/" must be used as
	// the path separator, not "\".
	//
	// If the name is omitted, the content will be appended to the previous
	// file.  This allows the generator to break large files into small chunks,
	// and allows the generated text to be streamed back to protoc so that large
	// files need not reside completely in memory at one time.  Note that as of
	// this writing protoc does not optimize for this -- it will read the entire
	// CodeGeneratorResponse before writing files to disk.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// If non-empty, indicates that the named file should already exist, and the
	// content here is to be inserted into that file at a defined insertion
	// point.  This feature allows a code generator to extend the output
	// produced by another code generator.  The original generator may provide
	// insertion points by placing special annotations in the file that look
	// like:
	//
	//	@@protoc_insertion_point(NAME)
	//
	// The annotation can have arbitrary text before and after it on the line,
	// which allows it to be placed in a comment.  NAME should be replaced with
	// an identifier naming the point -- this is what other generators will use
	// as the insertion_point.  Code inserted at this point will be placed
	// immediately above the line containing the insertion point (thus multiple
	// insertions to the same point will come out in the order they were added).
	// The double-@ is intended to make it unlikely that the generated code
	// could contain things that look like insertion points by accident.
	//
	// For example, the C++ code generator places the following line in the
	// .pb.h files that it generates:
	//
	//	// @@protoc_insertion_point(namespace_scope)
	//
	// This line appears within the scope of the file's package namespace, but
	// outside of any particular class.  Another plugin can then specify the
	// insertion_point "namespace_scope" to generate additional classes or
	// other declarations that should be placed in this scope.
	//
	// Note that if the line containing the insertion point begins with
	// whitespace, the same whitespace will be added to every line of the
	// inserted text.  This is useful for languages like Python, where
	// indentation matters.  In these languages, the insertion point comment
	// should be indented the same amount as any inserted code will need to be
	// in order to work correctly in that context.
	//
	// The code generator that generates the initial file and the one which
	// inserts into it must both run as part of a single invocation of protoc.
	// Code generators are executed in the order in which they appear on the
	// command line.
	//
	// If |insertion_point| is present, |name| must also be present.
	InsertionPoint *string `protobuf:"bytes,2,opt,name=insertion_point,json=insertionPoint" json:"insertionPoint,omitempty"`
	// The file contents.
	Content *string `protobuf:"bytes,15,opt,name=content" json:"content,omitempty"`
	// Information describing the file content being inserted. If an insertion
	// point is used, this information will be appropriately offset and inserted
	// into the code generation metadata for the generated files.
	GeneratedCodeInfo *descriptorpb.GeneratedCodeInfo `protobuf:"bytes,16,opt,name=generated_code_info,json=generatedCodeInfo" json:"generatedCodeInfo,omitempty"`
}

func (x *CodeGeneratorResponse_File) Reset() {
	*x = CodeGeneratorResponse_File{}
}

func (*CodeGeneratorResponse_File) ProtoMessage() {}

func (x *CodeGeneratorResponse_File) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *CodeGeneratorResponse_File) GetInsertionPoint() string {
	if x != nil && x.InsertionPoint != nil {
		return *x.InsertionPoint
	}
	return ""
}

func (x *CodeGeneratorResponse_File) GetContent() string {
	if x != nil && x.Content != nil {
		return *x.Content
	}
	return ""
}

func (x *CodeGeneratorResponse_File) GetGeneratedCodeInfo() *descriptorpb.GeneratedCodeInfo {
	if x != nil {
		return x.GeneratedCodeInfo
	}
	return nil
}

func (m *Version) CloneVT() *Version {
	if m == nil {
		return (*Version)(nil)
	}
	r := new(Version)
	if rhs := m.Major; rhs != nil {
		tmpVal := *rhs
		r.Major = &tmpVal
	}
	if rhs := m.Minor; rhs != nil {
		tmpVal := *rhs
		r.Minor = &tmpVal
	}
	if rhs := m.Patch; rhs != nil {
		tmpVal := *rhs
		r.Patch = &tmpVal
	}
	if rhs := m.Suffix; rhs != nil {
		tmpVal := *rhs
		r.Suffix = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *Version) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *CodeGeneratorRequest) CloneVT() *CodeGeneratorRequest {
	if m == nil {
		return (*CodeGeneratorRequest)(nil)
	}
	r := new(CodeGeneratorRequest)
	r.CompilerVersion = m.CompilerVersion.CloneVT()
	if rhs := m.FileToGenerate; rhs != nil {
		r.FileToGenerate = slices.Clone(rhs)
	}
	if rhs := m.Parameter; rhs != nil {
		tmpVal := *rhs
		r.Parameter = &tmpVal
	}
	if rhs := m.ProtoFile; rhs != nil {
		r.ProtoFile = make([]*descriptorpb.FileDescriptorProto, len(rhs))
		for k, v := range rhs {
			r.ProtoFile[k] = v.CloneVT()
		}
	}
	if rhs := m.SourceFileDescriptors; rhs != nil {
		r.SourceFileDescriptors = make([]*descriptorpb.FileDescriptorProto, len(rhs))
		for k, v := range rhs {
			r.SourceFileDescriptors[k] = v.CloneVT()
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *CodeGeneratorRequest) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *CodeGeneratorResponse_File) CloneVT() *CodeGeneratorResponse_File {
	if m == nil {
		return (*CodeGeneratorResponse_File)(nil)
	}
	r := new(CodeGeneratorResponse_File)
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.InsertionPoint; rhs != nil {
		tmpVal := *rhs
		r.InsertionPoint = &tmpVal
	}
	if rhs := m.Content; rhs != nil {
		tmpVal := *rhs
		r.Content = &tmpVal
	}
	if rhs := m.GeneratedCodeInfo; rhs != nil {
		r.GeneratedCodeInfo = rhs.CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *CodeGeneratorResponse_File) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *CodeGeneratorResponse) CloneVT() *CodeGeneratorResponse {
	if m == nil {
		return (*CodeGeneratorResponse)(nil)
	}
	r := new(CodeGeneratorResponse)
	if rhs := m.Error; rhs != nil {
		tmpVal := *rhs
		r.Error = &tmpVal
	}
	if rhs := m.SupportedFeatures; rhs != nil {
		tmpVal := *rhs
		r.SupportedFeatures = &tmpVal
	}
	if rhs := m.MinimumEdition; rhs != nil {
		tmpVal := *rhs
		r.MinimumEdition = &tmpVal
	}
	if rhs := m.MaximumEdition; rhs != nil {
		tmpVal := *rhs
		r.MaximumEdition = &tmpVal
	}
	if rhs := m.File; rhs != nil {
		r.File = make([]*CodeGeneratorResponse_File, len(rhs))
		for k, v := range rhs {
			r.File[k] = v.CloneVT()
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *CodeGeneratorResponse) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (this *Version) EqualVT(that *Version) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Major, that.Major; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Minor, that.Minor; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Patch, that.Patch; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Suffix, that.Suffix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Version) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Version)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *CodeGeneratorRequest) EqualVT(that *CodeGeneratorRequest) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.FileToGenerate) != len(that.FileToGenerate) {
		return false
	}
	for i, vx := range this.FileToGenerate {
		vy := that.FileToGenerate[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.Parameter, that.Parameter; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.CompilerVersion.EqualVT(that.CompilerVersion) {
		return false
	}
	if len(this.ProtoFile) != len(that.ProtoFile) {
		return false
	}
	for i, vx := range this.ProtoFile {
		vy := that.ProtoFile[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.FileDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.FileDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.SourceFileDescriptors) != len(that.SourceFileDescriptors) {
		return false
	}
	for i, vx := range this.SourceFileDescriptors {
		vy := that.SourceFileDescriptors[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.FileDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.FileDescriptorProto{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *CodeGeneratorRequest) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*CodeGeneratorRequest)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *CodeGeneratorResponse_File) EqualVT(that *CodeGeneratorResponse_File) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.InsertionPoint, that.InsertionPoint; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Content, that.Content; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.GeneratedCodeInfo.EqualVT(that.GeneratedCodeInfo) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *CodeGeneratorResponse_File) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*CodeGeneratorResponse_File)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *CodeGeneratorResponse) EqualVT(that *CodeGeneratorResponse) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Error, that.Error; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.SupportedFeatures, that.SupportedFeatures; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MinimumEdition, that.MinimumEdition; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MaximumEdition, that.MaximumEdition; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.File) != len(that.File) {
		return false
	}
	for i, vx := range this.File {
		vy := that.File[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &CodeGeneratorResponse_File{}
			}
			if q == nil {
				q = &CodeGeneratorResponse_File{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *CodeGeneratorResponse) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*CodeGeneratorResponse)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// NOTE: protobuf-go-lite json only supports proto3: proto2 is not supported.

func (m *Version) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Version) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Suffix != nil {
		i -= len(*m.Suffix)
		copy(dAtA[i:], *m.Suffix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Suffix)))
		i--
		dAtA[i] = 0x22
	}
	if m.Patch != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Patch))
		i--
		dAtA[i] = 0x18
	}
	if m.Minor != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Minor))
		i--
		dAtA[i] = 0x10
	}
	if m.Major != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Major))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CodeGeneratorRequest) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeGeneratorRequest) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CodeGeneratorRequest) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.SourceFileDescriptors) > 0 {
		for iNdEx := len(m.SourceFileDescriptors) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.SourceFileDescriptors[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.ProtoFile) > 0 {
		for iNdEx := len(m.ProtoFile) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ProtoFile[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.CompilerVersion != nil {
		size, err := m.CompilerVersion.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Parameter != nil {
		i -= len(*m.Parameter)
		copy(dAtA[i:], *m.Parameter)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Parameter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileToGenerate) > 0 {
		for iNdEx := len(m.FileToGenerate) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileToGenerate[iNdEx])
			copy(dAtA[i:], m.FileToGenerate[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.FileToGenerate[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CodeGeneratorResponse_File) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeGeneratorResponse_File) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CodeGeneratorResponse_File) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.GeneratedCodeInfo != nil {
		size, err := m.GeneratedCodeInfo.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Content != nil {
		i -= len(*m.Content)
		copy(dAtA[i:], *m.Content)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Content)))
		i--
		dAtA[i] = 0x7a
	}
	if m.InsertionPoint != nil {
		i -= len(*m.InsertionPoint)
		copy(dAtA[i:], *m.InsertionPoint)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.InsertionPoint)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodeGeneratorResponse) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeGeneratorResponse) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *CodeGeneratorResponse) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.File) > 0 {
		for iNdEx := len(m.File) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.File[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.MaximumEdition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MaximumEdition))
		i--
		dAtA[i] = 0x20
	}
	if m.MinimumEdition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MinimumEdition))
		i--
		dAtA[i] = 0x18
	}
	if m.SupportedFeatures != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.SupportedFeatures))
		i--
		dAtA[i] = 0x10
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Version) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *Version) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Suffix != nil {
		i -= len(*m.Suffix)
		copy(dAtA[i:], *m.Suffix)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Suffix)))
		i--
		dAtA[i] = 0x22
	}
	if m.Patch != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Patch))
		i--
		dAtA[i] = 0x18
	}
	if m.Minor != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Minor))
		i--
		dAtA[i] = 0x10
	}
	if m.Major != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Major))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CodeGeneratorRequest) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeGeneratorRequest) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *CodeGeneratorRequest) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.SourceFileDescriptors) > 0 {
		for iNdEx := len(m.SourceFileDescriptors) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.SourceFileDescriptors[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.ProtoFile) > 0 {
		for iNdEx := len(m.ProtoFile) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ProtoFile[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.CompilerVersion != nil {
		size, err := m.CompilerVersion.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Parameter != nil {
		i -= len(*m.Parameter)
		copy(dAtA[i:], *m.Parameter)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Parameter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileToGenerate) > 0 {
		for iNdEx := len(m.FileToGenerate) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileToGenerate[iNdEx])
			copy(dAtA[i:], m.FileToGenerate[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.FileToGenerate[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CodeGeneratorResponse_File) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeGeneratorResponse_File) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *CodeGeneratorResponse_File) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.GeneratedCodeInfo != nil {
		size, err := m.GeneratedCodeInfo.MarshalToSizedBufferVTStrict(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Content != nil {
		i -= len(*m.Content)
		copy(dAtA[i:], *m.Content)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Content)))
		i--
		dAtA[i] = 0x7a
	}
	if m.InsertionPoint != nil {
		i -= len(*m.InsertionPoint)
		copy(dAtA[i:], *m.InsertionPoint)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.InsertionPoint)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CodeGeneratorResponse) MarshalVTStrict() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVTStrict(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CodeGeneratorResponse) MarshalToVTStrict(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVTStrict(dAtA[:size])
}

func (m *CodeGeneratorResponse) MarshalToSizedBufferVTStrict(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.File) > 0 {
		for iNdEx := len(m.File) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.File[iNdEx].MarshalToSizedBufferVTStrict(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.MaximumEdition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MaximumEdition))
		i--
		dAtA[i] = 0x20
	}
	if m.MinimumEdition != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MinimumEdition))
		i--
		dAtA[i] = 0x18
	}
	if m.SupportedFeatures != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.SupportedFeatures))
		i--
		dAtA[i] = 0x10
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Version) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Major != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Major))
	}
	if m.Minor != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Minor))
	}
	if m.Patch != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Patch))
	}
	if m.Suffix != nil {
		l = len(*m.Suffix)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *CodeGeneratorRequest) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FileToGenerate) > 0 {
		for _, s := range m.FileToGenerate {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Parameter != nil {
		l = len(*m.Parameter)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.CompilerVersion != nil {
		l = m.CompilerVersion.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.ProtoFile) > 0 {
		for _, e := range m.ProtoFile {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.SourceFileDescriptors) > 0 {
		for _, e := range m.SourceFileDescriptors {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *CodeGeneratorResponse_File) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.InsertionPoint != nil {
		l = len(*m.InsertionPoint)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Content != nil {
		l = len(*m.Content)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.GeneratedCodeInfo != nil {
		l = m.GeneratedCodeInfo.SizeVT()
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *CodeGeneratorResponse) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.SupportedFeatures != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.SupportedFeatures))
	}
	if m.MinimumEdition != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.MinimumEdition))
	}
	if m.MaximumEdition != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.MaximumEdition))
	}
	if len(m.File) > 0 {
		for _, e := range m.File {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (x *Version) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Version {")
	if x.Major != nil {
		if sb.Len() > 9 {
			sb.WriteString(" ")
		}
		sb.WriteString("major: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Major), 10))
	}
	if x.Minor != nil {
		if sb.Len() > 9 {
			sb.WriteString(" ")
		}
		sb.WriteString("minor: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Minor), 10))
	}
	if x.Patch != nil {
		if sb.Len() > 9 {
			sb.WriteString(" ")
		}
		sb.WriteString("patch: ")
		sb.WriteString(strconv.FormatInt(int64(*x.Patch), 10))
	}
	if x.Suffix != nil {
		if sb.Len() > 9 {
			sb.WriteString(" ")
		}
		sb.WriteString("suffix: ")
		sb.WriteString(strconv.Quote(*x.Suffix))
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *Version) String() string {
	return x.MarshalProtoText()
}
func (x *CodeGeneratorRequest) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("CodeGeneratorRequest {")
	if len(x.FileToGenerate) > 0 {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("file_to_generate: [")
		for i, v := range x.FileToGenerate {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.Quote(v))
		}
		sb.WriteString("]")
	}
	if x.Parameter != nil {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("parameter: ")
		sb.WriteString(strconv.Quote(*x.Parameter))
	}
	if x.CompilerVersion != nil {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("compiler_version: ")
		sb.WriteString(x.CompilerVersion.MarshalProtoText())
	}
	if len(x.ProtoFile) > 0 {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("proto_file: [")
		for i, v := range x.ProtoFile {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.SourceFileDescriptors) > 0 {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("source_file_descriptors: [")
		for i, v := range x.SourceFileDescriptors {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *CodeGeneratorRequest) String() string {
	return x.MarshalProtoText()
}
func (x CodeGeneratorResponse_Feature) MarshalProtoText() string {
	return x.String()
}
func (x *CodeGeneratorResponse_File) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("File {")
	if x.Name != nil {
		if sb.Len() > 6 {
			sb.WriteString(" ")
		}
		sb.WriteString("name: ")
		sb.WriteString(strconv.Quote(*x.Name))
	}
	if x.InsertionPoint != nil {
		if sb.Len() > 6 {
			sb.WriteString(" ")
		}
		sb.WriteString("insertion_point: ")
		sb.WriteString(strconv.Quote(*x.InsertionPoint))
	}
	if x.Content != nil {
		if sb.Len() > 6 {
			sb.WriteString(" ")
		}
		sb.WriteString("content: ")
		sb.WriteString(strconv.Quote(*x.Content))
	}
	if x.GeneratedCodeInfo != nil {
		if sb.Len() > 6 {
			sb.WriteString(" ")
		}
		sb.WriteString("generated_code_info: ")
		sb.WriteString(x.GeneratedCodeInfo.MarshalProtoText())
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *CodeGeneratorResponse_File) String() string {
	return x.MarshalProtoText()
}
func (x *CodeGeneratorResponse) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("CodeGeneratorResponse {")
	if x.Error != nil {
		if sb.Len() > 23 {
			sb.WriteString(" ")
		}
		sb.WriteString("error: ")
		sb.WriteString(strconv.Quote(*x.Error))
	}
	if x.SupportedFeatures != nil {
		if sb.Len() > 23 {
			sb.WriteString(" ")
		}
		sb.WriteString("supported_features: ")
		sb.WriteString(strconv.FormatUint(uint64(*x.SupportedFeatures), 10))
	}
	if x.MinimumEdition != nil {
		if sb.Len() > 23 {
			sb.WriteString(" ")
		}
		sb.WriteString("minimum_edition: ")
		sb.WriteString(strconv.FormatInt(int64(*x.MinimumEdition), 10))
	}
	if x.MaximumEdition != nil {
		if sb.Len() > 23 {
			sb.WriteString(" ")
		}
		sb.WriteString("maximum_edition: ")
		sb.WriteString(strconv.FormatInt(int64(*x.MaximumEdition), 10))
	}
	if len(x.File) > 0 {
		if sb.Len() > 23 {
			sb.WriteString(" ")
		}
		sb.WriteString("file: [")
		for i, v := range x.File {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *CodeGeneratorResponse) String() string {
	return x.MarshalProtoText()
}
func (m *Version) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.Major = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.Minor = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.Patch = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Suffix = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeGeneratorRequest) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeGeneratorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeGeneratorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileToGenerate", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileToGenerate = append(m.FileToGenerate, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Parameter = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompilerVersion", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompilerVersion == nil {
				m.CompilerVersion = &Version{}
			}
			if err := m.CompilerVersion.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoFile", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoFile = append(m.ProtoFile, &descriptorpb.FileDescriptorProto{})
			if err := m.ProtoFile[len(m.ProtoFile)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceFileDescriptors", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceFileDescriptors = append(m.SourceFileDescriptors, &descriptorpb.FileDescriptorProto{})
			if err := m.SourceFileDescriptors[len(m.SourceFileDescriptors)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeGeneratorResponse_File) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeGeneratorResponse_File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeGeneratorResponse_File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertionPoint", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InsertionPoint = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Content = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedCodeInfo", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeneratedCodeInfo == nil {
				m.GeneratedCodeInfo = &descriptorpb.GeneratedCodeInfo{}
			}
			if err := m.GeneratedCodeInfo.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeGeneratorResponse) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeGeneratorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeGeneratorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedFeatures", wireType)
			}
			var v uint64
			v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.SupportedFeatures = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumEdition", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.MinimumEdition = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumEdition", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.MaximumEdition = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File, &CodeGeneratorResponse_File{})
			if err := m.File[len(m.File)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.Major = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.Minor = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.Patch = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Suffix = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeGeneratorRequest) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeGeneratorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeGeneratorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileToGenerate", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			m.FileToGenerate = append(m.FileToGenerate, stringValue)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Parameter = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompilerVersion", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompilerVersion == nil {
				m.CompilerVersion = &Version{}
			}
			if err := m.CompilerVersion.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoFile", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoFile = append(m.ProtoFile, &descriptorpb.FileDescriptorProto{})
			if err := m.ProtoFile[len(m.ProtoFile)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceFileDescriptors", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceFileDescriptors = append(m.SourceFileDescriptors, &descriptorpb.FileDescriptorProto{})
			if err := m.SourceFileDescriptors[len(m.SourceFileDescriptors)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeGeneratorResponse_File) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeGeneratorResponse_File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeGeneratorResponse_File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertionPoint", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.InsertionPoint = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Content = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedCodeInfo", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeneratedCodeInfo == nil {
				m.GeneratedCodeInfo = &descriptorpb.GeneratedCodeInfo{}
			}
			if err := m.GeneratedCodeInfo.UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodeGeneratorResponse) UnmarshalVTUnsafe(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodeGeneratorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodeGeneratorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var stringValue string
			if intStringLen > 0 {
				stringValue = unsafe.String(&dAtA[iNdEx], intStringLen)
			}
			s := stringValue
			m.Error = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedFeatures", wireType)
			}
			var v uint64
			v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.SupportedFeatures = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumEdition", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.MinimumEdition = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumEdition", wireType)
			}
			var v int32
			v, iNdEx, err = protobuf_go_lite.DecodeVarintInt32(dAtA, iNdEx)
			if err != nil {
				return err
			}
			m.MaximumEdition = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File, &CodeGeneratorResponse_File{})
			if err := m.File[len(m.File)-1].UnmarshalVTUnsafe(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
